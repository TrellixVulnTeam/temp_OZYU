
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>2. Implementation Defined Pragmas &#8212; GNAT Reference Manual 2021 documentation</title>
    <link rel="stylesheet" href="../_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="3. Implementation Defined Aspects" href="implementation_defined_aspects.html" />
    <link rel="prev" title="1. About This Guide" href="about_this_guide.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="implementation_defined_aspects.html" title="3. Implementation Defined Aspects"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="about_this_guide.html" title="1. About This Guide"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../gnat_rm.html">GNAT Reference Manual 2021 documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><span class="section-number">2. </span>Implementation Defined Pragmas</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="implementation-defined-pragmas">
<span id="id1"></span><h1><span class="section-number">2. </span>Implementation Defined Pragmas<a class="headerlink" href="#implementation-defined-pragmas" title="Permalink to this headline">¶</a></h1>
<p>Ada defines a set of pragmas that can be used to supply additional
information to the compiler.  These language defined pragmas are
implemented in GNAT and work as described in the Ada Reference Manual.</p>
<p>In addition, Ada allows implementations to define additional pragmas
whose meaning is defined by the implementation.  GNAT provides a number
of these implementation-defined pragmas, which can be used to extend
and enhance the functionality of the compiler.  This section of the GNAT
Reference Manual describes these additional pragmas.</p>
<p>Note that any program using these pragmas might not be portable to other
compilers (although GNAT implements this set of pragmas on all
platforms).  Therefore if portability to other compilers is an important
consideration, the use of these pragmas should be minimized.</p>
<div class="section" id="pragma-abort-defer">
<h2><span class="section-number">2.1. </span>Pragma Abort_Defer<a class="headerlink" href="#pragma-abort-defer" title="Permalink to this headline">¶</a></h2>
<p id="index-0">Syntax:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma</span><span class="p"> </span><span class="n">Abort_Defer</span><span class="p">;</span>
</pre></div>
</div>
<p>This pragma must appear at the start of the statement sequence of a
handled sequence of statements (right after the <code class="docutils literal notranslate"><span class="pre">begin</span></code>).  It has
the effect of deferring aborts for the sequence of statements (but not
for the declarations or handlers, if any, associated with this statement
sequence). This can also be useful for adding a polling point in Ada code,
where asynchronous abort of tasks is checked when leaving the statement
sequence, and is lighter than, for example, using <code class="docutils literal notranslate"><span class="pre">delay</span> <span class="pre">0.0;</span></code>, since with
zero-cost exception handling, propagating exceptions (implicitly used to
implement task abort) cannot be done reliably in an asynchronous way.</p>
<p>An example of usage would be:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="c">--  Add a polling point to check for task aborts</span>

<span class="kr">begin</span><span class="p"></span>
   <span class="kr">pragma</span><span class="p"> </span><span class="n">Abort_Defer</span><span class="p">;</span>
<span class="kr">end</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="pragma-abstract-state">
<span id="id2"></span><h2><span class="section-number">2.2. </span>Pragma Abstract_State<a class="headerlink" href="#pragma-abstract-state" title="Permalink to this headline">¶</a></h2>
<p>Syntax:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma</span><span class="p"> </span><span class="n">Abstract_State</span> <span class="o">(</span><span class="n">ABSTRACT_STATE_LIST</span><span class="o">)</span><span class="p">;</span>

<span class="n">ABSTRACT_STATE_LIST</span> <span class="o">::=</span>
     <span class="kr">null</span><span class="p"></span>
  <span class="o">|</span>  <span class="n">STATE_NAME_WITH_OPTIONS</span>
  <span class="o">|</span> <span class="o">(</span><span class="n">STATE_NAME_WITH_OPTIONS</span> {<span class="p">,</span> <span class="n">STATE_NAME_WITH_OPTIONS</span>} <span class="o">)</span>

<span class="n">STATE_NAME_WITH_OPTIONS</span> <span class="o">::=</span>
     <span class="n">STATE_NAME</span>
  <span class="o">|</span> <span class="o">(</span><span class="n">STATE_NAME</span> <span class="kr">with</span><span class="p"> </span><span class="n">OPTION_LIST</span><span class="o">)</span>

<span class="n">OPTION_LIST</span> <span class="o">::=</span> <span class="n">OPTION</span> {<span class="p">,</span> <span class="n">OPTION</span>}

<span class="n">OPTION</span> <span class="o">::=</span>
    <span class="n">SIMPLE_OPTION</span>
  <span class="o">|</span> <span class="n">NAME_VALUE_OPTION</span>

<span class="n">SIMPLE_OPTION</span> <span class="o">::=</span> <span class="n">Ghost</span> <span class="o">|</span> <span class="n">Synchronous</span>

<span class="n">NAME_VALUE_OPTION</span> <span class="o">::=</span>
    <span class="n">Part_Of</span> <span class="o">=&gt;</span> <span class="n">ABSTRACT_STATE</span>
  <span class="o">|</span> <span class="n">External</span> [<span class="o">=&gt;</span> <span class="n">EXTERNAL_PROPERTY_LIST</span>]

<span class="n">EXTERNAL_PROPERTY_LIST</span> <span class="o">::=</span>
     <span class="n">EXTERNAL_PROPERTY</span>
  <span class="o">|</span> <span class="o">(</span><span class="n">EXTERNAL_PROPERTY</span> {<span class="p">,</span> <span class="n">EXTERNAL_PROPERTY</span>} <span class="o">)</span>

<span class="n">EXTERNAL_PROPERTY</span> <span class="o">::=</span>
    <span class="n">Async_Readers</span>    [<span class="o">=&gt;</span> <span class="n">boolean_EXPRESSION</span>]
  <span class="o">|</span> <span class="n">Async_Writers</span>    [<span class="o">=&gt;</span> <span class="n">boolean_EXPRESSION</span>]
  <span class="o">|</span> <span class="n">Effective_Reads</span>  [<span class="o">=&gt;</span> <span class="n">boolean_EXPRESSION</span>]
  <span class="o">|</span> <span class="n">Effective_Writes</span> [<span class="o">=&gt;</span> <span class="n">boolean_EXPRESSION</span>]
    <span class="kr">others</span><span class="p"> </span>           <span class="o">=&gt;</span> <span class="n">boolean_EXPRESSION</span>

<span class="n">STATE_NAME</span> <span class="o">::=</span> <span class="n">defining_identifier</span>

<span class="n">ABSTRACT_STATE</span> <span class="o">::=</span> <span class="n">name</span>
</pre></div>
</div>
<p>For the semantics of this pragma, see the entry for aspect <code class="docutils literal notranslate"><span class="pre">Abstract_State</span></code> in
the SPARK 2014 Reference Manual, section 7.1.4.</p>
</div>
<div class="section" id="pragma-ada-83">
<h2><span class="section-number">2.3. </span>Pragma Ada_83<a class="headerlink" href="#pragma-ada-83" title="Permalink to this headline">¶</a></h2>
<p>Syntax:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma</span><span class="p"> </span><span class="n">Ada_83</span><span class="p">;</span>
</pre></div>
</div>
<p>A configuration pragma that establishes Ada 83 mode for the unit to
which it applies, regardless of the mode set by the command line
switches.  In Ada 83 mode, GNAT attempts to be as compatible with
the syntax and semantics of Ada 83, as defined in the original Ada
83 Reference Manual as possible.  In particular, the keywords added by Ada 95
and Ada 2005 are not recognized, optional package bodies are allowed,
and generics may name types with unknown discriminants without using
the <code class="docutils literal notranslate"><span class="pre">(&lt;&gt;)</span></code> notation.  In addition, some but not all of the additional
restrictions of Ada 83 are enforced.</p>
<p>Ada 83 mode is intended for two purposes.  Firstly, it allows existing
Ada 83 code to be compiled and adapted to GNAT with less effort.
Secondly, it aids in keeping code backwards compatible with Ada 83.
However, there is no guarantee that code that is processed correctly
by GNAT in Ada 83 mode will in fact compile and execute with an Ada
83 compiler, since GNAT does not enforce all the additional checks
required by Ada 83.</p>
</div>
<div class="section" id="pragma-ada-95">
<h2><span class="section-number">2.4. </span>Pragma Ada_95<a class="headerlink" href="#pragma-ada-95" title="Permalink to this headline">¶</a></h2>
<p>Syntax:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma</span><span class="p"> </span><span class="n">Ada_95</span><span class="p">;</span>
</pre></div>
</div>
<p>A configuration pragma that establishes Ada 95 mode for the unit to which
it applies, regardless of the mode set by the command line switches.
This mode is set automatically for the <code class="docutils literal notranslate"><span class="pre">Ada</span></code> and <code class="docutils literal notranslate"><span class="pre">System</span></code>
packages and their children, so you need not specify it in these
contexts.  This pragma is useful when writing a reusable component that
itself uses Ada 95 features, but which is intended to be usable from
either Ada 83 or Ada 95 programs.</p>
</div>
<div class="section" id="pragma-ada-05">
<h2><span class="section-number">2.5. </span>Pragma Ada_05<a class="headerlink" href="#pragma-ada-05" title="Permalink to this headline">¶</a></h2>
<p>Syntax:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma</span><span class="p"> </span><span class="n">Ada_05</span><span class="p">;</span>
<span class="kr">pragma</span><span class="p"> </span><span class="n">Ada_05</span> <span class="o">(</span><span class="n">local_NAME</span><span class="o">)</span><span class="p">;</span>
</pre></div>
</div>
<p>A configuration pragma that establishes Ada 2005 mode for the unit to which
it applies, regardless of the mode set by the command line switches.
This pragma is useful when writing a reusable component that
itself uses Ada 2005 features, but which is intended to be usable from
either Ada 83 or Ada 95 programs.</p>
<p>The one argument form (which is not a configuration pragma)
is used for managing the transition from
Ada 95 to Ada 2005 in the run-time library. If an entity is marked
as Ada_2005 only, then referencing the entity in Ada_83 or Ada_95
mode will generate a warning. In addition, in Ada_83 or Ada_95
mode, a preference rule is established which does not choose
such an entity unless it is unambiguously specified. This avoids
extra subprograms marked this way from generating ambiguities in
otherwise legal pre-Ada_2005 programs. The one argument form is
intended for exclusive use in the GNAT run-time library.</p>
</div>
<div class="section" id="pragma-ada-2005">
<h2><span class="section-number">2.6. </span>Pragma Ada_2005<a class="headerlink" href="#pragma-ada-2005" title="Permalink to this headline">¶</a></h2>
<p>Syntax:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma</span><span class="p"> </span><span class="n">Ada_2005</span><span class="p">;</span>
</pre></div>
</div>
<p>This configuration pragma is a synonym for pragma Ada_05 and has the
same syntax and effect.</p>
</div>
<div class="section" id="pragma-ada-12">
<h2><span class="section-number">2.7. </span>Pragma Ada_12<a class="headerlink" href="#pragma-ada-12" title="Permalink to this headline">¶</a></h2>
<p>Syntax:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma</span><span class="p"> </span><span class="n">Ada_12</span><span class="p">;</span>
<span class="kr">pragma</span><span class="p"> </span><span class="n">Ada_12</span> <span class="o">(</span><span class="n">local_NAME</span><span class="o">)</span><span class="p">;</span>
</pre></div>
</div>
<p>A configuration pragma that establishes Ada 2012 mode for the unit to which
it applies, regardless of the mode set by the command line switches.
This mode is set automatically for the <code class="docutils literal notranslate"><span class="pre">Ada</span></code> and <code class="docutils literal notranslate"><span class="pre">System</span></code>
packages and their children, so you need not specify it in these
contexts.  This pragma is useful when writing a reusable component that
itself uses Ada 2012 features, but which is intended to be usable from
Ada 83, Ada 95, or Ada 2005 programs.</p>
<p>The one argument form, which is not a configuration pragma,
is used for managing the transition from Ada
2005 to Ada 2012 in the run-time library. If an entity is marked
as Ada_2012 only, then referencing the entity in any pre-Ada_2012
mode will generate a warning. In addition, in any pre-Ada_2012
mode, a preference rule is established which does not choose
such an entity unless it is unambiguously specified. This avoids
extra subprograms marked this way from generating ambiguities in
otherwise legal pre-Ada_2012 programs. The one argument form is
intended for exclusive use in the GNAT run-time library.</p>
</div>
<div class="section" id="pragma-ada-2012">
<h2><span class="section-number">2.8. </span>Pragma Ada_2012<a class="headerlink" href="#pragma-ada-2012" title="Permalink to this headline">¶</a></h2>
<p>Syntax:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma</span><span class="p"> </span><span class="n">Ada_2012</span><span class="p">;</span>
</pre></div>
</div>
<p>This configuration pragma is a synonym for pragma Ada_12 and has the
same syntax and effect.</p>
</div>
<div class="section" id="pragma-aggregate-individually-assign">
<h2><span class="section-number">2.9. </span>Pragma Aggregate_Individually_Assign<a class="headerlink" href="#pragma-aggregate-individually-assign" title="Permalink to this headline">¶</a></h2>
<p>Syntax:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma</span><span class="p"> </span><span class="n">Aggregate_Individually_Assign</span><span class="p">;</span>
</pre></div>
</div>
<p>Where possible, GNAT will store the binary representation of a record aggregate
in memory for space and performance reasons. This configuration pragma changes
this behavior so that record aggregates are instead always converted into
individual assignment statements.</p>
</div>
<div class="section" id="pragma-allow-integer-address">
<h2><span class="section-number">2.10. </span>Pragma Allow_Integer_Address<a class="headerlink" href="#pragma-allow-integer-address" title="Permalink to this headline">¶</a></h2>
<p>Syntax:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma</span><span class="p"> </span><span class="n">Allow_Integer_Address</span><span class="p">;</span>
</pre></div>
</div>
<p>In almost all versions of GNAT, <code class="docutils literal notranslate"><span class="pre">System.Address</span></code> is a private
type in accordance with the implementation advice in the RM. This
means that integer values,
in particular integer literals, are not allowed as address values.
If the configuration pragma
<code class="docutils literal notranslate"><span class="pre">Allow_Integer_Address</span></code> is given, then integer expressions may
be used anywhere a value of type <code class="docutils literal notranslate"><span class="pre">System.Address</span></code> is required.
The effect is to introduce an implicit unchecked conversion from the
integer value to type <code class="docutils literal notranslate"><span class="pre">System.Address</span></code>. The reverse case of using
an address where an integer type is required is handled analogously.
The following example compiles without errors:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma</span><span class="p"> </span><span class="n">Allow_Integer_Address</span><span class="p">;</span>
<span class="kr">with</span><span class="nn"> System;</span> <span class="kr">use</span><span class="p"> </span><span class="n">System</span><span class="p">;</span>
<span class="k">package </span><span class="nf">AddrAsInt</span> <span class="kr">is</span><span class="p"></span>
   <span class="n">X</span> <span class="o">:</span> <span class="n">Integer</span><span class="p">;</span>
   <span class="n">Y</span> <span class="o">:</span> <span class="n">Integer</span><span class="p">;</span>
   <span class="kr">for</span><span class="p"> </span><span class="n">X</span><span class="na">&#39;Address</span> <span class="kr">use</span><span class="p"> </span><span class="mi">16#1240#</span><span class="p">;</span>
   <span class="kr">for</span><span class="p"> </span><span class="n">Y</span> <span class="kr">use</span><span class="p"> </span><span class="kr">at</span><span class="p"> </span><span class="mi">16#3230#</span><span class="p">;</span>
   <span class="n">m</span> <span class="o">:</span> <span class="n">Address</span> <span class="o">:=</span> <span class="mi">16#4000#</span><span class="p">;</span>
   <span class="n">n</span> <span class="o">:</span> <span class="kr">constant</span><span class="p"> </span><span class="n">Address</span> <span class="o">:=</span> <span class="mi">4000</span><span class="p">;</span>
   <span class="n">p</span> <span class="o">:</span> <span class="kr">constant</span><span class="p"> </span><span class="n">Address</span> <span class="o">:=</span> <span class="n">Address</span> <span class="o">(</span><span class="n">X</span> <span class="o">+</span> <span class="n">Y</span><span class="o">)</span><span class="p">;</span>
   <span class="n">v</span> <span class="o">:</span> <span class="n">Integer</span> <span class="o">:=</span> <span class="n">y</span><span class="na">&#39;Address</span><span class="p">;</span>
   <span class="n">w</span> <span class="o">:</span> <span class="kr">constant</span><span class="p"> </span><span class="n">Integer</span> <span class="o">:=</span> <span class="n">Integer</span> <span class="o">(</span><span class="n">Y</span><span class="na">&#39;Address</span><span class="o">)</span><span class="p">;</span>
   <span class="kr">type</span><span class="p"> </span><span class="n">R</span> <span class="kr">is</span><span class="p"> </span><span class="kr">new</span><span class="p"> </span><span class="n">integer</span><span class="p">;</span>
   <span class="n">RR</span> <span class="o">:</span> <span class="n">R</span> <span class="o">:=</span> <span class="mi">1000</span><span class="p">;</span>
   <span class="n">Z</span> <span class="o">:</span> <span class="n">Integer</span><span class="p">;</span>
   <span class="kr">for</span><span class="p"> </span><span class="n">Z</span><span class="na">&#39;Address</span> <span class="kr">use</span><span class="p"> </span><span class="n">RR</span><span class="p">;</span>
<span class="k">end </span><span class="nf">AddrAsInt</span><span class="p">;</span>
</pre></div>
</div>
<p>Note that pragma <code class="docutils literal notranslate"><span class="pre">Allow_Integer_Address</span></code> is ignored if <code class="docutils literal notranslate"><span class="pre">System.Address</span></code>
is not a private type. In implementations of <code class="docutils literal notranslate"><span class="pre">GNAT</span></code> where
System.Address is a visible integer type,
this pragma serves no purpose but is ignored
rather than rejected to allow common sets of sources to be used
in the two situations.</p>
</div>
<div class="section" id="pragma-annotate">
<span id="id3"></span><h2><span class="section-number">2.11. </span>Pragma Annotate<a class="headerlink" href="#pragma-annotate" title="Permalink to this headline">¶</a></h2>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pragma</span> <span class="n">Annotate</span> <span class="p">(</span><span class="n">IDENTIFIER</span> <span class="p">[,</span> <span class="n">IDENTIFIER</span> <span class="p">{,</span> <span class="n">ARG</span><span class="p">}]</span> <span class="p">[,</span> <span class="n">entity</span> <span class="o">=&gt;</span> <span class="n">local_NAME</span><span class="p">]);</span>

<span class="n">ARG</span> <span class="p">:</span><span class="o">:=</span> <span class="n">NAME</span> <span class="o">|</span> <span class="n">EXPRESSION</span>
</pre></div>
</div>
<p>This pragma is used to annotate programs.  IDENTIFIER identifies
the type of annotation.  GNAT verifies that it is an identifier, but does
not otherwise analyze it. The second optional identifier is also left
unanalyzed, and by convention is used to control the action of the tool to
which the annotation is addressed.  The remaining ARG arguments
can be either string literals or more generally expressions.
String literals (and concatenations of string literals) are assumed to be
either of type
<code class="docutils literal notranslate"><span class="pre">Standard.String</span></code> or else <code class="docutils literal notranslate"><span class="pre">Wide_String</span></code> or <code class="docutils literal notranslate"><span class="pre">Wide_Wide_String</span></code>
depending on the character literals they contain.
All other kinds of arguments are analyzed as expressions, and must be
unambiguous. The last argument if present must have the identifier
<code class="docutils literal notranslate"><span class="pre">Entity</span></code> and GNAT verifies that a local name is given.</p>
<p>The analyzed pragma is retained in the tree, but not otherwise processed
by any part of the GNAT compiler, except to generate corresponding note
lines in the generated ALI file. For the format of these note lines, see
the compiler source file lib-writ.ads. This pragma is intended for use by
external tools, including ASIS. The use of pragma Annotate does not
affect the compilation process in any way. This pragma may be used as
a configuration pragma.</p>
</div>
<div class="section" id="pragma-assert">
<h2><span class="section-number">2.12. </span>Pragma Assert<a class="headerlink" href="#pragma-assert" title="Permalink to this headline">¶</a></h2>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pragma</span> <span class="n">Assert</span> <span class="p">(</span>
  <span class="n">boolean_EXPRESSION</span>
  <span class="p">[,</span> <span class="n">string_EXPRESSION</span><span class="p">]);</span>
</pre></div>
</div>
<p>The effect of this pragma depends on whether the corresponding command
line switch is set to activate assertions.  The pragma expands into code
equivalent to the following:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">if</span><span class="p"> </span><span class="n">assertions</span><span class="o">-</span><span class="n">enabled</span> <span class="kr">then</span><span class="p"></span>
   <span class="kr">if</span><span class="p"> </span><span class="kr">not</span><span class="p"> </span><span class="n">boolean_EXPRESSION</span> <span class="kr">then</span><span class="p"></span>
      <span class="n">System.Assertions.Raise_Assert_Failure</span>
        <span class="o">(</span><span class="n">string_EXPRESSION</span><span class="o">)</span><span class="p">;</span>
   <span class="k">end if</span><span class="p">;</span>
<span class="k">end if</span><span class="p">;</span>
</pre></div>
</div>
<p>The string argument, if given, is the message that will be associated
with the exception occurrence if the exception is raised.  If no second
argument is given, the default message is <code class="docutils literal notranslate"><span class="pre">file</span></code>:<code class="docutils literal notranslate"><span class="pre">nnn</span></code>,
where <code class="docutils literal notranslate"><span class="pre">file</span></code> is the name of the source file containing the assert,
and <code class="docutils literal notranslate"><span class="pre">nnn</span></code> is the line number of the assert.</p>
<p>Note that, as with the <code class="docutils literal notranslate"><span class="pre">if</span></code> statement to which it is equivalent, the
type of the expression is either <code class="docutils literal notranslate"><span class="pre">Standard.Boolean</span></code>, or any type derived
from this standard type.</p>
<p>Assert checks can be either checked or ignored. By default they are ignored.
They will be checked if either the command line switch <em>-gnata</em> is
used, or if an <code class="docutils literal notranslate"><span class="pre">Assertion_Policy</span></code> or <code class="docutils literal notranslate"><span class="pre">Check_Policy</span></code> pragma is used
to enable <code class="docutils literal notranslate"><span class="pre">Assert_Checks</span></code>.</p>
<p>If assertions are ignored, then there
is no run-time effect (and in particular, any side effects from the
expression will not occur at run time).  (The expression is still
analyzed at compile time, and may cause types to be frozen if they are
mentioned here for the first time).</p>
<p>If assertions are checked, then the given expression is tested, and if
it is <code class="docutils literal notranslate"><span class="pre">False</span></code> then <code class="docutils literal notranslate"><span class="pre">System.Assertions.Raise_Assert_Failure</span></code> is called
which results in the raising of <code class="docutils literal notranslate"><span class="pre">Assert_Failure</span></code> with the given message.</p>
<p>You should generally avoid side effects in the expression arguments of
this pragma, because these side effects will turn on and off with the
setting of the assertions mode, resulting in assertions that have an
effect on the program.  However, the expressions are analyzed for
semantic correctness whether or not assertions are enabled, so turning
assertions on and off cannot affect the legality of a program.</p>
<p>Note that the implementation defined policy <code class="docutils literal notranslate"><span class="pre">DISABLE</span></code>, given in a
pragma <code class="docutils literal notranslate"><span class="pre">Assertion_Policy</span></code>, can be used to suppress this semantic analysis.</p>
<p>Note: this is a standard language-defined pragma in versions
of Ada from 2005 on. In GNAT, it is implemented in all versions
of Ada, and the DISABLE policy is an implementation-defined
addition.</p>
</div>
<div class="section" id="pragma-assert-and-cut">
<h2><span class="section-number">2.13. </span>Pragma Assert_And_Cut<a class="headerlink" href="#pragma-assert-and-cut" title="Permalink to this headline">¶</a></h2>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pragma</span> <span class="n">Assert_And_Cut</span> <span class="p">(</span>
  <span class="n">boolean_EXPRESSION</span>
  <span class="p">[,</span> <span class="n">string_EXPRESSION</span><span class="p">]);</span>
</pre></div>
</div>
<p>The effect of this pragma is identical to that of pragma <code class="docutils literal notranslate"><span class="pre">Assert</span></code>,
except that in an <code class="docutils literal notranslate"><span class="pre">Assertion_Policy</span></code> pragma, the identifier
<code class="docutils literal notranslate"><span class="pre">Assert_And_Cut</span></code> is used to control whether it is ignored or checked
(or disabled).</p>
<p>The intention is that this be used within a subprogram when the
given test expresion sums up all the work done so far in the
subprogram, so that the rest of the subprogram can be verified
(informally or formally) using only the entry preconditions,
and the expression in this pragma. This allows dividing up
a subprogram into sections for the purposes of testing or
formal verification. The pragma also serves as useful
documentation.</p>
</div>
<div class="section" id="pragma-assertion-policy">
<h2><span class="section-number">2.14. </span>Pragma Assertion_Policy<a class="headerlink" href="#pragma-assertion-policy" title="Permalink to this headline">¶</a></h2>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pragma</span> <span class="n">Assertion_Policy</span> <span class="p">(</span><span class="n">CHECK</span> <span class="o">|</span> <span class="n">DISABLE</span> <span class="o">|</span> <span class="n">IGNORE</span> <span class="o">|</span> <span class="n">SUPPRESSIBLE</span><span class="p">);</span>

<span class="n">pragma</span> <span class="n">Assertion_Policy</span> <span class="p">(</span>
    <span class="n">ASSERTION_KIND</span> <span class="o">=&gt;</span> <span class="n">POLICY_IDENTIFIER</span>
 <span class="p">{,</span> <span class="n">ASSERTION_KIND</span> <span class="o">=&gt;</span> <span class="n">POLICY_IDENTIFIER</span><span class="p">});</span>

<span class="n">ASSERTION_KIND</span> <span class="p">:</span><span class="o">:=</span> <span class="n">RM_ASSERTION_KIND</span> <span class="o">|</span> <span class="n">ID_ASSERTION_KIND</span>

<span class="n">RM_ASSERTION_KIND</span> <span class="p">:</span><span class="o">:=</span> <span class="n">Assert</span>                    <span class="o">|</span>
                      <span class="n">Static_Predicate</span>          <span class="o">|</span>
                      <span class="n">Dynamic_Predicate</span>         <span class="o">|</span>
                      <span class="n">Pre</span>                       <span class="o">|</span>
                      <span class="n">Pre</span><span class="s1">&#39;Class                 |</span>
                      <span class="n">Post</span>                      <span class="o">|</span>
                      <span class="n">Post</span><span class="s1">&#39;Class                |</span>
                      <span class="n">Type_Invariant</span>            <span class="o">|</span>
                      <span class="n">Type_Invariant</span><span class="s1">&#39;Class      |</span>
                      <span class="n">Default_Initial_Condition</span>

<span class="n">ID_ASSERTION_KIND</span> <span class="p">:</span><span class="o">:=</span> <span class="n">Assertions</span>           <span class="o">|</span>
                      <span class="n">Assert_And_Cut</span>       <span class="o">|</span>
                      <span class="n">Assume</span>               <span class="o">|</span>
                      <span class="n">Contract_Cases</span>       <span class="o">|</span>
                      <span class="n">Debug</span>                <span class="o">|</span>
                      <span class="n">Ghost</span>                <span class="o">|</span>
                      <span class="n">Initial_Condition</span>    <span class="o">|</span>
                      <span class="n">Invariant</span>            <span class="o">|</span>
                      <span class="n">Invariant</span><span class="s1">&#39;Class      |</span>
                      <span class="n">Loop_Invariant</span>       <span class="o">|</span>
                      <span class="n">Loop_Variant</span>         <span class="o">|</span>
                      <span class="n">Postcondition</span>        <span class="o">|</span>
                      <span class="n">Precondition</span>         <span class="o">|</span>
                      <span class="n">Predicate</span>            <span class="o">|</span>
                      <span class="n">Refined_Post</span>         <span class="o">|</span>
                      <span class="n">Statement_Assertions</span> <span class="o">|</span>
                      <span class="n">Subprogram_Variant</span>

<span class="n">POLICY_IDENTIFIER</span> <span class="p">:</span><span class="o">:=</span> <span class="n">Check</span> <span class="o">|</span> <span class="n">Disable</span> <span class="o">|</span> <span class="n">Ignore</span> <span class="o">|</span> <span class="n">Suppressible</span>
</pre></div>
</div>
<p>This is a standard Ada 2012 pragma that is available as an
implementation-defined pragma in earlier versions of Ada.
The assertion kinds <code class="docutils literal notranslate"><span class="pre">RM_ASSERTION_KIND</span></code> are those defined in
the Ada standard. The assertion kinds <code class="docutils literal notranslate"><span class="pre">ID_ASSERTION_KIND</span></code>
are implementation defined additions recognized by the GNAT compiler.</p>
<p>The pragma applies in both cases to pragmas and aspects with matching
names, e.g. <code class="docutils literal notranslate"><span class="pre">Pre</span></code> applies to the Pre aspect, and <code class="docutils literal notranslate"><span class="pre">Precondition</span></code>
applies to both the <code class="docutils literal notranslate"><span class="pre">Precondition</span></code> pragma
and the aspect <code class="docutils literal notranslate"><span class="pre">Precondition</span></code>. Note that the identifiers for
pragmas Pre_Class and Post_Class are Pre’Class and Post’Class (not
Pre_Class and Post_Class), since these pragmas are intended to be
identical to the corresponding aspects).</p>
<p>If the policy is <code class="docutils literal notranslate"><span class="pre">CHECK</span></code>, then assertions are enabled, i.e.
the corresponding pragma or aspect is activated.
If the policy is <code class="docutils literal notranslate"><span class="pre">IGNORE</span></code>, then assertions are ignored, i.e.
the corresponding pragma or aspect is deactivated.
This pragma overrides the effect of the <em>-gnata</em> switch on the
command line.
If the policy is <code class="docutils literal notranslate"><span class="pre">SUPPRESSIBLE</span></code>, then assertions are enabled by default,
however, if the <em>-gnatp</em> switch is specified all assertions are ignored.</p>
<p>The implementation defined policy <code class="docutils literal notranslate"><span class="pre">DISABLE</span></code> is like
<code class="docutils literal notranslate"><span class="pre">IGNORE</span></code> except that it completely disables semantic
checking of the corresponding pragma or aspect. This is
useful when the pragma or aspect argument references subprograms
in a with’ed package which is replaced by a dummy package
for the final build.</p>
<p>The implementation defined assertion kind <code class="docutils literal notranslate"><span class="pre">Assertions</span></code> applies to all
assertion kinds. The form with no assertion kind given implies this
choice, so it applies to all assertion kinds (RM defined, and
implementation defined).</p>
<p>The implementation defined assertion kind <code class="docutils literal notranslate"><span class="pre">Statement_Assertions</span></code>
applies to <code class="docutils literal notranslate"><span class="pre">Assert</span></code>, <code class="docutils literal notranslate"><span class="pre">Assert_And_Cut</span></code>,
<code class="docutils literal notranslate"><span class="pre">Assume</span></code>, <code class="docutils literal notranslate"><span class="pre">Loop_Invariant</span></code>, and <code class="docutils literal notranslate"><span class="pre">Loop_Variant</span></code>.</p>
</div>
<div class="section" id="pragma-assume">
<h2><span class="section-number">2.15. </span>Pragma Assume<a class="headerlink" href="#pragma-assume" title="Permalink to this headline">¶</a></h2>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pragma</span> <span class="n">Assume</span> <span class="p">(</span>
  <span class="n">boolean_EXPRESSION</span>
  <span class="p">[,</span> <span class="n">string_EXPRESSION</span><span class="p">]);</span>
</pre></div>
</div>
<p>The effect of this pragma is identical to that of pragma <code class="docutils literal notranslate"><span class="pre">Assert</span></code>,
except that in an <code class="docutils literal notranslate"><span class="pre">Assertion_Policy</span></code> pragma, the identifier
<code class="docutils literal notranslate"><span class="pre">Assume</span></code> is used to control whether it is ignored or checked
(or disabled).</p>
<p>The intention is that this be used for assumptions about the
external environment. So you cannot expect to verify formally
or informally that the condition is met, this must be
established by examining things outside the program itself.
For example, we may have code that depends on the size of
<code class="docutils literal notranslate"><span class="pre">Long_Long_Integer</span></code> being at least 64. So we could write:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma</span><span class="p"> </span><span class="n">Assume</span> <span class="o">(</span><span class="n">Long_Long_Integer</span><span class="na">&#39;Size</span> <span class="o">&gt;=</span> <span class="mi">64</span><span class="o">)</span><span class="p">;</span>
</pre></div>
</div>
<p>This assumption cannot be proved from the program itself,
but it acts as a useful run-time check that the assumption
is met, and documents the need to ensure that it is met by
reference to information outside the program.</p>
</div>
<div class="section" id="pragma-assume-no-invalid-values">
<h2><span class="section-number">2.16. </span>Pragma Assume_No_Invalid_Values<a class="headerlink" href="#pragma-assume-no-invalid-values" title="Permalink to this headline">¶</a></h2>
<span class="target" id="index-1"></span><p id="index-2">Syntax:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma</span><span class="p"> </span><span class="n">Assume_No_Invalid_Values</span> <span class="o">(</span><span class="n">On</span> <span class="o">|</span> <span class="n">Off</span><span class="o">)</span><span class="p">;</span>
</pre></div>
</div>
<p>This is a configuration pragma that controls the assumptions made by the
compiler about the occurrence of invalid representations (invalid values)
in the code.</p>
<p>The default behavior (corresponding to an Off argument for this pragma), is
to assume that values may in general be invalid unless the compiler can
prove they are valid. Consider the following example:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="n">V1</span> <span class="o">:</span> <span class="n">Integer</span> <span class="kr">range</span><span class="p"> </span><span class="mi">1</span> <span class="o">..</span> <span class="mi">10</span><span class="p">;</span>
<span class="n">V2</span> <span class="o">:</span> <span class="n">Integer</span> <span class="kr">range</span><span class="p"> </span><span class="mi">11</span> <span class="o">..</span> <span class="mi">20</span><span class="p">;</span>
<span class="o">...</span>
<span class="kr">for</span><span class="p"> </span><span class="n">J</span> <span class="kr">in</span><span class="p"> </span><span class="n">V2</span> <span class="o">..</span> <span class="n">V1</span> <span class="kr">loop</span><span class="p"></span>
   <span class="o">...</span>
<span class="k">end loop</span><span class="p">;</span>
</pre></div>
</div>
<p>if V1 and V2 have valid values, then the loop is known at compile
time not to execute since the lower bound must be greater than the
upper bound. However in default mode, no such assumption is made,
and the loop may execute. If <code class="docutils literal notranslate"><span class="pre">Assume_No_Invalid_Values</span> <span class="pre">(On)</span></code>
is given, the compiler will assume that any occurrence of a variable
other than in an explicit <code class="docutils literal notranslate"><span class="pre">'Valid</span></code> test always has a valid
value, and the loop above will be optimized away.</p>
<p>The use of <code class="docutils literal notranslate"><span class="pre">Assume_No_Invalid_Values</span> <span class="pre">(On)</span></code> is appropriate if
you know your code is free of uninitialized variables and other
possible sources of invalid representations, and may result in
more efficient code. A program that accesses an invalid representation
with this pragma in effect is erroneous, so no guarantees can be made
about its behavior.</p>
<p>It is peculiar though permissible to use this pragma in conjunction
with validity checking (-gnatVa). In such cases, accessing invalid
values will generally give an exception, though formally the program
is erroneous so there are no guarantees that this will always be the
case, and it is recommended that these two options not be used together.</p>
</div>
<div class="section" id="pragma-async-readers">
<span id="id4"></span><h2><span class="section-number">2.17. </span>Pragma Async_Readers<a class="headerlink" href="#pragma-async-readers" title="Permalink to this headline">¶</a></h2>
<p>Syntax:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma</span><span class="p"> </span><span class="n">Async_Readers</span> [ <span class="o">(</span><span class="n">boolean_EXPRESSION</span><span class="o">)</span> ]<span class="p">;</span>
</pre></div>
</div>
<p>For the semantics of this pragma, see the entry for aspect <code class="docutils literal notranslate"><span class="pre">Async_Readers</span></code> in
the SPARK 2014 Reference Manual, section 7.1.2.</p>
</div>
<div class="section" id="pragma-async-writers">
<span id="id5"></span><h2><span class="section-number">2.18. </span>Pragma Async_Writers<a class="headerlink" href="#pragma-async-writers" title="Permalink to this headline">¶</a></h2>
<p>Syntax:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma</span><span class="p"> </span><span class="n">Async_Writers</span> [ <span class="o">(</span><span class="n">boolean_EXPRESSION</span><span class="o">)</span> ]<span class="p">;</span>
</pre></div>
</div>
<p>For the semantics of this pragma, see the entry for aspect <code class="docutils literal notranslate"><span class="pre">Async_Writers</span></code> in
the SPARK 2014 Reference Manual, section 7.1.2.</p>
</div>
<div class="section" id="pragma-attribute-definition">
<h2><span class="section-number">2.19. </span>Pragma Attribute_Definition<a class="headerlink" href="#pragma-attribute-definition" title="Permalink to this headline">¶</a></h2>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pragma</span> <span class="n">Attribute_Definition</span>
  <span class="p">([</span><span class="n">Attribute</span>  <span class="o">=&gt;</span><span class="p">]</span> <span class="n">ATTRIBUTE_DESIGNATOR</span><span class="p">,</span>
   <span class="p">[</span><span class="n">Entity</span>     <span class="o">=&gt;</span><span class="p">]</span> <span class="n">LOCAL_NAME</span><span class="p">,</span>
   <span class="p">[</span><span class="n">Expression</span> <span class="o">=&gt;</span><span class="p">]</span> <span class="n">EXPRESSION</span> <span class="o">|</span> <span class="n">NAME</span><span class="p">);</span>
</pre></div>
</div>
<p>If <code class="docutils literal notranslate"><span class="pre">Attribute</span></code> is a known attribute name, this pragma is equivalent to
the attribute definition clause:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">for</span><span class="p"> </span><span class="n">Entity</span><span class="o">&#39;</span><span class="n">Attribute</span> <span class="kr">use</span><span class="p"> </span><span class="n">Expression</span><span class="p">;</span>
</pre></div>
</div>
<p>If <code class="docutils literal notranslate"><span class="pre">Attribute</span></code> is not a recognized attribute name, the pragma is
ignored, and a warning is emitted. This allows source
code to be written that takes advantage of some new attribute, while remaining
compilable with earlier compilers.</p>
</div>
<div class="section" id="pragma-c-pass-by-copy">
<h2><span class="section-number">2.20. </span>Pragma C_Pass_By_Copy<a class="headerlink" href="#pragma-c-pass-by-copy" title="Permalink to this headline">¶</a></h2>
<p id="index-3">Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pragma</span> <span class="n">C_Pass_By_Copy</span>
  <span class="p">([</span><span class="n">Max_Size</span> <span class="o">=&gt;</span><span class="p">]</span> <span class="n">static_integer_EXPRESSION</span><span class="p">);</span>
</pre></div>
</div>
<p>Normally the default mechanism for passing C convention records to C
convention subprograms is to pass them by reference, as suggested by RM
B.3(69).  Use the configuration pragma <code class="docutils literal notranslate"><span class="pre">C_Pass_By_Copy</span></code> to change
this default, by requiring that record formal parameters be passed by
copy if all of the following conditions are met:</p>
<ul class="simple">
<li><p>The size of the record type does not exceed the value specified for
<code class="docutils literal notranslate"><span class="pre">Max_Size</span></code>.</p></li>
<li><p>The record type has <code class="docutils literal notranslate"><span class="pre">Convention</span> <span class="pre">C</span></code>.</p></li>
<li><p>The formal parameter has this record type, and the subprogram has a
foreign (non-Ada) convention.</p></li>
</ul>
<p>If these conditions are met the argument is passed by copy; i.e., in a
manner consistent with what C expects if the corresponding formal in the
C prototype is a struct (rather than a pointer to a struct).</p>
<p>You can also pass records by copy by specifying the convention
<code class="docutils literal notranslate"><span class="pre">C_Pass_By_Copy</span></code> for the record type, or by using the extended
<code class="docutils literal notranslate"><span class="pre">Import</span></code> and <code class="docutils literal notranslate"><span class="pre">Export</span></code> pragmas, which allow specification of
passing mechanisms on a parameter by parameter basis.</p>
</div>
<div class="section" id="pragma-check">
<h2><span class="section-number">2.21. </span>Pragma Check<a class="headerlink" href="#pragma-check" title="Permalink to this headline">¶</a></h2>
<span class="target" id="index-4"></span><p id="index-5">Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pragma</span> <span class="n">Check</span> <span class="p">(</span>
     <span class="p">[</span><span class="n">Name</span>    <span class="o">=&gt;</span><span class="p">]</span> <span class="n">CHECK_KIND</span><span class="p">,</span>
     <span class="p">[</span><span class="n">Check</span>   <span class="o">=&gt;</span><span class="p">]</span> <span class="n">Boolean_EXPRESSION</span>
  <span class="p">[,</span> <span class="p">[</span><span class="n">Message</span> <span class="o">=&gt;</span><span class="p">]</span> <span class="n">string_EXPRESSION</span><span class="p">]</span> <span class="p">);</span>

<span class="n">CHECK_KIND</span> <span class="p">:</span><span class="o">:=</span> <span class="n">IDENTIFIER</span>           <span class="o">|</span>
               <span class="n">Pre</span><span class="s1">&#39;Class            |</span>
               <span class="n">Post</span><span class="s1">&#39;Class           |</span>
               <span class="n">Type_Invariant</span><span class="s1">&#39;Class |</span>
               <span class="n">Invariant</span><span class="s1">&#39;Class</span>
</pre></div>
</div>
<p>This pragma is similar to the predefined pragma <code class="docutils literal notranslate"><span class="pre">Assert</span></code> except that an
extra identifier argument is present. In conjunction with pragma
<code class="docutils literal notranslate"><span class="pre">Check_Policy</span></code>, this can be used to define groups of assertions that can
be independently controlled. The identifier <code class="docutils literal notranslate"><span class="pre">Assertion</span></code> is special, it
refers to the normal set of pragma <code class="docutils literal notranslate"><span class="pre">Assert</span></code> statements.</p>
<p>Checks introduced by this pragma are normally deactivated by default. They can
be activated either by the command line option <em>-gnata</em>, which turns on
all checks, or individually controlled using pragma <code class="docutils literal notranslate"><span class="pre">Check_Policy</span></code>.</p>
<p>The identifiers <code class="docutils literal notranslate"><span class="pre">Assertions</span></code> and <code class="docutils literal notranslate"><span class="pre">Statement_Assertions</span></code> are not
permitted as check kinds, since this would cause confusion with the use
of these identifiers in <code class="docutils literal notranslate"><span class="pre">Assertion_Policy</span></code> and <code class="docutils literal notranslate"><span class="pre">Check_Policy</span></code>
pragmas, where they are used to refer to sets of assertions.</p>
</div>
<div class="section" id="pragma-check-float-overflow">
<h2><span class="section-number">2.22. </span>Pragma Check_Float_Overflow<a class="headerlink" href="#pragma-check-float-overflow" title="Permalink to this headline">¶</a></h2>
<p id="index-6">Syntax:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma</span><span class="p"> </span><span class="n">Check_Float_Overflow</span><span class="p">;</span>
</pre></div>
</div>
<p>In Ada, the predefined floating-point types (<code class="docutils literal notranslate"><span class="pre">Short_Float</span></code>,
<code class="docutils literal notranslate"><span class="pre">Float</span></code>, <code class="docutils literal notranslate"><span class="pre">Long_Float</span></code>, <code class="docutils literal notranslate"><span class="pre">Long_Long_Float</span></code>) are
defined to be <em>unconstrained</em>. This means that even though each
has a well-defined base range, an operation that delivers a result
outside this base range is not required to raise an exception.
This implementation permission accommodates the notion
of infinities in IEEE floating-point, and corresponds to the
efficient execution mode on most machines. GNAT will not raise
overflow exceptions on these machines; instead it will generate
infinities and NaN’s as defined in the IEEE standard.</p>
<p>Generating infinities, although efficient, is not always desirable.
Often the preferable approach is to check for overflow, even at the
(perhaps considerable) expense of run-time performance.
This can be accomplished by defining your own constrained floating-point subtypes – i.e., by supplying explicit
range constraints – and indeed such a subtype
can have the same base range as its base type. For example:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">subtype</span><span class="p"> </span><span class="n">My_Float</span> <span class="kr">is</span><span class="p"> </span><span class="n">Float</span> <span class="kr">range</span><span class="p"> </span><span class="n">Float</span><span class="na">&#39;Range</span><span class="p">;</span>
</pre></div>
</div>
<p>Here <code class="docutils literal notranslate"><span class="pre">My_Float</span></code> has the same range as
<code class="docutils literal notranslate"><span class="pre">Float</span></code> but is constrained, so operations on
<code class="docutils literal notranslate"><span class="pre">My_Float</span></code> values will be checked for overflow
against this range.</p>
<p>This style will achieve the desired goal, but
it is often more convenient to be able to simply use
the standard predefined floating-point types as long
as overflow checking could be guaranteed.
The <code class="docutils literal notranslate"><span class="pre">Check_Float_Overflow</span></code>
configuration pragma achieves this effect. If a unit is compiled
subject to this configuration pragma, then all operations
on predefined floating-point types including operations on
base types of these floating-point types will be treated as
though those types were constrained, and overflow checks
will be generated. The <code class="docutils literal notranslate"><span class="pre">Constraint_Error</span></code>
exception is raised if the result is out of range.</p>
<p>This mode can also be set by use of the compiler
switch <em>-gnateF</em>.</p>
</div>
<div class="section" id="pragma-check-name">
<h2><span class="section-number">2.23. </span>Pragma Check_Name<a class="headerlink" href="#pragma-check-name" title="Permalink to this headline">¶</a></h2>
<span class="target" id="index-7"></span><p id="index-8">Syntax:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma</span><span class="p"> </span><span class="n">Check_Name</span> <span class="o">(</span><span class="n">check_name_IDENTIFIER</span><span class="o">)</span><span class="p">;</span>
</pre></div>
</div>
<p>This is a configuration pragma that defines a new implementation
defined check name (unless IDENTIFIER matches one of the predefined
check names, in which case the pragma has no effect). Check names
are global to a partition, so if two or more configuration pragmas
are present in a partition mentioning the same name, only one new
check name is introduced.</p>
<p>An implementation defined check name introduced with this pragma may
be used in only three contexts: <code class="docutils literal notranslate"><span class="pre">pragma</span> <span class="pre">Suppress</span></code>,
<code class="docutils literal notranslate"><span class="pre">pragma</span> <span class="pre">Unsuppress</span></code>,
and as the prefix of a <code class="docutils literal notranslate"><span class="pre">Check_Name'Enabled</span></code> attribute reference. For
any of these three cases, the check name must be visible. A check
name is visible if it is in the configuration pragmas applying to
the current unit, or if it appears at the start of any unit that
is part of the dependency set of the current unit (e.g., units that
are mentioned in <code class="docutils literal notranslate"><span class="pre">with</span></code> clauses).</p>
<p>Check names introduced by this pragma are subject to control by compiler
switches (in particular -gnatp) in the usual manner.</p>
</div>
<div class="section" id="pragma-check-policy">
<h2><span class="section-number">2.24. </span>Pragma Check_Policy<a class="headerlink" href="#pragma-check-policy" title="Permalink to this headline">¶</a></h2>
<span class="target" id="index-9"></span><span class="target" id="index-10"></span><span class="target" id="index-11"></span><p id="index-12">Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pragma</span> <span class="n">Check_Policy</span>
 <span class="p">([</span><span class="n">Name</span>   <span class="o">=&gt;</span><span class="p">]</span> <span class="n">CHECK_KIND</span><span class="p">,</span>
  <span class="p">[</span><span class="n">Policy</span> <span class="o">=&gt;</span><span class="p">]</span> <span class="n">POLICY_IDENTIFIER</span><span class="p">);</span>

<span class="n">pragma</span> <span class="n">Check_Policy</span> <span class="p">(</span>
    <span class="n">CHECK_KIND</span> <span class="o">=&gt;</span> <span class="n">POLICY_IDENTIFIER</span>
 <span class="p">{,</span> <span class="n">CHECK_KIND</span> <span class="o">=&gt;</span> <span class="n">POLICY_IDENTIFIER</span><span class="p">});</span>

<span class="n">ASSERTION_KIND</span> <span class="p">:</span><span class="o">:=</span> <span class="n">RM_ASSERTION_KIND</span> <span class="o">|</span> <span class="n">ID_ASSERTION_KIND</span>

<span class="n">CHECK_KIND</span> <span class="p">:</span><span class="o">:=</span> <span class="n">IDENTIFIER</span>           <span class="o">|</span>
               <span class="n">Pre</span><span class="s1">&#39;Class            |</span>
               <span class="n">Post</span><span class="s1">&#39;Class           |</span>
               <span class="n">Type_Invariant</span><span class="s1">&#39;Class |</span>
               <span class="n">Invariant</span><span class="s1">&#39;Class</span>

<span class="n">The</span> <span class="n">identifiers</span> <span class="n">Name</span> <span class="ow">and</span> <span class="n">Policy</span> <span class="n">are</span> <span class="ow">not</span> <span class="n">allowed</span> <span class="k">as</span> <span class="n">CHECK_KIND</span> <span class="n">values</span><span class="o">.</span> <span class="n">This</span>
<span class="n">avoids</span> <span class="n">confusion</span> <span class="n">between</span> <span class="n">the</span> <span class="n">two</span> <span class="n">possible</span> <span class="n">syntax</span> <span class="n">forms</span> <span class="k">for</span> <span class="n">this</span> <span class="n">pragma</span><span class="o">.</span>

<span class="n">POLICY_IDENTIFIER</span> <span class="p">:</span><span class="o">:=</span> <span class="n">ON</span> <span class="o">|</span> <span class="n">OFF</span> <span class="o">|</span> <span class="n">CHECK</span> <span class="o">|</span> <span class="n">DISABLE</span> <span class="o">|</span> <span class="n">IGNORE</span>
</pre></div>
</div>
<p>This pragma is used to set the checking policy for assertions (specified
by aspects or pragmas), the <code class="docutils literal notranslate"><span class="pre">Debug</span></code> pragma, or additional checks
to be checked using the <code class="docutils literal notranslate"><span class="pre">Check</span></code> pragma. It may appear either as
a configuration pragma, or within a declarative part of package. In the
latter case, it applies from the point where it appears to the end of
the declarative region (like pragma <code class="docutils literal notranslate"><span class="pre">Suppress</span></code>).</p>
<p>The <code class="docutils literal notranslate"><span class="pre">Check_Policy</span></code> pragma is similar to the
predefined <code class="docutils literal notranslate"><span class="pre">Assertion_Policy</span></code> pragma,
and if the check kind corresponds to one of the assertion kinds that
are allowed by <code class="docutils literal notranslate"><span class="pre">Assertion_Policy</span></code>, then the effect is identical.</p>
<p>If the first argument is Debug, then the policy applies to Debug pragmas,
disabling their effect if the policy is <code class="docutils literal notranslate"><span class="pre">OFF</span></code>, <code class="docutils literal notranslate"><span class="pre">DISABLE</span></code>, or
<code class="docutils literal notranslate"><span class="pre">IGNORE</span></code>, and allowing them to execute with normal semantics if
the policy is <code class="docutils literal notranslate"><span class="pre">ON</span></code> or <code class="docutils literal notranslate"><span class="pre">CHECK</span></code>. In addition if the policy is
<code class="docutils literal notranslate"><span class="pre">DISABLE</span></code>, then the procedure call in <code class="docutils literal notranslate"><span class="pre">Debug</span></code> pragmas will
be totally ignored and not analyzed semantically.</p>
<p>Finally the first argument may be some other identifier than the above
possibilities, in which case it controls a set of named assertions
that can be checked using pragma <code class="docutils literal notranslate"><span class="pre">Check</span></code>. For example, if the pragma:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma</span><span class="p"> </span><span class="n">Check_Policy</span> <span class="o">(</span><span class="n">Critical_Error</span><span class="p">,</span> <span class="n">OFF</span><span class="o">)</span><span class="p">;</span>
</pre></div>
</div>
<p>is given, then subsequent <code class="docutils literal notranslate"><span class="pre">Check</span></code> pragmas whose first argument is also
<code class="docutils literal notranslate"><span class="pre">Critical_Error</span></code> will be disabled.</p>
<p>The check policy is <code class="docutils literal notranslate"><span class="pre">OFF</span></code> to turn off corresponding checks, and <code class="docutils literal notranslate"><span class="pre">ON</span></code>
to turn on corresponding checks. The default for a set of checks for which no
<code class="docutils literal notranslate"><span class="pre">Check_Policy</span></code> is given is <code class="docutils literal notranslate"><span class="pre">OFF</span></code> unless the compiler switch
<em>-gnata</em> is given, which turns on all checks by default.</p>
<p>The check policy settings <code class="docutils literal notranslate"><span class="pre">CHECK</span></code> and <code class="docutils literal notranslate"><span class="pre">IGNORE</span></code> are recognized
as synonyms for <code class="docutils literal notranslate"><span class="pre">ON</span></code> and <code class="docutils literal notranslate"><span class="pre">OFF</span></code>. These synonyms are provided for
compatibility with the standard <code class="docutils literal notranslate"><span class="pre">Assertion_Policy</span></code> pragma. The check
policy setting <code class="docutils literal notranslate"><span class="pre">DISABLE</span></code> causes the second argument of a corresponding
<code class="docutils literal notranslate"><span class="pre">Check</span></code> pragma to be completely ignored and not analyzed.</p>
</div>
<div class="section" id="pragma-comment">
<h2><span class="section-number">2.25. </span>Pragma Comment<a class="headerlink" href="#pragma-comment" title="Permalink to this headline">¶</a></h2>
<p>Syntax:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma</span><span class="p"> </span><span class="n">Comment</span> <span class="o">(</span><span class="n">static_string_EXPRESSION</span><span class="o">)</span><span class="p">;</span>
</pre></div>
</div>
<p>This is almost identical in effect to pragma <code class="docutils literal notranslate"><span class="pre">Ident</span></code>.  It allows the
placement of a comment into the object file and hence into the
executable file if the operating system permits such usage.  The
difference is that <code class="docutils literal notranslate"><span class="pre">Comment</span></code>, unlike <code class="docutils literal notranslate"><span class="pre">Ident</span></code>, has
no limitations on placement of the pragma (it can be placed
anywhere in the main source unit), and if more than one pragma
is used, all comments are retained.</p>
</div>
<div class="section" id="pragma-common-object">
<h2><span class="section-number">2.26. </span>Pragma Common_Object<a class="headerlink" href="#pragma-common-object" title="Permalink to this headline">¶</a></h2>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pragma</span> <span class="n">Common_Object</span> <span class="p">(</span>
     <span class="p">[</span><span class="n">Internal</span> <span class="o">=&gt;</span><span class="p">]</span> <span class="n">LOCAL_NAME</span>
  <span class="p">[,</span> <span class="p">[</span><span class="n">External</span> <span class="o">=&gt;</span><span class="p">]</span> <span class="n">EXTERNAL_SYMBOL</span><span class="p">]</span>
  <span class="p">[,</span> <span class="p">[</span><span class="n">Size</span>     <span class="o">=&gt;</span><span class="p">]</span> <span class="n">EXTERNAL_SYMBOL</span><span class="p">]</span> <span class="p">);</span>

<span class="n">EXTERNAL_SYMBOL</span> <span class="p">:</span><span class="o">:=</span>
  <span class="n">IDENTIFIER</span>
<span class="o">|</span> <span class="n">static_string_EXPRESSION</span>
</pre></div>
</div>
<p>This pragma enables the shared use of variables stored in overlaid
linker areas corresponding to the use of <code class="docutils literal notranslate"><span class="pre">COMMON</span></code>
in Fortran.  The single
object <code class="docutils literal notranslate"><span class="pre">LOCAL_NAME</span></code> is assigned to the area designated by
the <code class="docutils literal notranslate"><span class="pre">External</span></code> argument.
You may define a record to correspond to a series
of fields.  The <code class="docutils literal notranslate"><span class="pre">Size</span></code> argument
is syntax checked in GNAT, but otherwise ignored.</p>
<p><code class="docutils literal notranslate"><span class="pre">Common_Object</span></code> is not supported on all platforms.  If no
support is available, then the code generator will issue a message
indicating that the necessary attribute for implementation of this
pragma is not available.</p>
</div>
<div class="section" id="pragma-compile-time-error">
<span id="compile-time-error"></span><h2><span class="section-number">2.27. </span>Pragma Compile_Time_Error<a class="headerlink" href="#pragma-compile-time-error" title="Permalink to this headline">¶</a></h2>
<p>Syntax:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma</span><span class="p"> </span><span class="n">Compile_Time_Error</span>
         <span class="o">(</span><span class="n">boolean_EXPRESSION</span><span class="p">,</span> <span class="n">static_string_EXPRESSION</span><span class="o">)</span><span class="p">;</span>
</pre></div>
</div>
<p>This pragma can be used to generate additional compile time
error messages. It
is particularly useful in generics, where errors can be issued for
specific problematic instantiations. The first parameter is a boolean
expression. The pragma ensures that the value of an expression
is known at compile time, and has the value False. The set of expressions
whose values are known at compile time includes all static boolean
expressions, and also other values which the compiler can determine
at compile time (e.g., the size of a record type set by an explicit
size representation clause, or the value of a variable which was
initialized to a constant and is known not to have been modified).
If these conditions are not met, an error message is generated using
the value given as the second argument. This string value may contain
embedded ASCII.LF characters to break the message into multiple lines.</p>
</div>
<div class="section" id="pragma-compile-time-warning">
<h2><span class="section-number">2.28. </span>Pragma Compile_Time_Warning<a class="headerlink" href="#pragma-compile-time-warning" title="Permalink to this headline">¶</a></h2>
<p>Syntax:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma</span><span class="p"> </span><span class="n">Compile_Time_Warning</span>
         <span class="o">(</span><span class="n">boolean_EXPRESSION</span><span class="p">,</span> <span class="n">static_string_EXPRESSION</span><span class="o">)</span><span class="p">;</span>
</pre></div>
</div>
<p>Same as pragma Compile_Time_Error, except a warning is issued instead
of an error message. If switch <em>-gnatw_C</em> is used, a warning is only issued
if the value of the expression is known to be True at compile time, not when
the value of the expression is not known at compile time.
Note that if this pragma is used in a package that
is with’ed by a client, the client will get the warning even though it
is issued by a with’ed package (normally warnings in with’ed units are
suppressed, but this is a special exception to that rule).</p>
<p>One typical use is within a generic where compile time known characteristics
of formal parameters are tested, and warnings given appropriately. Another use
with a first parameter of True is to warn a client about use of a package,
for example that it is not fully implemented.</p>
<p>In previous versions of the compiler, combining <em>-gnatwe</em> with
Compile_Time_Warning resulted in a fatal error. Now the compiler always emits
a warning. You can use <a class="reference internal" href="#compile-time-error"><span class="std std-ref">Pragma Compile_Time_Error</span></a> to force the generation of
an error.</p>
</div>
<div class="section" id="pragma-compiler-unit">
<h2><span class="section-number">2.29. </span>Pragma Compiler_Unit<a class="headerlink" href="#pragma-compiler-unit" title="Permalink to this headline">¶</a></h2>
<p>Syntax:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma</span><span class="p"> </span><span class="n">Compiler_Unit</span><span class="p">;</span>
</pre></div>
</div>
<p>This pragma is obsolete. It is equivalent to Compiler_Unit_Warning. It is
retained so that old versions of the GNAT run-time that use this pragma can
be compiled with newer versions of the compiler.</p>
</div>
<div class="section" id="pragma-compiler-unit-warning">
<h2><span class="section-number">2.30. </span>Pragma Compiler_Unit_Warning<a class="headerlink" href="#pragma-compiler-unit-warning" title="Permalink to this headline">¶</a></h2>
<p>Syntax:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma</span><span class="p"> </span><span class="n">Compiler_Unit_Warning</span><span class="p">;</span>
</pre></div>
</div>
<p>This pragma is intended only for internal use in the GNAT run-time library.
It indicates that the unit is used as part of the compiler build. The effect
is to generate warnings for the use of constructs (for example, conditional
expressions) that would cause trouble when bootstrapping using an older
version of GNAT. For the exact list of restrictions, see the compiler sources
and references to Check_Compiler_Unit.</p>
</div>
<div class="section" id="pragma-complete-representation">
<h2><span class="section-number">2.31. </span>Pragma Complete_Representation<a class="headerlink" href="#pragma-complete-representation" title="Permalink to this headline">¶</a></h2>
<p>Syntax:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma</span><span class="p"> </span><span class="n">Complete_Representation</span><span class="p">;</span>
</pre></div>
</div>
<p>This pragma must appear immediately within a record representation
clause. Typical placements are before the first component clause
or after the last component clause. The effect is to give an error
message if any component is missing a component clause. This pragma
may be used to ensure that a record representation clause is
complete, and that this invariant is maintained if fields are
added to the record in the future.</p>
</div>
<div class="section" id="pragma-complex-representation">
<h2><span class="section-number">2.32. </span>Pragma Complex_Representation<a class="headerlink" href="#pragma-complex-representation" title="Permalink to this headline">¶</a></h2>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pragma</span> <span class="n">Complex_Representation</span>
        <span class="p">([</span><span class="n">Entity</span> <span class="o">=&gt;</span><span class="p">]</span> <span class="n">LOCAL_NAME</span><span class="p">);</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">Entity</span></code> argument must be the name of a record type which has
two fields of the same floating-point type.  The effect of this pragma is
to force gcc to use the special internal complex representation form for
this record, which may be more efficient.  Note that this may result in
the code for this type not conforming to standard ABI (application
binary interface) requirements for the handling of record types.  For
example, in some environments, there is a requirement for passing
records by pointer, and the use of this pragma may result in passing
this type in floating-point registers.</p>
</div>
<div class="section" id="pragma-component-alignment">
<h2><span class="section-number">2.33. </span>Pragma Component_Alignment<a class="headerlink" href="#pragma-component-alignment" title="Permalink to this headline">¶</a></h2>
<span class="target" id="index-13"></span><p id="index-14">Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pragma</span> <span class="n">Component_Alignment</span> <span class="p">(</span>
     <span class="p">[</span><span class="n">Form</span> <span class="o">=&gt;</span><span class="p">]</span> <span class="n">ALIGNMENT_CHOICE</span>
  <span class="p">[,</span> <span class="p">[</span><span class="n">Name</span> <span class="o">=&gt;</span><span class="p">]</span> <span class="n">type_LOCAL_NAME</span><span class="p">]);</span>

<span class="n">ALIGNMENT_CHOICE</span> <span class="p">:</span><span class="o">:=</span>
  <span class="n">Component_Size</span>
<span class="o">|</span> <span class="n">Component_Size_4</span>
<span class="o">|</span> <span class="n">Storage_Unit</span>
<span class="o">|</span> <span class="n">Default</span>
</pre></div>
</div>
<p>Specifies the alignment of components in array or record types.
The meaning of the <code class="docutils literal notranslate"><span class="pre">Form</span></code> argument is as follows:</p>
<blockquote>
<div></div></blockquote>
<dl id="index-15">
<dt><em>Component_Size</em></dt><dd><p>Aligns scalar components and subcomponents of the array or record type
on boundaries appropriate to their inherent size (naturally
aligned).  For example, 1-byte components are aligned on byte boundaries,
2-byte integer components are aligned on 2-byte boundaries, 4-byte
integer components are aligned on 4-byte boundaries and so on.  These
alignment rules correspond to the normal rules for C compilers on all
machines except the VAX.</p>
</dd>
<dt id="index-16"><em>Component_Size_4</em></dt><dd><p>Naturally aligns components with a size of four or fewer
bytes.  Components that are larger than 4 bytes are placed on the next
4-byte boundary.</p>
</dd>
<dt id="index-17"><em>Storage_Unit</em></dt><dd><p>Specifies that array or record components are byte aligned, i.e.,
aligned on boundaries determined by the value of the constant
<code class="docutils literal notranslate"><span class="pre">System.Storage_Unit</span></code>.</p>
</dd>
<dt id="index-18"><em>Default</em></dt><dd><p>Specifies that array or record components are aligned on default
boundaries, appropriate to the underlying hardware or operating system or
both. The <code class="docutils literal notranslate"><span class="pre">Default</span></code> choice is the same as <code class="docutils literal notranslate"><span class="pre">Component_Size</span></code> (natural
alignment).</p>
</dd>
</dl>
<p>If the <code class="docutils literal notranslate"><span class="pre">Name</span></code> parameter is present, <code class="docutils literal notranslate"><span class="pre">type_LOCAL_NAME</span></code> must
refer to a local record or array type, and the specified alignment
choice applies to the specified type.  The use of
<code class="docutils literal notranslate"><span class="pre">Component_Alignment</span></code> together with a pragma <code class="docutils literal notranslate"><span class="pre">Pack</span></code> causes the
<code class="docutils literal notranslate"><span class="pre">Component_Alignment</span></code> pragma to be ignored.  The use of
<code class="docutils literal notranslate"><span class="pre">Component_Alignment</span></code> together with a record representation clause
is only effective for fields not specified by the representation clause.</p>
<p>If the <code class="docutils literal notranslate"><span class="pre">Name</span></code> parameter is absent, the pragma can be used as either
a configuration pragma, in which case it applies to one or more units in
accordance with the normal rules for configuration pragmas, or it can be
used within a declarative part, in which case it applies to types that
are declared within this declarative part, or within any nested scope
within this declarative part.  In either case it specifies the alignment
to be applied to any record or array type which has otherwise standard
representation.</p>
<p>If the alignment for a record or array type is not specified (using
pragma <code class="docutils literal notranslate"><span class="pre">Pack</span></code>, pragma <code class="docutils literal notranslate"><span class="pre">Component_Alignment</span></code>, or a record rep
clause), the GNAT uses the default alignment as described previously.</p>
</div>
<div class="section" id="pragma-constant-after-elaboration">
<span id="id6"></span><h2><span class="section-number">2.34. </span>Pragma Constant_After_Elaboration<a class="headerlink" href="#pragma-constant-after-elaboration" title="Permalink to this headline">¶</a></h2>
<p>Syntax:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma</span><span class="p"> </span><span class="n">Constant_After_Elaboration</span> [ <span class="o">(</span><span class="n">boolean_EXPRESSION</span><span class="o">)</span> ]<span class="p">;</span>
</pre></div>
</div>
<p>For the semantics of this pragma, see the entry for aspect
<code class="docutils literal notranslate"><span class="pre">Constant_After_Elaboration</span></code> in the SPARK 2014 Reference Manual, section 3.3.1.</p>
</div>
<div class="section" id="pragma-contract-cases">
<span id="id7"></span><h2><span class="section-number">2.35. </span>Pragma Contract_Cases<a class="headerlink" href="#pragma-contract-cases" title="Permalink to this headline">¶</a></h2>
<p id="index-19">Syntax:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma</span><span class="p"> </span><span class="n">Contract_Cases</span> <span class="o">((</span><span class="n">CONTRACT_CASE</span> {<span class="p">,</span> <span class="n">CONTRACT_CASE</span><span class="o">))</span><span class="p">;</span>

<span class="n">CONTRACT_CASE</span> <span class="o">::=</span> <span class="n">CASE_GUARD</span> <span class="o">=&gt;</span> <span class="n">CONSEQUENCE</span>

<span class="n">CASE_GUARD</span> <span class="o">::=</span> <span class="n">boolean_EXPRESSION</span> <span class="o">|</span> <span class="kr">others</span><span class="p"></span>

<span class="n">CONSEQUENCE</span> <span class="o">::=</span> <span class="n">boolean_EXPRESSION</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">Contract_Cases</span></code> pragma allows defining fine-grain specifications
that can complement or replace the contract given by a precondition and a
postcondition. Additionally, the <code class="docutils literal notranslate"><span class="pre">Contract_Cases</span></code> pragma can be used
by testing and formal verification tools. The compiler checks its validity and,
depending on the assertion policy at the point of declaration of the pragma,
it may insert a check in the executable. For code generation, the contract
cases</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma</span><span class="p"> </span><span class="n">Contract_Cases</span> <span class="o">(</span>
  <span class="n">Cond1</span> <span class="o">=&gt;</span> <span class="n">Pred1</span><span class="p">,</span>
  <span class="n">Cond2</span> <span class="o">=&gt;</span> <span class="n">Pred2</span><span class="o">)</span><span class="p">;</span>
</pre></div>
</div>
<p>are equivalent to</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="n">C1</span> <span class="o">:</span> <span class="kr">constant</span><span class="p"> </span><span class="n">Boolean</span> <span class="o">:=</span> <span class="n">Cond1</span><span class="p">;</span>  <span class="c">--  evaluated at subprogram entry</span>
<span class="n">C2</span> <span class="o">:</span> <span class="kr">constant</span><span class="p"> </span><span class="n">Boolean</span> <span class="o">:=</span> <span class="n">Cond2</span><span class="p">;</span>  <span class="c">--  evaluated at subprogram entry</span>
<span class="kr">pragma</span><span class="p"> </span><span class="n">Precondition</span> <span class="o">((</span><span class="n">C1</span> <span class="kr">and</span><span class="p"> </span><span class="kr">not</span><span class="p"> </span><span class="n">C2</span><span class="o">)</span> <span class="kr">or</span><span class="p"> </span><span class="o">(</span><span class="n">C2</span> <span class="kr">and</span><span class="p"> </span><span class="kr">not</span><span class="p"> </span><span class="n">C1</span><span class="o">))</span><span class="p">;</span>
<span class="kr">pragma</span><span class="p"> </span><span class="n">Postcondition</span> <span class="o">(</span><span class="kr">if</span><span class="p"> </span><span class="n">C1</span> <span class="kr">then</span><span class="p"> </span><span class="n">Pred1</span><span class="o">)</span><span class="p">;</span>
<span class="kr">pragma</span><span class="p"> </span><span class="n">Postcondition</span> <span class="o">(</span><span class="kr">if</span><span class="p"> </span><span class="n">C2</span> <span class="kr">then</span><span class="p"> </span><span class="n">Pred2</span><span class="o">)</span><span class="p">;</span>
</pre></div>
</div>
<p>The precondition ensures that one and only one of the case guards is
satisfied on entry to the subprogram.
The postcondition ensures that for the case guard that was True on entry,
the corresponding consequence is True on exit. Other consequence expressions
are not evaluated.</p>
<p>A precondition <code class="docutils literal notranslate"><span class="pre">P</span></code> and postcondition <code class="docutils literal notranslate"><span class="pre">Q</span></code> can also be
expressed as contract cases:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma</span><span class="p"> </span><span class="n">Contract_Cases</span> <span class="o">(</span><span class="n">P</span> <span class="o">=&gt;</span> <span class="n">Q</span><span class="o">)</span><span class="p">;</span>
</pre></div>
</div>
<p>The placement and visibility rules for <code class="docutils literal notranslate"><span class="pre">Contract_Cases</span></code> pragmas are
identical to those described for preconditions and postconditions.</p>
<p>The compiler checks that boolean expressions given in case guards and
consequences are valid, where the rules for case guards are the same as
the rule for an expression in <code class="docutils literal notranslate"><span class="pre">Precondition</span></code> and the rules for
consequences are the same as the rule for an expression in
<code class="docutils literal notranslate"><span class="pre">Postcondition</span></code>. In particular, attributes <code class="docutils literal notranslate"><span class="pre">'Old</span></code> and
<code class="docutils literal notranslate"><span class="pre">'Result</span></code> can only be used within consequence expressions.
The case guard for the last contract case may be <code class="docutils literal notranslate"><span class="pre">others</span></code>, to denote
any case not captured by the previous cases. The
following is an example of use within a package spec:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="k">package </span><span class="nf">Math_Functions</span> <span class="kr">is</span><span class="p"></span>
   <span class="o">...</span>
   <span class="k">function </span><span class="nf">Sqrt</span> <span class="o">(</span><span class="n">Arg</span> <span class="o">:</span> <span class="n">Float</span><span class="o">)</span> <span class="kr">return</span><span class="p"> </span><span class="n">Float</span><span class="p">;</span>
   <span class="kr">pragma</span><span class="p"> </span><span class="n">Contract_Cases</span> <span class="o">(((</span><span class="n">Arg</span> <span class="kr">in</span><span class="p"> </span><span class="mi">0</span><span class="o">.</span><span class="mi">0</span> <span class="o">..</span> <span class="mi">99</span><span class="o">.</span><span class="mi">0</span><span class="o">)</span> <span class="o">=&gt;</span> <span class="n">Sqrt</span><span class="na">&#39;Result</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="o">.</span><span class="mi">0</span><span class="p">,</span>
                           <span class="n">Arg</span> <span class="o">&gt;=</span> <span class="mi">100</span><span class="o">.</span><span class="mi">0</span>         <span class="o">=&gt;</span> <span class="n">Sqrt</span><span class="na">&#39;Result</span> <span class="o">&gt;=</span> <span class="mi">10</span><span class="o">.</span><span class="mi">0</span><span class="p">,</span>
                           <span class="kr">others</span><span class="p"> </span>              <span class="o">=&gt;</span> <span class="n">Sqrt</span><span class="na">&#39;Result</span> <span class="o">=</span> <span class="mi">0</span><span class="o">.</span><span class="mi">0</span><span class="o">))</span><span class="p">;</span>
   <span class="o">...</span>
<span class="k">end </span><span class="nf">Math_Functions</span><span class="p">;</span>
</pre></div>
</div>
<p>The meaning of contract cases is that only one case should apply at each
call, as determined by the corresponding case guard evaluating to True,
and that the consequence for this case should hold when the subprogram
returns.</p>
</div>
<div class="section" id="pragma-convention-identifier">
<h2><span class="section-number">2.36. </span>Pragma Convention_Identifier<a class="headerlink" href="#pragma-convention-identifier" title="Permalink to this headline">¶</a></h2>
<p id="index-20">Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pragma</span> <span class="n">Convention_Identifier</span> <span class="p">(</span>
         <span class="p">[</span><span class="n">Name</span> <span class="o">=&gt;</span><span class="p">]</span>       <span class="n">IDENTIFIER</span><span class="p">,</span>
         <span class="p">[</span><span class="n">Convention</span> <span class="o">=&gt;</span><span class="p">]</span> <span class="n">convention_IDENTIFIER</span><span class="p">);</span>
</pre></div>
</div>
<p>This pragma provides a mechanism for supplying synonyms for existing
convention identifiers. The <code class="docutils literal notranslate"><span class="pre">Name</span></code> identifier can subsequently
be used as a synonym for the given convention in other pragmas (including
for example pragma <code class="docutils literal notranslate"><span class="pre">Import</span></code> or another <code class="docutils literal notranslate"><span class="pre">Convention_Identifier</span></code>
pragma). As an example of the use of this, suppose you had legacy code
which used Fortran77 as the identifier for Fortran. Then the pragma:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma</span><span class="p"> </span><span class="n">Convention_Identifier</span> <span class="o">(</span><span class="n">Fortran77</span><span class="p">,</span> <span class="n">Fortran</span><span class="o">)</span><span class="p">;</span>
</pre></div>
</div>
<p>would allow the use of the convention identifier <code class="docutils literal notranslate"><span class="pre">Fortran77</span></code> in
subsequent code, avoiding the need to modify the sources. As another
example, you could use this to parameterize convention requirements
according to systems. Suppose you needed to use <code class="docutils literal notranslate"><span class="pre">Stdcall</span></code> on
windows systems, and <code class="docutils literal notranslate"><span class="pre">C</span></code> on some other system, then you could
define a convention identifier <code class="docutils literal notranslate"><span class="pre">Library</span></code> and use a single
<code class="docutils literal notranslate"><span class="pre">Convention_Identifier</span></code> pragma to specify which convention
would be used system-wide.</p>
</div>
<div class="section" id="pragma-cpp-class">
<h2><span class="section-number">2.37. </span>Pragma CPP_Class<a class="headerlink" href="#pragma-cpp-class" title="Permalink to this headline">¶</a></h2>
<p id="index-21">Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pragma</span> <span class="n">CPP_Class</span> <span class="p">([</span><span class="n">Entity</span> <span class="o">=&gt;</span><span class="p">]</span> <span class="n">LOCAL_NAME</span><span class="p">);</span>
</pre></div>
</div>
<p>The argument denotes an entity in the current declarative region that is
declared as a record type. It indicates that the type corresponds to an
externally declared C++ class type, and is to be laid out the same way
that C++ would lay out the type. If the C++ class has virtual primitives
then the record must be declared as a tagged record type.</p>
<p>Types for which <code class="docutils literal notranslate"><span class="pre">CPP_Class</span></code> is specified do not have assignment or
equality operators defined (such operations can be imported or declared
as subprograms as required). Initialization is allowed only by constructor
functions (see pragma <code class="docutils literal notranslate"><span class="pre">CPP_Constructor</span></code>). Such types are implicitly
limited if not explicitly declared as limited or derived from a limited
type, and an error is issued in that case.</p>
<p>See <a class="reference internal" href="interfacing_to_other_languages.html#id3"><span class="std std-ref">Interfacing to C++</span></a> for related information.</p>
<p>Note: Pragma <code class="docutils literal notranslate"><span class="pre">CPP_Class</span></code> is currently obsolete. It is supported
for backward compatibility but its functionality is available
using pragma <code class="docutils literal notranslate"><span class="pre">Import</span></code> with <code class="docutils literal notranslate"><span class="pre">Convention</span></code> = <code class="docutils literal notranslate"><span class="pre">CPP</span></code>.</p>
</div>
<div class="section" id="pragma-cpp-constructor">
<h2><span class="section-number">2.38. </span>Pragma CPP_Constructor<a class="headerlink" href="#pragma-cpp-constructor" title="Permalink to this headline">¶</a></h2>
<p id="index-22">Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pragma</span> <span class="n">CPP_Constructor</span> <span class="p">([</span><span class="n">Entity</span> <span class="o">=&gt;</span><span class="p">]</span> <span class="n">LOCAL_NAME</span>
  <span class="p">[,</span> <span class="p">[</span><span class="n">External_Name</span> <span class="o">=&gt;</span><span class="p">]</span> <span class="n">static_string_EXPRESSION</span> <span class="p">]</span>
  <span class="p">[,</span> <span class="p">[</span><span class="n">Link_Name</span>     <span class="o">=&gt;</span><span class="p">]</span> <span class="n">static_string_EXPRESSION</span> <span class="p">]);</span>
</pre></div>
</div>
<p>This pragma identifies an imported function (imported in the usual way
with pragma <code class="docutils literal notranslate"><span class="pre">Import</span></code>) as corresponding to a C++ constructor. If
<code class="docutils literal notranslate"><span class="pre">External_Name</span></code> and <code class="docutils literal notranslate"><span class="pre">Link_Name</span></code> are not specified then the
<code class="docutils literal notranslate"><span class="pre">Entity</span></code> argument is a name that must have been previously mentioned
in a pragma <code class="docutils literal notranslate"><span class="pre">Import</span></code> with <code class="docutils literal notranslate"><span class="pre">Convention</span></code> = <code class="docutils literal notranslate"><span class="pre">CPP</span></code>. Such name
must be of one of the following forms:</p>
<ul class="simple">
<li><p><strong>function</strong> <code class="docutils literal notranslate"><span class="pre">Fname</span></code> <strong>return</strong> T`</p></li>
<li><p><strong>function</strong> <code class="docutils literal notranslate"><span class="pre">Fname</span></code> <strong>return</strong> T’Class</p></li>
<li><p><strong>function</strong> <code class="docutils literal notranslate"><span class="pre">Fname</span></code> (…) <strong>return</strong> T`</p></li>
<li><p><strong>function</strong> <code class="docutils literal notranslate"><span class="pre">Fname</span></code> (…) <strong>return</strong> T’Class</p></li>
</ul>
<p>where <code class="docutils literal notranslate"><span class="pre">T</span></code> is a limited record type imported from C++ with pragma
<code class="docutils literal notranslate"><span class="pre">Import</span></code> and <code class="docutils literal notranslate"><span class="pre">Convention</span></code> = <code class="docutils literal notranslate"><span class="pre">CPP</span></code>.</p>
<p>The first two forms import the default constructor, used when an object
of type <code class="docutils literal notranslate"><span class="pre">T</span></code> is created on the Ada side with no explicit constructor.
The latter two forms cover all the non-default constructors of the type.
See the GNAT User’s Guide for details.</p>
<p>If no constructors are imported, it is impossible to create any objects
on the Ada side and the type is implicitly declared abstract.</p>
<p>Pragma <code class="docutils literal notranslate"><span class="pre">CPP_Constructor</span></code> is intended primarily for automatic generation
using an automatic binding generator tool (such as the <code class="switch docutils literal notranslate"><span class="pre">-fdump-ada-spec</span></code>
GCC switch).
See <a class="reference internal" href="interfacing_to_other_languages.html#id3"><span class="std std-ref">Interfacing to C++</span></a> for more related information.</p>
<p>Note: The use of functions returning class-wide types for constructors is
currently obsolete. They are supported for backward compatibility. The
use of functions returning the type T leave the Ada sources more clear
because the imported C++ constructors always return an object of type T;
that is, they never return an object whose type is a descendant of type T.</p>
</div>
<div class="section" id="pragma-cpp-virtual">
<h2><span class="section-number">2.39. </span>Pragma CPP_Virtual<a class="headerlink" href="#pragma-cpp-virtual" title="Permalink to this headline">¶</a></h2>
<p id="index-23">This pragma is now obsolete and, other than generating a warning if warnings
on obsolescent features are enabled, is completely ignored.
It is retained for compatibility
purposes. It used to be required to ensure compoatibility with C++, but
is no longer required for that purpose because GNAT generates
the same object layout as the G++ compiler by default.</p>
<p>See <a class="reference internal" href="interfacing_to_other_languages.html#id3"><span class="std std-ref">Interfacing to C++</span></a> for related information.</p>
</div>
<div class="section" id="pragma-cpp-vtable">
<h2><span class="section-number">2.40. </span>Pragma CPP_Vtable<a class="headerlink" href="#pragma-cpp-vtable" title="Permalink to this headline">¶</a></h2>
<p id="index-24">This pragma is now obsolete and, other than generating a warning if warnings
on obsolescent features are enabled, is completely ignored.
It used to be required to ensure compatibility with C++, but
is no longer required for that purpose because GNAT generates
the same object layout as the G++ compiler by default.</p>
<p>See <a class="reference internal" href="interfacing_to_other_languages.html#id3"><span class="std std-ref">Interfacing to C++</span></a> for related information.</p>
</div>
<div class="section" id="pragma-cpu">
<h2><span class="section-number">2.41. </span>Pragma CPU<a class="headerlink" href="#pragma-cpu" title="Permalink to this headline">¶</a></h2>
<p>Syntax:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma</span><span class="p"> </span><span class="n">CPU</span> <span class="o">(</span><span class="n">EXPRESSION</span><span class="o">)</span><span class="p">;</span>
</pre></div>
</div>
<p>This pragma is standard in Ada 2012, but is available in all earlier
versions of Ada as an implementation-defined pragma.
See Ada 2012 Reference Manual for details.</p>
</div>
<div class="section" id="pragma-deadline-floor">
<h2><span class="section-number">2.42. </span>Pragma Deadline_Floor<a class="headerlink" href="#pragma-deadline-floor" title="Permalink to this headline">¶</a></h2>
<p>Syntax:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma</span><span class="p"> </span><span class="n">Deadline_Floor</span> <span class="o">(</span><span class="n">time_span_EXPRESSION</span><span class="o">)</span><span class="p">;</span>
</pre></div>
</div>
<p>This pragma applies only to protected types and specifies the floor
deadline inherited by a task when the task enters a protected object.
It is effective only when the EDF scheduling policy is used.</p>
</div>
<div class="section" id="pragma-default-initial-condition">
<span id="id8"></span><h2><span class="section-number">2.43. </span>Pragma Default_Initial_Condition<a class="headerlink" href="#pragma-default-initial-condition" title="Permalink to this headline">¶</a></h2>
<p>Syntax:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma</span><span class="p"> </span><span class="n">Default_Initial_Condition</span> [ <span class="o">(</span><span class="kr">null</span><span class="p"> </span><span class="o">|</span> <span class="n">boolean_EXPRESSION</span><span class="o">)</span> ]<span class="p">;</span>
</pre></div>
</div>
<p>For the semantics of this pragma, see the entry for aspect
<code class="docutils literal notranslate"><span class="pre">Default_Initial_Condition</span></code> in the SPARK 2014 Reference Manual, section 7.3.3.</p>
</div>
<div class="section" id="pragma-debug">
<h2><span class="section-number">2.44. </span>Pragma Debug<a class="headerlink" href="#pragma-debug" title="Permalink to this headline">¶</a></h2>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pragma</span> <span class="n">Debug</span> <span class="p">([</span><span class="n">CONDITION</span><span class="p">,</span> <span class="p">]</span><span class="n">PROCEDURE_CALL_WITHOUT_SEMICOLON</span><span class="p">);</span>

<span class="n">PROCEDURE_CALL_WITHOUT_SEMICOLON</span> <span class="p">:</span><span class="o">:=</span>
  <span class="n">PROCEDURE_NAME</span>
<span class="o">|</span> <span class="n">PROCEDURE_PREFIX</span> <span class="n">ACTUAL_PARAMETER_PART</span>
</pre></div>
</div>
<p>The procedure call argument has the syntactic form of an expression, meeting
the syntactic requirements for pragmas.</p>
<p>If debug pragmas are not enabled or if the condition is present and evaluates
to False, this pragma has no effect. If debug pragmas are enabled, the
semantics of the pragma is exactly equivalent to the procedure call statement
corresponding to the argument with a terminating semicolon. Pragmas are
permitted in sequences of declarations, so you can use pragma <code class="docutils literal notranslate"><span class="pre">Debug</span></code> to
intersperse calls to debug procedures in the middle of declarations. Debug
pragmas can be enabled either by use of the command line switch <em>-gnata</em>
or by use of the pragma <code class="docutils literal notranslate"><span class="pre">Check_Policy</span></code> with a first argument of
<code class="docutils literal notranslate"><span class="pre">Debug</span></code>.</p>
</div>
<div class="section" id="pragma-debug-policy">
<h2><span class="section-number">2.45. </span>Pragma Debug_Policy<a class="headerlink" href="#pragma-debug-policy" title="Permalink to this headline">¶</a></h2>
<p>Syntax:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma</span><span class="p"> </span><span class="n">Debug_Policy</span> <span class="o">(</span><span class="n">CHECK</span> <span class="o">|</span> <span class="n">DISABLE</span> <span class="o">|</span> <span class="n">IGNORE</span> <span class="o">|</span> <span class="n">ON</span> <span class="o">|</span> <span class="n">OFF</span><span class="o">)</span><span class="p">;</span>
</pre></div>
</div>
<p>This pragma is equivalent to a corresponding <code class="docutils literal notranslate"><span class="pre">Check_Policy</span></code> pragma
with a first argument of <code class="docutils literal notranslate"><span class="pre">Debug</span></code>. It is retained for historical
compatibility reasons.</p>
</div>
<div class="section" id="pragma-default-scalar-storage-order">
<h2><span class="section-number">2.46. </span>Pragma Default_Scalar_Storage_Order<a class="headerlink" href="#pragma-default-scalar-storage-order" title="Permalink to this headline">¶</a></h2>
<span class="target" id="index-25"></span><p id="index-26">Syntax:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma</span><span class="p"> </span><span class="n">Default_Scalar_Storage_Order</span> <span class="o">(</span><span class="n">High_Order_First</span> <span class="o">|</span> <span class="n">Low_Order_First</span><span class="o">)</span><span class="p">;</span>
</pre></div>
</div>
<p>Normally if no explicit <code class="docutils literal notranslate"><span class="pre">Scalar_Storage_Order</span></code> is given for a record
type or array type, then the scalar storage order defaults to the ordinary
default for the target. But this default may be overridden using this pragma.
The pragma may appear as a configuration pragma, or locally within a package
spec or declarative part. In the latter case, it applies to all subsequent
types declared within that package spec or declarative part.</p>
<p>The following example shows the use of this pragma:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma</span><span class="p"> </span><span class="n">Default_Scalar_Storage_Order</span> <span class="o">(</span><span class="n">High_Order_First</span><span class="o">)</span><span class="p">;</span>
<span class="kr">with</span><span class="nn"> System;</span> <span class="kr">use</span><span class="p"> </span><span class="n">System</span><span class="p">;</span>
<span class="k">package </span><span class="nf">DSSO1</span> <span class="kr">is</span><span class="p"></span>
   <span class="kr">type</span><span class="p"> </span><span class="n">H1</span> <span class="kr">is</span><span class="p"> </span><span class="kr">record</span><span class="p"></span>
      <span class="n">a</span> <span class="o">:</span> <span class="n">Integer</span><span class="p">;</span>
   <span class="k">end record</span><span class="p">;</span>

   <span class="kr">type</span><span class="p"> </span><span class="n">L2</span> <span class="kr">is</span><span class="p"> </span><span class="kr">record</span><span class="p"></span>
      <span class="n">a</span> <span class="o">:</span> <span class="n">Integer</span><span class="p">;</span>
   <span class="k">end record</span><span class="p">;</span>
   <span class="kr">for</span><span class="p"> </span><span class="n">L2</span><span class="na">&#39;Scalar_Storage_Order</span> <span class="kr">use</span><span class="p"> </span><span class="n">Low_Order_First</span><span class="p">;</span>

   <span class="kr">type</span><span class="p"> </span><span class="n">L2a</span> <span class="kr">is</span><span class="p"> </span><span class="kr">new</span><span class="p"> </span><span class="n">L2</span><span class="p">;</span>

   <span class="k">package </span><span class="nf">Inner</span> <span class="kr">is</span><span class="p"></span>
      <span class="kr">type</span><span class="p"> </span><span class="n">H3</span> <span class="kr">is</span><span class="p"> </span><span class="kr">record</span><span class="p"></span>
         <span class="n">a</span> <span class="o">:</span> <span class="n">Integer</span><span class="p">;</span>
      <span class="k">end record</span><span class="p">;</span>

      <span class="kr">pragma</span><span class="p"> </span><span class="n">Default_Scalar_Storage_Order</span> <span class="o">(</span><span class="n">Low_Order_First</span><span class="o">)</span><span class="p">;</span>

      <span class="kr">type</span><span class="p"> </span><span class="n">L4</span> <span class="kr">is</span><span class="p"> </span><span class="kr">record</span><span class="p"></span>
         <span class="n">a</span> <span class="o">:</span> <span class="n">Integer</span><span class="p">;</span>
      <span class="k">end record</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">Inner</span><span class="p">;</span>

   <span class="kr">type</span><span class="p"> </span><span class="n">H4a</span> <span class="kr">is</span><span class="p"> </span><span class="kr">new</span><span class="p"> </span><span class="n">Inner.L4</span><span class="p">;</span>

   <span class="kr">type</span><span class="p"> </span><span class="n">H5</span> <span class="kr">is</span><span class="p"> </span><span class="kr">record</span><span class="p"></span>
      <span class="n">a</span> <span class="o">:</span> <span class="n">Integer</span><span class="p">;</span>
   <span class="k">end record</span><span class="p">;</span>
<span class="k">end </span><span class="nf">DSSO1</span><span class="p">;</span>
</pre></div>
</div>
<p>In this example record types with names starting with <em>L</em> have <cite>Low_Order_First</cite> scalar
storage order, and record types with names starting with <em>H</em> have <code class="docutils literal notranslate"><span class="pre">High_Order_First</span></code>.
Note that in the case of <code class="docutils literal notranslate"><span class="pre">H4a</span></code>, the order is not inherited
from the parent type. Only an explicitly set <code class="docutils literal notranslate"><span class="pre">Scalar_Storage_Order</span></code>
gets inherited on type derivation.</p>
<p>If this pragma is used as a configuration pragma which appears within a
configuration pragma file (as opposed to appearing explicitly at the start
of a single unit), then the binder will require that all units in a partition
be compiled in a similar manner, other than run-time units, which are not
affected by this pragma. Note that the use of this form is discouraged because
it may significantly degrade the run-time performance of the software, instead
the default scalar storage order ought to be changed only on a local basis.</p>
</div>
<div class="section" id="pragma-default-storage-pool">
<h2><span class="section-number">2.47. </span>Pragma Default_Storage_Pool<a class="headerlink" href="#pragma-default-storage-pool" title="Permalink to this headline">¶</a></h2>
<p id="index-27">Syntax:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma</span><span class="p"> </span><span class="n">Default_Storage_Pool</span> <span class="o">(</span><span class="n">storage_pool_NAME</span> <span class="o">|</span> <span class="n">null</span><span class="o">)</span><span class="p">;</span>
</pre></div>
</div>
<p>This pragma is standard in Ada 2012, but is available in all earlier
versions of Ada as an implementation-defined pragma.
See Ada 2012 Reference Manual for details.</p>
</div>
<div class="section" id="pragma-depends">
<span id="id9"></span><h2><span class="section-number">2.48. </span>Pragma Depends<a class="headerlink" href="#pragma-depends" title="Permalink to this headline">¶</a></h2>
<p>Syntax:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma</span><span class="p"> </span><span class="n">Depends</span> <span class="o">(</span><span class="n">DEPENDENCY_RELATION</span><span class="o">)</span><span class="p">;</span>

<span class="n">DEPENDENCY_RELATION</span> <span class="o">::=</span>
     <span class="kr">null</span><span class="p"></span>
  <span class="o">|</span> <span class="o">(</span><span class="n">DEPENDENCY_CLAUSE</span> {<span class="p">,</span> <span class="n">DEPENDENCY_CLAUSE</span>}<span class="o">)</span>

<span class="n">DEPENDENCY_CLAUSE</span> <span class="o">::=</span>
    <span class="n">OUTPUT_LIST</span> <span class="o">=&gt;</span>[<span class="o">+</span>] <span class="n">INPUT_LIST</span>
  <span class="o">|</span> <span class="n">NULL_DEPENDENCY_CLAUSE</span>

<span class="n">NULL_DEPENDENCY_CLAUSE</span> <span class="o">::=</span> <span class="kr">null</span><span class="p"> </span><span class="o">=&gt;</span> <span class="n">INPUT_LIST</span>

<span class="n">OUTPUT_LIST</span> <span class="o">::=</span> <span class="n">OUTPUT</span> <span class="o">|</span> <span class="o">(</span><span class="n">OUTPUT</span> {<span class="p">,</span> <span class="n">OUTPUT</span>}<span class="o">)</span>

<span class="n">INPUT_LIST</span> <span class="o">::=</span> <span class="kr">null</span><span class="p"> </span><span class="o">|</span> <span class="n">INPUT</span> <span class="o">|</span> <span class="o">(</span><span class="n">INPUT</span> {<span class="p">,</span> <span class="n">INPUT</span>}<span class="o">)</span>

<span class="n">OUTPUT</span> <span class="o">::=</span> <span class="n">NAME</span> <span class="o">|</span> <span class="n">FUNCTION_RESULT</span>
<span class="n">INPUT</span>  <span class="o">::=</span> <span class="n">NAME</span>

<span class="n">where</span> <span class="n">FUNCTION_RESULT</span> <span class="kr">is</span><span class="p"> </span><span class="n">a</span> <span class="k">function </span><span class="nf">Result</span> <span class="n">attribute_reference</span>
</pre></div>
</div>
<p>For the semantics of this pragma, see the entry for aspect <code class="docutils literal notranslate"><span class="pre">Depends</span></code> in the
SPARK 2014 Reference Manual, section 6.1.5.</p>
</div>
<div class="section" id="pragma-detect-blocking">
<h2><span class="section-number">2.49. </span>Pragma Detect_Blocking<a class="headerlink" href="#pragma-detect-blocking" title="Permalink to this headline">¶</a></h2>
<p>Syntax:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma</span><span class="p"> </span><span class="n">Detect_Blocking</span><span class="p">;</span>
</pre></div>
</div>
<p>This is a standard pragma in Ada 2005, that is available in all earlier
versions of Ada as an implementation-defined pragma.</p>
<p>This is a configuration pragma that forces the detection of potentially
blocking operations within a protected operation, and to raise Program_Error
if that happens.</p>
</div>
<div class="section" id="pragma-disable-atomic-synchronization">
<h2><span class="section-number">2.50. </span>Pragma Disable_Atomic_Synchronization<a class="headerlink" href="#pragma-disable-atomic-synchronization" title="Permalink to this headline">¶</a></h2>
<p id="index-28">Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pragma</span> <span class="n">Disable_Atomic_Synchronization</span> <span class="p">[(</span><span class="n">Entity</span><span class="p">)];</span>
</pre></div>
</div>
<p>Ada requires that accesses (reads or writes) of an atomic variable be
regarded as synchronization points in the case of multiple tasks.
Particularly in the case of multi-processors this may require special
handling, e.g. the generation of memory barriers. This capability may
be turned off using this pragma in cases where it is known not to be
required.</p>
<p>The placement and scope rules for this pragma are the same as those
for <code class="docutils literal notranslate"><span class="pre">pragma</span> <span class="pre">Suppress</span></code>. In particular it can be used as a
configuration  pragma, or in a declaration sequence where it applies
till the end of the scope. If an <code class="docutils literal notranslate"><span class="pre">Entity</span></code> argument is present,
the action applies only to that entity.</p>
</div>
<div class="section" id="pragma-dispatching-domain">
<h2><span class="section-number">2.51. </span>Pragma Dispatching_Domain<a class="headerlink" href="#pragma-dispatching-domain" title="Permalink to this headline">¶</a></h2>
<p>Syntax:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma</span><span class="p"> </span><span class="n">Dispatching_Domain</span> <span class="o">(</span><span class="n">EXPRESSION</span><span class="o">)</span><span class="p">;</span>
</pre></div>
</div>
<p>This pragma is standard in Ada 2012, but is available in all earlier
versions of Ada as an implementation-defined pragma.
See Ada 2012 Reference Manual for details.</p>
</div>
<div class="section" id="pragma-effective-reads">
<span id="id10"></span><h2><span class="section-number">2.52. </span>Pragma Effective_Reads<a class="headerlink" href="#pragma-effective-reads" title="Permalink to this headline">¶</a></h2>
<p>Syntax:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma</span><span class="p"> </span><span class="n">Effective_Reads</span> [ <span class="o">(</span><span class="n">boolean_EXPRESSION</span><span class="o">)</span> ]<span class="p">;</span>
</pre></div>
</div>
<p>For the semantics of this pragma, see the entry for aspect <code class="docutils literal notranslate"><span class="pre">Effective_Reads</span></code> in
the SPARK 2014 Reference Manual, section 7.1.2.</p>
</div>
<div class="section" id="pragma-effective-writes">
<span id="id11"></span><h2><span class="section-number">2.53. </span>Pragma Effective_Writes<a class="headerlink" href="#pragma-effective-writes" title="Permalink to this headline">¶</a></h2>
<p>Syntax:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma</span><span class="p"> </span><span class="n">Effective_Writes</span> [ <span class="o">(</span><span class="n">boolean_EXPRESSION</span><span class="o">)</span> ]<span class="p">;</span>
</pre></div>
</div>
<p>For the semantics of this pragma, see the entry for aspect <code class="docutils literal notranslate"><span class="pre">Effective_Writes</span></code>
in the SPARK 2014 Reference Manual, section 7.1.2.</p>
</div>
<div class="section" id="pragma-elaboration-checks">
<h2><span class="section-number">2.54. </span>Pragma Elaboration_Checks<a class="headerlink" href="#pragma-elaboration-checks" title="Permalink to this headline">¶</a></h2>
<p id="index-29">Syntax:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma</span><span class="p"> </span><span class="n">Elaboration_Checks</span> <span class="o">(</span><span class="n">Dynamic</span> <span class="o">|</span> <span class="n">Static</span><span class="o">)</span><span class="p">;</span>
</pre></div>
</div>
<p>This is a configuration pragma which specifies the elaboration model to be
used during compilation. For more information on the elaboration models of
GNAT, consult the chapter on elaboration order handling in the <em>GNAT User’s
Guide</em>.</p>
<p>The pragma may appear in the following contexts:</p>
<ul class="simple">
<li><p>Configuration pragmas file</p></li>
<li><p>Prior to the context clauses of a compilation unit’s initial declaration</p></li>
</ul>
<p>Any other placement of the pragma will result in a warning and the effects of
the offending pragma will be ignored.</p>
<p>If the pragma argument is <code class="docutils literal notranslate"><span class="pre">Dynamic</span></code>, then the dynamic elaboration model is in
effect. If the pragma argument is <code class="docutils literal notranslate"><span class="pre">Static</span></code>, then the static elaboration model
is in effect.</p>
</div>
<div class="section" id="pragma-eliminate">
<h2><span class="section-number">2.55. </span>Pragma Eliminate<a class="headerlink" href="#pragma-eliminate" title="Permalink to this headline">¶</a></h2>
<p id="index-30">Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pragma</span> <span class="n">Eliminate</span> <span class="p">(</span>
            <span class="p">[</span>  <span class="n">Unit_Name</span>       <span class="o">=&gt;</span> <span class="p">]</span> <span class="n">IDENTIFIER</span> <span class="o">|</span> <span class="n">SELECTED_COMPONENT</span> <span class="p">,</span>
            <span class="p">[</span>  <span class="n">Entity</span>          <span class="o">=&gt;</span> <span class="p">]</span> <span class="n">IDENTIFIER</span> <span class="o">|</span>
                                    <span class="n">SELECTED_COMPONENT</span> <span class="o">|</span>
                                    <span class="n">STRING_LITERAL</span>
            <span class="p">[,</span> <span class="n">Source_Location</span> <span class="o">=&gt;</span>   <span class="n">SOURCE_TRACE</span> <span class="p">]</span> <span class="p">);</span>

        <span class="n">SOURCE_TRACE</span>    <span class="p">:</span><span class="o">:=</span> <span class="n">STRING_LITERAL</span>
</pre></div>
</div>
<p>This pragma indicates that the given entity is not used in the program to be
compiled and built, thus allowing the compiler to
eliminate the code or data associated with the named entity. Any reference to
an eliminated entity causes a compile-time or link-time error.</p>
<p>The pragma has the following semantics, where <code class="docutils literal notranslate"><span class="pre">U</span></code> is the unit specified by
the <code class="docutils literal notranslate"><span class="pre">Unit_Name</span></code> argument and <code class="docutils literal notranslate"><span class="pre">E</span></code> is the entity specified by the <code class="docutils literal notranslate"><span class="pre">Entity</span></code>
argument:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">E</span></code> must be a subprogram that is explicitly declared either:</p>
<p>o  Within <code class="docutils literal notranslate"><span class="pre">U</span></code>, or</p>
<p>o  Within a generic package that is instantiated in <code class="docutils literal notranslate"><span class="pre">U</span></code>, or</p>
<p>o  As an instance of generic subprogram instantiated in <code class="docutils literal notranslate"><span class="pre">U</span></code>.</p>
<p>Otherwise the pragma is ignored.</p>
</li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">E</span></code> is overloaded within <code class="docutils literal notranslate"><span class="pre">U</span></code> then, in the absence of a
<code class="docutils literal notranslate"><span class="pre">Source_Location</span></code> argument, all overloadings are eliminated.</p></li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">E</span></code> is overloaded within <code class="docutils literal notranslate"><span class="pre">U</span></code> and only some overloadings
are to be eliminated, then each overloading to be eliminated
must be specified in a corresponding pragma <code class="docutils literal notranslate"><span class="pre">Eliminate</span></code>
with a <code class="docutils literal notranslate"><span class="pre">Source_Location</span></code> argument identifying the line where the
declaration appears, as described below.</p></li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">E</span></code> is declared as the result of a generic instantiation, then
a <code class="docutils literal notranslate"><span class="pre">Source_Location</span></code> argument is needed, as described below</p></li>
</ul>
<p>Pragma <code class="docutils literal notranslate"><span class="pre">Eliminate</span></code> allows a program to be compiled in a system-independent
manner, so that unused entities are eliminated but without
needing to modify the source text. Normally the required set of
<code class="docutils literal notranslate"><span class="pre">Eliminate</span></code> pragmas is constructed automatically using the <code class="docutils literal notranslate"><span class="pre">gnatelim</span></code> tool.</p>
<p>Any source file change that removes, splits, or
adds lines may make the set of <code class="docutils literal notranslate"><span class="pre">Eliminate</span></code> pragmas invalid because their
<code class="docutils literal notranslate"><span class="pre">Source_Location</span></code> argument values may get out of date.</p>
<p>Pragma <code class="docutils literal notranslate"><span class="pre">Eliminate</span></code> may be used where the referenced entity is a dispatching
operation. In this case all the subprograms to which the given operation can
dispatch are considered to be unused (are never called as a result of a direct
or a dispatching call).</p>
<p>The string literal given for the source location specifies the line number
of the declaration of the entity, using the following syntax for <code class="docutils literal notranslate"><span class="pre">SOURCE_TRACE</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SOURCE_TRACE</span>     <span class="p">:</span><span class="o">:=</span> <span class="n">SOURCE_REFERENCE</span> <span class="p">[</span> <span class="n">LBRACKET</span> <span class="n">SOURCE_TRACE</span> <span class="n">RBRACKET</span> <span class="p">]</span>

<span class="n">LBRACKET</span>         <span class="p">:</span><span class="o">:=</span> <span class="s1">&#39;[&#39;</span>
<span class="n">RBRACKET</span>         <span class="p">:</span><span class="o">:=</span> <span class="s1">&#39;]&#39;</span>

<span class="n">SOURCE_REFERENCE</span> <span class="p">:</span><span class="o">:=</span> <span class="n">FILE_NAME</span> <span class="p">:</span> <span class="n">LINE_NUMBER</span>

<span class="n">LINE_NUMBER</span>      <span class="p">:</span><span class="o">:=</span> <span class="n">DIGIT</span> <span class="p">{</span><span class="n">DIGIT</span><span class="p">}</span>
</pre></div>
</div>
<p>Spaces around the colon in a <code class="docutils literal notranslate"><span class="pre">SOURCE_REFERENCE</span></code> are optional.</p>
<p>The source trace that is given as the <code class="docutils literal notranslate"><span class="pre">Source_Location</span></code> must obey the
following rules (or else the pragma is ignored), where <code class="docutils literal notranslate"><span class="pre">U</span></code> is
the unit <code class="docutils literal notranslate"><span class="pre">U</span></code> specified by the <code class="docutils literal notranslate"><span class="pre">Unit_Name</span></code> argument and <code class="docutils literal notranslate"><span class="pre">E</span></code> is the
subprogram specified by the <code class="docutils literal notranslate"><span class="pre">Entity</span></code> argument:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">FILE_NAME</span></code> is the short name (with no directory
information) of the Ada source file for <code class="docutils literal notranslate"><span class="pre">U</span></code>, using the required syntax
for the underlying file system (e.g. case is significant if the underlying
operating system is case sensitive).
If <code class="docutils literal notranslate"><span class="pre">U</span></code> is a package and <code class="docutils literal notranslate"><span class="pre">E</span></code> is a subprogram declared in the package
specification and its full declaration appears in the package body,
then the  relevant source file is the one for the package specification;
analogously if <code class="docutils literal notranslate"><span class="pre">U</span></code> is a generic package.</p></li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">E</span></code> is not declared in a generic instantiation (this includes
generic subprogram instances), the source trace includes only one source
line reference. <code class="docutils literal notranslate"><span class="pre">LINE_NUMBER</span></code> gives the line number of the occurrence
of the declaration of <code class="docutils literal notranslate"><span class="pre">E</span></code> within the source file (as a decimal literal
without an exponent or point).</p></li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">E</span></code> is declared by a generic instantiation, its source trace
(from left to right) starts with the source location of the
declaration of <code class="docutils literal notranslate"><span class="pre">E</span></code> in the generic unit and ends with the source
location of the instantiation, given in square brackets. This approach is
applied recursively with nested instantiations: the rightmost (nested
most deeply in square brackets) element of the source trace is the location
of the outermost instantiation, and the leftmost element (that is, outside
of any square brackets) is the location of the declaration of <code class="docutils literal notranslate"><span class="pre">E</span></code> in
the generic unit.</p></li>
</ul>
<p>Examples:</p>
<blockquote>
<div><div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma</span><span class="p"> </span><span class="n">Eliminate</span> <span class="o">(</span><span class="n">Pkg0</span><span class="p">,</span> <span class="n">Proc</span><span class="o">)</span><span class="p">;</span>
<span class="c">-- Eliminate (all overloadings of) Proc in Pkg0</span>

<span class="kr">pragma</span><span class="p"> </span><span class="n">Eliminate</span> <span class="o">(</span><span class="n">Pkg1</span><span class="p">,</span> <span class="n">Proc</span><span class="p">,</span>
                  <span class="n">Source_Location</span> <span class="o">=&gt;</span> <span class="s">&quot;pkg1.ads:8&quot;</span><span class="o">)</span><span class="p">;</span>
<span class="c">-- Eliminate overloading of Proc at line 8 in pkg1.ads</span>

<span class="c">-- Assume the following file contents:</span>
<span class="c">--   gen_pkg.ads</span>
<span class="c">--   1: generic</span>
<span class="c">--   2:   type T is private;</span>
<span class="c">--   3: package Gen_Pkg is</span>
<span class="c">--   4:   procedure Proc(N : T);</span>
<span class="c">--  ...   ...</span>
<span class="c">--  ... end Gen_Pkg;</span>
<span class="c">--</span>
<span class="c">--    q.adb</span>
<span class="c">--   1: with Gen_Pkg;</span>
<span class="c">--   2: procedure Q is</span>
<span class="c">--   3:   package Inst_Pkg is new Gen_Pkg(Integer);</span>
<span class="c">--  ...   -- No calls on Inst_Pkg.Proc</span>
<span class="c">--  ... end Q;</span>

<span class="c">-- The following pragma eliminates Inst_Pkg.Proc from Q</span>
<span class="kr">pragma</span><span class="p"> </span><span class="n">Eliminate</span> <span class="o">(</span><span class="n">Q</span><span class="p">,</span> <span class="n">Proc</span><span class="p">,</span>
                  <span class="n">Source_Location</span> <span class="o">=&gt;</span> <span class="s">&quot;gen_pkg.ads:4[q.adb:3]&quot;</span><span class="o">)</span><span class="p">;</span>
</pre></div>
</div>
</div></blockquote>
</div>
<div class="section" id="pragma-enable-atomic-synchronization">
<h2><span class="section-number">2.56. </span>Pragma Enable_Atomic_Synchronization<a class="headerlink" href="#pragma-enable-atomic-synchronization" title="Permalink to this headline">¶</a></h2>
<p id="index-31">Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pragma</span> <span class="n">Enable_Atomic_Synchronization</span> <span class="p">[(</span><span class="n">Entity</span><span class="p">)];</span>
</pre></div>
</div>
<p>Ada requires that accesses (reads or writes) of an atomic variable be
regarded as synchronization points in the case of multiple tasks.
Particularly in the case of multi-processors this may require special
handling, e.g. the generation of memory barriers. This synchronization
is performed by default, but can be turned off using
<code class="docutils literal notranslate"><span class="pre">pragma</span> <span class="pre">Disable_Atomic_Synchronization</span></code>. The
<code class="docutils literal notranslate"><span class="pre">Enable_Atomic_Synchronization</span></code> pragma can be used to turn
it back on.</p>
<p>The placement and scope rules for this pragma are the same as those
for <code class="docutils literal notranslate"><span class="pre">pragma</span> <span class="pre">Unsuppress</span></code>. In particular it can be used as a
configuration  pragma, or in a declaration sequence where it applies
till the end of the scope. If an <code class="docutils literal notranslate"><span class="pre">Entity</span></code> argument is present,
the action applies only to that entity.</p>
</div>
<div class="section" id="pragma-export-function">
<h2><span class="section-number">2.57. </span>Pragma Export_Function<a class="headerlink" href="#pragma-export-function" title="Permalink to this headline">¶</a></h2>
<p id="index-32">Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pragma</span> <span class="n">Export_Function</span> <span class="p">(</span>
     <span class="p">[</span><span class="n">Internal</span>         <span class="o">=&gt;</span><span class="p">]</span> <span class="n">LOCAL_NAME</span>
  <span class="p">[,</span> <span class="p">[</span><span class="n">External</span>         <span class="o">=&gt;</span><span class="p">]</span> <span class="n">EXTERNAL_SYMBOL</span><span class="p">]</span>
  <span class="p">[,</span> <span class="p">[</span><span class="n">Parameter_Types</span>  <span class="o">=&gt;</span><span class="p">]</span> <span class="n">PARAMETER_TYPES</span><span class="p">]</span>
  <span class="p">[,</span> <span class="p">[</span><span class="n">Result_Type</span>      <span class="o">=&gt;</span><span class="p">]</span> <span class="n">result_SUBTYPE_MARK</span><span class="p">]</span>
  <span class="p">[,</span> <span class="p">[</span><span class="n">Mechanism</span>        <span class="o">=&gt;</span><span class="p">]</span> <span class="n">MECHANISM</span><span class="p">]</span>
  <span class="p">[,</span> <span class="p">[</span><span class="n">Result_Mechanism</span> <span class="o">=&gt;</span><span class="p">]</span> <span class="n">MECHANISM_NAME</span><span class="p">]);</span>

<span class="n">EXTERNAL_SYMBOL</span> <span class="p">:</span><span class="o">:=</span>
  <span class="n">IDENTIFIER</span>
<span class="o">|</span> <span class="n">static_string_EXPRESSION</span>
<span class="o">|</span> <span class="s2">&quot;&quot;</span>

<span class="n">PARAMETER_TYPES</span> <span class="p">:</span><span class="o">:=</span>
  <span class="n">null</span>
<span class="o">|</span> <span class="n">TYPE_DESIGNATOR</span> <span class="p">{,</span> <span class="n">TYPE_DESIGNATOR</span><span class="p">}</span>

<span class="n">TYPE_DESIGNATOR</span> <span class="p">:</span><span class="o">:=</span>
  <span class="n">subtype_NAME</span>
<span class="o">|</span> <span class="n">subtype_Name</span> <span class="s1">&#39; Access</span>

<span class="n">MECHANISM</span> <span class="p">:</span><span class="o">:=</span>
  <span class="n">MECHANISM_NAME</span>
<span class="o">|</span> <span class="p">(</span><span class="n">MECHANISM_ASSOCIATION</span> <span class="p">{,</span> <span class="n">MECHANISM_ASSOCIATION</span><span class="p">})</span>

<span class="n">MECHANISM_ASSOCIATION</span> <span class="p">:</span><span class="o">:=</span>
  <span class="p">[</span><span class="n">formal_parameter_NAME</span> <span class="o">=&gt;</span><span class="p">]</span> <span class="n">MECHANISM_NAME</span>

<span class="n">MECHANISM_NAME</span> <span class="p">:</span><span class="o">:=</span> <span class="n">Value</span> <span class="o">|</span> <span class="n">Reference</span>
</pre></div>
</div>
<p>Use this pragma to make a function externally callable and optionally
provide information on mechanisms to be used for passing parameter and
result values.  We recommend, for the purposes of improving portability,
this pragma always be used in conjunction with a separate pragma
<code class="docutils literal notranslate"><span class="pre">Export</span></code>, which must precede the pragma <code class="docutils literal notranslate"><span class="pre">Export_Function</span></code>.
GNAT does not require a separate pragma <code class="docutils literal notranslate"><span class="pre">Export</span></code>, but if none is
present, <code class="docutils literal notranslate"><span class="pre">Convention</span> <span class="pre">Ada</span></code> is assumed, which is usually
not what is wanted, so it is usually appropriate to use this
pragma in conjunction with a <code class="docutils literal notranslate"><span class="pre">Export</span></code> or <code class="docutils literal notranslate"><span class="pre">Convention</span></code>
pragma that specifies the desired foreign convention.
Pragma <code class="docutils literal notranslate"><span class="pre">Export_Function</span></code>
(and <code class="docutils literal notranslate"><span class="pre">Export</span></code>, if present) must appear in the same declarative
region as the function to which they apply.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">internal_name</span></code> must uniquely designate the function to which the
pragma applies.  If more than one function name exists of this name in
the declarative part you must use the <code class="docutils literal notranslate"><span class="pre">Parameter_Types</span></code> and
<code class="docutils literal notranslate"><span class="pre">Result_Type</span></code> parameters to achieve the required
unique designation.  The <cite>subtype_mark</cite>s in these parameters must
exactly match the subtypes in the corresponding function specification,
using positional notation to match parameters with subtype marks.
The form with an <code class="docutils literal notranslate"><span class="pre">'Access</span></code> attribute can be used to match an
anonymous access parameter.</p>
<p id="index-33">Special treatment is given if the EXTERNAL is an explicit null
string or a static string expressions that evaluates to the null
string. In this case, no external name is generated. This form
still allows the specification of parameter mechanisms.</p>
</div>
<div class="section" id="pragma-export-object">
<h2><span class="section-number">2.58. </span>Pragma Export_Object<a class="headerlink" href="#pragma-export-object" title="Permalink to this headline">¶</a></h2>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pragma</span> <span class="n">Export_Object</span>
      <span class="p">[</span><span class="n">Internal</span> <span class="o">=&gt;</span><span class="p">]</span> <span class="n">LOCAL_NAME</span>
   <span class="p">[,</span> <span class="p">[</span><span class="n">External</span> <span class="o">=&gt;</span><span class="p">]</span> <span class="n">EXTERNAL_SYMBOL</span><span class="p">]</span>
   <span class="p">[,</span> <span class="p">[</span><span class="n">Size</span>     <span class="o">=&gt;</span><span class="p">]</span> <span class="n">EXTERNAL_SYMBOL</span><span class="p">]</span>

<span class="n">EXTERNAL_SYMBOL</span> <span class="p">:</span><span class="o">:=</span>
  <span class="n">IDENTIFIER</span>
<span class="o">|</span> <span class="n">static_string_EXPRESSION</span>
</pre></div>
</div>
<p>This pragma designates an object as exported, and apart from the
extended rules for external symbols, is identical in effect to the use of
the normal <code class="docutils literal notranslate"><span class="pre">Export</span></code> pragma applied to an object.  You may use a
separate Export pragma (and you probably should from the point of view
of portability), but it is not required.  <code class="docutils literal notranslate"><span class="pre">Size</span></code> is syntax checked,
but otherwise ignored by GNAT.</p>
</div>
<div class="section" id="pragma-export-procedure">
<h2><span class="section-number">2.59. </span>Pragma Export_Procedure<a class="headerlink" href="#pragma-export-procedure" title="Permalink to this headline">¶</a></h2>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pragma</span> <span class="n">Export_Procedure</span> <span class="p">(</span>
     <span class="p">[</span><span class="n">Internal</span>        <span class="o">=&gt;</span><span class="p">]</span> <span class="n">LOCAL_NAME</span>
  <span class="p">[,</span> <span class="p">[</span><span class="n">External</span>        <span class="o">=&gt;</span><span class="p">]</span> <span class="n">EXTERNAL_SYMBOL</span><span class="p">]</span>
  <span class="p">[,</span> <span class="p">[</span><span class="n">Parameter_Types</span> <span class="o">=&gt;</span><span class="p">]</span> <span class="n">PARAMETER_TYPES</span><span class="p">]</span>
  <span class="p">[,</span> <span class="p">[</span><span class="n">Mechanism</span>       <span class="o">=&gt;</span><span class="p">]</span> <span class="n">MECHANISM</span><span class="p">]);</span>

<span class="n">EXTERNAL_SYMBOL</span> <span class="p">:</span><span class="o">:=</span>
  <span class="n">IDENTIFIER</span>
<span class="o">|</span> <span class="n">static_string_EXPRESSION</span>
<span class="o">|</span> <span class="s2">&quot;&quot;</span>

<span class="n">PARAMETER_TYPES</span> <span class="p">:</span><span class="o">:=</span>
  <span class="n">null</span>
<span class="o">|</span> <span class="n">TYPE_DESIGNATOR</span> <span class="p">{,</span> <span class="n">TYPE_DESIGNATOR</span><span class="p">}</span>

<span class="n">TYPE_DESIGNATOR</span> <span class="p">:</span><span class="o">:=</span>
  <span class="n">subtype_NAME</span>
<span class="o">|</span> <span class="n">subtype_Name</span> <span class="s1">&#39; Access</span>

<span class="n">MECHANISM</span> <span class="p">:</span><span class="o">:=</span>
  <span class="n">MECHANISM_NAME</span>
<span class="o">|</span> <span class="p">(</span><span class="n">MECHANISM_ASSOCIATION</span> <span class="p">{,</span> <span class="n">MECHANISM_ASSOCIATION</span><span class="p">})</span>

<span class="n">MECHANISM_ASSOCIATION</span> <span class="p">:</span><span class="o">:=</span>
  <span class="p">[</span><span class="n">formal_parameter_NAME</span> <span class="o">=&gt;</span><span class="p">]</span> <span class="n">MECHANISM_NAME</span>

<span class="n">MECHANISM_NAME</span> <span class="p">:</span><span class="o">:=</span> <span class="n">Value</span> <span class="o">|</span> <span class="n">Reference</span>
</pre></div>
</div>
<p>This pragma is identical to <code class="docutils literal notranslate"><span class="pre">Export_Function</span></code> except that it
applies to a procedure rather than a function and the parameters
<code class="docutils literal notranslate"><span class="pre">Result_Type</span></code> and <code class="docutils literal notranslate"><span class="pre">Result_Mechanism</span></code> are not permitted.
GNAT does not require a separate pragma <code class="docutils literal notranslate"><span class="pre">Export</span></code>, but if none is
present, <code class="docutils literal notranslate"><span class="pre">Convention</span> <span class="pre">Ada</span></code> is assumed, which is usually
not what is wanted, so it is usually appropriate to use this
pragma in conjunction with a <code class="docutils literal notranslate"><span class="pre">Export</span></code> or <code class="docutils literal notranslate"><span class="pre">Convention</span></code>
pragma that specifies the desired foreign convention.</p>
<p id="index-34">Special treatment is given if the EXTERNAL is an explicit null
string or a static string expressions that evaluates to the null
string. In this case, no external name is generated. This form
still allows the specification of parameter mechanisms.</p>
</div>
<div class="section" id="pragma-export-valued-procedure">
<h2><span class="section-number">2.60. </span>Pragma Export_Valued_Procedure<a class="headerlink" href="#pragma-export-valued-procedure" title="Permalink to this headline">¶</a></h2>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pragma</span> <span class="n">Export_Valued_Procedure</span> <span class="p">(</span>
     <span class="p">[</span><span class="n">Internal</span>        <span class="o">=&gt;</span><span class="p">]</span> <span class="n">LOCAL_NAME</span>
  <span class="p">[,</span> <span class="p">[</span><span class="n">External</span>        <span class="o">=&gt;</span><span class="p">]</span> <span class="n">EXTERNAL_SYMBOL</span><span class="p">]</span>
  <span class="p">[,</span> <span class="p">[</span><span class="n">Parameter_Types</span> <span class="o">=&gt;</span><span class="p">]</span> <span class="n">PARAMETER_TYPES</span><span class="p">]</span>
  <span class="p">[,</span> <span class="p">[</span><span class="n">Mechanism</span>       <span class="o">=&gt;</span><span class="p">]</span> <span class="n">MECHANISM</span><span class="p">]);</span>

<span class="n">EXTERNAL_SYMBOL</span> <span class="p">:</span><span class="o">:=</span>
  <span class="n">IDENTIFIER</span>
<span class="o">|</span> <span class="n">static_string_EXPRESSION</span>
<span class="o">|</span> <span class="s2">&quot;&quot;</span>

<span class="n">PARAMETER_TYPES</span> <span class="p">:</span><span class="o">:=</span>
  <span class="n">null</span>
<span class="o">|</span> <span class="n">TYPE_DESIGNATOR</span> <span class="p">{,</span> <span class="n">TYPE_DESIGNATOR</span><span class="p">}</span>

<span class="n">TYPE_DESIGNATOR</span> <span class="p">:</span><span class="o">:=</span>
  <span class="n">subtype_NAME</span>
<span class="o">|</span> <span class="n">subtype_Name</span> <span class="s1">&#39; Access</span>

<span class="n">MECHANISM</span> <span class="p">:</span><span class="o">:=</span>
  <span class="n">MECHANISM_NAME</span>
<span class="o">|</span> <span class="p">(</span><span class="n">MECHANISM_ASSOCIATION</span> <span class="p">{,</span> <span class="n">MECHANISM_ASSOCIATION</span><span class="p">})</span>

<span class="n">MECHANISM_ASSOCIATION</span> <span class="p">:</span><span class="o">:=</span>
  <span class="p">[</span><span class="n">formal_parameter_NAME</span> <span class="o">=&gt;</span><span class="p">]</span> <span class="n">MECHANISM_NAME</span>

<span class="n">MECHANISM_NAME</span> <span class="p">:</span><span class="o">:=</span> <span class="n">Value</span> <span class="o">|</span> <span class="n">Reference</span>
</pre></div>
</div>
<p>This pragma is identical to <code class="docutils literal notranslate"><span class="pre">Export_Procedure</span></code> except that the
first parameter of <code class="docutils literal notranslate"><span class="pre">LOCAL_NAME</span></code>, which must be present, must be of
mode <code class="docutils literal notranslate"><span class="pre">out</span></code>, and externally the subprogram is treated as a function
with this parameter as the result of the function.  GNAT provides for
this capability to allow the use of <code class="docutils literal notranslate"><span class="pre">out</span></code> and <code class="docutils literal notranslate"><span class="pre">in</span> <span class="pre">out</span></code>
parameters in interfacing to external functions (which are not permitted
in Ada functions).
GNAT does not require a separate pragma <code class="docutils literal notranslate"><span class="pre">Export</span></code>, but if none is
present, <code class="docutils literal notranslate"><span class="pre">Convention</span> <span class="pre">Ada</span></code> is assumed, which is almost certainly
not what is wanted since the whole point of this pragma is to interface
with foreign language functions, so it is usually appropriate to use this
pragma in conjunction with a <code class="docutils literal notranslate"><span class="pre">Export</span></code> or <code class="docutils literal notranslate"><span class="pre">Convention</span></code>
pragma that specifies the desired foreign convention.</p>
<p id="index-35">Special treatment is given if the EXTERNAL is an explicit null
string or a static string expressions that evaluates to the null
string. In this case, no external name is generated. This form
still allows the specification of parameter mechanisms.</p>
</div>
<div class="section" id="pragma-extend-system">
<h2><span class="section-number">2.61. </span>Pragma Extend_System<a class="headerlink" href="#pragma-extend-system" title="Permalink to this headline">¶</a></h2>
<span class="target" id="index-36"></span><p id="index-37">Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pragma</span> <span class="n">Extend_System</span> <span class="p">([</span><span class="n">Name</span> <span class="o">=&gt;</span><span class="p">]</span> <span class="n">IDENTIFIER</span><span class="p">);</span>
</pre></div>
</div>
<p>This pragma is used to provide backwards compatibility with other
implementations that extend the facilities of package <code class="docutils literal notranslate"><span class="pre">System</span></code>.  In
GNAT, <code class="docutils literal notranslate"><span class="pre">System</span></code> contains only the definitions that are present in
the Ada RM.  However, other implementations, notably the DEC Ada 83
implementation, provide many extensions to package <code class="docutils literal notranslate"><span class="pre">System</span></code>.</p>
<p>For each such implementation accommodated by this pragma, GNAT provides a
package <code class="samp docutils literal notranslate"><span class="pre">Aux_</span><em><span class="pre">xxx</span></em></code>, e.g., <code class="docutils literal notranslate"><span class="pre">Aux_DEC</span></code> for the DEC Ada 83
implementation, which provides the required additional definitions.  You
can use this package in two ways.  You can <code class="docutils literal notranslate"><span class="pre">with</span></code> it in the normal
way and access entities either by selection or using a <code class="docutils literal notranslate"><span class="pre">use</span></code>
clause.  In this case no special processing is required.</p>
<p>However, if existing code contains references such as
<code class="samp docutils literal notranslate"><span class="pre">System.</span><em><span class="pre">xxx</span></em></code> where <em>xxx</em> is an entity in the extended
definitions provided in package <code class="docutils literal notranslate"><span class="pre">System</span></code>, you may use this pragma
to extend visibility in <code class="docutils literal notranslate"><span class="pre">System</span></code> in a non-standard way that
provides greater compatibility with the existing code.  Pragma
<code class="docutils literal notranslate"><span class="pre">Extend_System</span></code> is a configuration pragma whose single argument is
the name of the package containing the extended definition
(e.g., <code class="docutils literal notranslate"><span class="pre">Aux_DEC</span></code> for the DEC Ada case).  A unit compiled under
control of this pragma will be processed using special visibility
processing that looks in package <code class="samp docutils literal notranslate"><span class="pre">System.Aux_</span><em><span class="pre">xxx</span></em></code> where
<code class="samp docutils literal notranslate"><span class="pre">Aux_</span><em><span class="pre">xxx</span></em></code> is the pragma argument for any entity referenced in
package <code class="docutils literal notranslate"><span class="pre">System</span></code>, but not found in package <code class="docutils literal notranslate"><span class="pre">System</span></code>.</p>
<p>You can use this pragma either to access a predefined <code class="docutils literal notranslate"><span class="pre">System</span></code>
extension supplied with the compiler, for example <code class="docutils literal notranslate"><span class="pre">Aux_DEC</span></code> or
you can construct your own extension unit following the above
definition.  Note that such a package is a child of <code class="docutils literal notranslate"><span class="pre">System</span></code>
and thus is considered part of the implementation.
To compile it you will have to use the <em>-gnatg</em> switch
for compiling System units, as explained in the
GNAT User’s Guide.</p>
</div>
<div class="section" id="pragma-extensions-allowed">
<h2><span class="section-number">2.62. </span>Pragma Extensions_Allowed<a class="headerlink" href="#pragma-extensions-allowed" title="Permalink to this headline">¶</a></h2>
<span class="target" id="index-38"></span><p id="index-39">Syntax:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma</span><span class="p"> </span><span class="n">Extensions_Allowed</span> <span class="o">(</span><span class="n">On</span> <span class="o">|</span> <span class="n">Off</span><span class="o">)</span><span class="p">;</span>
</pre></div>
</div>
<p>This configuration pragma enables or disables the implementation
extension mode (the use of Off as a parameter cancels the effect
of the <em>-gnatX</em> command switch).</p>
<p>In extension mode, the latest version of the Ada language is
implemented (currently Ada 2022), and in addition a number
of GNAT specific extensions are recognized as follows:</p>
<ul>
<li><p>Constrained attribute for generic objects</p>
<p>The <code class="docutils literal notranslate"><span class="pre">Constrained</span></code> attribute is permitted for objects of
generic types. The result indicates if the corresponding actual
is constrained.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">Static</span></code> aspect on intrinsic functions</p>
<p>The Ada 202x <code class="docutils literal notranslate"><span class="pre">Static</span></code> aspect can be specified on Intrinsic imported
functions and the compiler will evaluate some of these intrinsic statically,
in particular the <code class="docutils literal notranslate"><span class="pre">Shift_Left</span></code> and <code class="docutils literal notranslate"><span class="pre">Shift_Right</span></code> intrinsics.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">'Reduce</span></code> attribute</p>
<p>This attribute part of the Ada 202x language definition is provided for
now under -gnatX to confirm and potentially refine its usage and syntax.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">[]</span></code> aggregates</p>
<p>This new aggregate syntax for arrays and containers is provided under -gnatX
to experiment and confirm this new language syntax.</p>
</li>
<li><p>Additional <code class="docutils literal notranslate"><span class="pre">when</span></code> constructs</p>
<p>In addition to the <code class="docutils literal notranslate"><span class="pre">exit</span> <span class="pre">when</span> <span class="pre">CONDITION</span></code> control structure, several
additional constructs are allowed following this format. Including
<code class="docutils literal notranslate"><span class="pre">return</span> <span class="pre">when</span> <span class="pre">CONDITION</span></code>, <code class="docutils literal notranslate"><span class="pre">goto</span> <span class="pre">when</span> <span class="pre">CONDITION</span></code>, and
<code class="docutils literal notranslate"><span class="pre">raise</span> <span class="pre">[with</span> <span class="pre">EXCEPTION_MESSAGE]</span> <span class="pre">when</span> <span class="pre">CONDITION.</span></code></p>
<p>Some examples:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">return</span><span class="p"> </span><span class="n">Result</span> <span class="kr">when</span><span class="p"> </span><span class="n">Variable</span> <span class="o">&gt;</span> <span class="mi">10</span><span class="p">;</span>

<span class="kr">raise</span><span class="p"> </span><span class="n">Program_Error</span> <span class="kr">with</span><span class="p"> </span><span class="s">&quot;Element is null&quot;</span> <span class="kr">when</span><span class="p"> </span><span class="n">Element</span> <span class="o">=</span> <span class="kr">null</span><span class="p">;</span>

<span class="kr">goto</span><span class="p"> </span><span class="n">End_Of_Subprogram</span> <span class="kr">when</span><span class="p"> </span><span class="n">Variable</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</pre></div>
</div>
</li>
<li><p>Casing on composite values (aka pattern matching)</p>
<p>The selector for a case statement may be of a composite type, subject to
some restrictions (described below). Aggregate syntax is used for choices
of such a case statement; however, in cases where a “normal” aggregate would
require a discrete value, a discrete subtype may be used instead; box
notation can also be used to match all values (but currently only
for discrete subcomponents).</p>
<p>Consider this example:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">type</span><span class="p"> </span><span class="n">Rec</span> <span class="kr">is</span><span class="p"> </span><span class="kr">record</span><span class="p"></span>
   <span class="n">F1</span><span class="p">,</span> <span class="n">F2</span> <span class="o">:</span> <span class="n">Integer</span><span class="p">;</span>
<span class="k">end record</span><span class="p">;</span>

<span class="k">procedure </span><span class="nf">Caser_1</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">Rec</span><span class="o">)</span> <span class="kr">is</span><span class="p"></span>
<span class="kr">begin</span><span class="p"></span>
   <span class="kr">case</span><span class="p"> </span><span class="n">X</span> <span class="kr">is</span><span class="p"></span>
      <span class="kr">when</span><span class="p"> </span><span class="o">(</span><span class="n">F1</span> <span class="o">=&gt;</span> <span class="n">Positive</span><span class="p">,</span> <span class="n">F2</span> <span class="o">=&gt;</span> <span class="n">Positive</span><span class="o">)</span> <span class="o">=&gt;</span>
         <span class="n">Do_This</span><span class="p">;</span>
      <span class="kr">when</span><span class="p"> </span><span class="o">(</span><span class="n">F1</span> <span class="o">=&gt;</span> <span class="n">Natural</span><span class="p">,</span> <span class="n">F2</span> <span class="o">=&gt;</span> <span class="o">&lt;&gt;)</span> <span class="o">|</span> <span class="o">(</span><span class="n">F1</span> <span class="o">=&gt;</span> <span class="o">&lt;&gt;</span><span class="p">,</span> <span class="n">F2</span> <span class="o">=&gt;</span> <span class="n">Natural</span><span class="o">)</span> <span class="o">=&gt;</span>
         <span class="n">Do_That</span><span class="p">;</span>
      <span class="kr">when</span><span class="p"> </span><span class="kr">others</span><span class="p"> </span><span class="o">=&gt;</span>
          <span class="n">Do_The_Other_Thing</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">case</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Caser_1</span><span class="p">;</span>
</pre></div>
</div>
<p>If Caser_1 is called and both components of X are positive, then
Do_This will be called; otherwise, if either component is nonnegative
then Do_That will be called; otherwise, Do_The_Other_Thing will be called.</p>
<p>If the set of values that match the choice(s) of an earlier alternative
overlaps the corresponding set of a later alternative, then the first
set shall be a proper subset of the second (and the later alternative
will not be executed if the earlier alternative “matches”). All possible
values of the composite type shall be covered. The composite type of the
selector shall be a nonlimited untagged undiscriminated record type, all
of whose subcomponent subtypes are either static discrete subtypes or
record types that meet the same restrictions. Support for arrays is
planned, but not yet implemented.</p>
<p>In addition, pattern bindings are supported. This is a mechanism
for binding a name to a component of a matching value for use within
an alternative of a case statement. For a component association
that occurs within a case choice, the expression may be followed by
“is &lt;identifier&gt;”. In the special case of a “box” component association,
the identifier may instead be provided within the box. Either of these
indicates that the given identifer denotes (a constant view of) the matching
subcomponent of the case selector.</p>
<p>Consider this example (which uses type Rec from the previous example):</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="k">procedure </span><span class="nf">Caser_2</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">Rec</span><span class="o">)</span> <span class="kr">is</span><span class="p"></span>
<span class="kr">begin</span><span class="p"></span>
   <span class="kr">case</span><span class="p"> </span><span class="n">X</span> <span class="kr">is</span><span class="p"></span>
      <span class="kr">when</span><span class="p"> </span><span class="o">(</span><span class="n">F1</span> <span class="o">=&gt;</span> <span class="n">Positive</span> <span class="kr">is</span><span class="p"> </span><span class="n">Abc</span><span class="p">,</span> <span class="n">F2</span> <span class="o">=&gt;</span> <span class="n">Positive</span><span class="o">)</span> <span class="o">=&gt;</span>
         <span class="n">Do_This</span> <span class="o">(</span><span class="n">Abc</span><span class="o">)</span>
      <span class="kr">when</span><span class="p"> </span><span class="o">(</span><span class="n">F1</span> <span class="o">=&gt;</span> <span class="n">Natural</span> <span class="kr">is</span><span class="p"> </span><span class="n">N1</span><span class="p">,</span> <span class="n">F2</span> <span class="o">=&gt;</span> <span class="o">&lt;</span><span class="n">N2</span><span class="o">&gt;)</span> <span class="o">|</span>
           <span class="o">(</span><span class="n">F1</span> <span class="o">=&gt;</span> <span class="o">&lt;</span><span class="n">N2</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">F2</span> <span class="o">=&gt;</span> <span class="n">Natural</span> <span class="kr">is</span><span class="p"> </span><span class="n">N1</span><span class="o">)</span> <span class="o">=&gt;</span>
         <span class="n">Do_That</span> <span class="o">(</span><span class="n">Param_1</span> <span class="o">=&gt;</span> <span class="n">N1</span><span class="p">,</span> <span class="n">Param_2</span> <span class="o">=&gt;</span> <span class="n">N2</span><span class="o">)</span><span class="p">;</span>
      <span class="kr">when</span><span class="p"> </span><span class="kr">others</span><span class="p"> </span><span class="o">=&gt;</span>
         <span class="n">Do_The_Other_Thing</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">case</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Caser_2</span><span class="p">;</span>
</pre></div>
</div>
<p>This example is the same as the previous one with respect to
determining whether Do_This, Do_That, or Do_The_Other_Thing will
be called. But for this version, Do_This takes a parameter and Do_That
takes two parameters. If Do_This is called, the actual parameter in the
call will be X.F1.</p>
<p>If Do_That is called, the situation is more complex because there are two
choices for that alternative. If Do_That is called because the first choice
matched (i.e., because X.F1 is nonnegative and either X.F1 or X.F2 is zero
or negative), then the actual parameters of the call will be (in order)
X.F1 and X.F2. If Do_That is called because the second choice matched (and
the first one did not), then the actual parameters will be reversed.</p>
<p>Within the choice list for single alternative, each choice must
define the same set of bindings and the component subtypes for
for a given identifer must all statically match. Currently, the case
of a binding for a nondiscrete component is not implemented.</p>
</li>
<li><p>Fixed lower bounds for array types and subtypes</p>
<p>Unconstrained array types and subtypes can be specified with a lower bound
that is fixed to a certain value, by writing an index range that uses the
syntax “&lt;lower-bound-expression&gt; .. &lt;&gt;”. This guarantees that all objects
of the type or subtype will have the specified lower bound.</p>
<p>For example, a matrix type with fixed lower bounds of zero for each
dimension can be declared by the following:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">type</span><span class="p"> </span><span class="n">Matrix</span> <span class="kr">is</span><span class="p"></span>
  <span class="kr">array</span><span class="p"> </span><span class="o">(</span><span class="n">Natural</span> <span class="kr">range</span><span class="p"> </span><span class="mi">0</span> <span class="o">..</span> <span class="o">&lt;&gt;</span><span class="p">,</span> <span class="n">Natural</span> <span class="kr">range</span><span class="p"> </span><span class="mi">0</span> <span class="o">..</span> <span class="o">&lt;&gt;)</span> <span class="kr">of</span><span class="p"> </span><span class="n">Integer</span><span class="p">;</span>
</pre></div>
</div>
<p>Objects of type Matrix declared with an index constraint must have index
ranges starting at zero:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="n">M1</span> <span class="o">:</span> <span class="n">Matrix</span> <span class="o">(</span><span class="mi">0</span> <span class="o">..</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">0</span> <span class="o">..</span> <span class="mi">19</span><span class="o">)</span><span class="p">;</span>
<span class="n">M2</span> <span class="o">:</span> <span class="n">Matrix</span> <span class="o">(</span><span class="mi">2</span> <span class="o">..</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">3</span> <span class="o">..</span> <span class="mi">22</span><span class="o">)</span><span class="p">;</span>  <span class="c">-- Warning about bounds; will raise CE</span>
</pre></div>
</div>
<p>Similarly, a subtype of String can be declared that specifies the lower
bound of objects of that subtype to be 1:</p>
<blockquote>
<div><div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">subtype</span><span class="p"> </span><span class="n">String_1</span> <span class="kr">is</span><span class="p"> </span><span class="n">String</span> <span class="o">(</span><span class="mi">1</span> <span class="o">..</span> <span class="o">&lt;&gt;)</span><span class="p">;</span>
</pre></div>
</div>
</div></blockquote>
<p>If a string slice is passed to a formal of subtype String_1 in a call to
a subprogram S, the slice’s bounds will “slide” so that the lower bound
is 1. Within S, the lower bound of the formal is known to be 1, so, unlike
a normal unconstrained String formal, there is no need to worry about
accounting for other possible lower-bound values. Sliding of bounds also
occurs in other contexts, such as for object declarations with an
unconstrained subtype with fixed lower bound, as well as in subtype
conversions.</p>
<p>Use of this feature increases safety by simplifying code, and can also
improve the efficiency of indexing operations, since the compiler statically
knows the lower bound of unconstrained array formals when the formal’s
subtype has index ranges with static fixed lower bounds.</p>
</li>
<li><p>Prefixed-view notation for calls to primitive subprograms of untagged types</p>
<p>Since Ada 2005, calls to primitive subprograms of a tagged type that
have a “prefixed view” (see RM 4.1.3(9.2)) have been allowed to be
written using the form of a selected_component, with the first actual
parameter given as the prefix and the name of the subprogram as a
selector. This prefixed-view notation for calls is extended so as to
also allow such syntax for calls to primitive subprograms of untagged
types. The primitives of an untagged type T that have a prefixed view
are those where the first formal parameter of the subprogram either
is of type T or is an anonymous access parameter whose designated type
is T. For a type that has a component that happens to have the same
simple name as one of the type’s primitive subprograms, where the
component is visible at the point of a selected_component using that
name, preference is given to the component in a selected_component
(as is currently the case for tagged types with such component names).</p>
</li>
</ul>
</div>
<div class="section" id="pragma-extensions-visible">
<span id="id12"></span><h2><span class="section-number">2.63. </span>Pragma Extensions_Visible<a class="headerlink" href="#pragma-extensions-visible" title="Permalink to this headline">¶</a></h2>
<p>Syntax:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma</span><span class="p"> </span><span class="n">Extensions_Visible</span> [ <span class="o">(</span><span class="n">boolean_EXPRESSION</span><span class="o">)</span> ]<span class="p">;</span>
</pre></div>
</div>
<p>For the semantics of this pragma, see the entry for aspect <code class="docutils literal notranslate"><span class="pre">Extensions_Visible</span></code>
in the SPARK 2014 Reference Manual, section 6.1.7.</p>
</div>
<div class="section" id="pragma-external">
<h2><span class="section-number">2.64. </span>Pragma External<a class="headerlink" href="#pragma-external" title="Permalink to this headline">¶</a></h2>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pragma</span> <span class="n">External</span> <span class="p">(</span>
  <span class="p">[</span>   <span class="n">Convention</span>    <span class="o">=&gt;</span><span class="p">]</span> <span class="n">convention_IDENTIFIER</span><span class="p">,</span>
  <span class="p">[</span>   <span class="n">Entity</span>        <span class="o">=&gt;</span><span class="p">]</span> <span class="n">LOCAL_NAME</span>
  <span class="p">[,</span> <span class="p">[</span><span class="n">External_Name</span> <span class="o">=&gt;</span><span class="p">]</span> <span class="n">static_string_EXPRESSION</span> <span class="p">]</span>
  <span class="p">[,</span> <span class="p">[</span><span class="n">Link_Name</span>     <span class="o">=&gt;</span><span class="p">]</span> <span class="n">static_string_EXPRESSION</span> <span class="p">]);</span>
</pre></div>
</div>
<p>This pragma is identical in syntax and semantics to pragma
<code class="docutils literal notranslate"><span class="pre">Export</span></code> as defined in the Ada Reference Manual.  It is
provided for compatibility with some Ada 83 compilers that
used this pragma for exactly the same purposes as pragma
<code class="docutils literal notranslate"><span class="pre">Export</span></code> before the latter was standardized.</p>
</div>
<div class="section" id="pragma-external-name-casing">
<h2><span class="section-number">2.65. </span>Pragma External_Name_Casing<a class="headerlink" href="#pragma-external-name-casing" title="Permalink to this headline">¶</a></h2>
<span class="target" id="index-40"></span><span class="target" id="index-41"></span><p id="index-42">Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pragma</span> <span class="n">External_Name_Casing</span> <span class="p">(</span>
  <span class="n">Uppercase</span> <span class="o">|</span> <span class="n">Lowercase</span>
  <span class="p">[,</span> <span class="n">Uppercase</span> <span class="o">|</span> <span class="n">Lowercase</span> <span class="o">|</span> <span class="n">As_Is</span><span class="p">]);</span>
</pre></div>
</div>
<p>This pragma provides control over the casing of external names associated
with Import and Export pragmas.  There are two cases to consider:</p>
<ul>
<li><p>Implicit external names</p>
<p>Implicit external names are derived from identifiers.  The most common case
arises when a standard Ada Import or Export pragma is used with only two
arguments, as in:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma</span><span class="p"> </span><span class="n">Import</span> <span class="o">(</span><span class="n">C</span><span class="p">,</span> <span class="n">C_Routine</span><span class="o">)</span><span class="p">;</span>
</pre></div>
</div>
<p>Since Ada is a case-insensitive language, the spelling of the identifier in
the Ada source program does not provide any information on the desired
casing of the external name, and so a convention is needed.  In GNAT the
default treatment is that such names are converted to all lower case
letters.  This corresponds to the normal C style in many environments.
The first argument of pragma <code class="docutils literal notranslate"><span class="pre">External_Name_Casing</span></code> can be used to
control this treatment.  If <code class="docutils literal notranslate"><span class="pre">Uppercase</span></code> is specified, then the name
will be forced to all uppercase letters.  If <code class="docutils literal notranslate"><span class="pre">Lowercase</span></code> is specified,
then the normal default of all lower case letters will be used.</p>
<p>This same implicit treatment is also used in the case of extended DEC Ada 83
compatible Import and Export pragmas where an external name is explicitly
specified using an identifier rather than a string.</p>
</li>
<li><p>Explicit external names</p>
<p>Explicit external names are given as string literals.  The most common case
arises when a standard Ada Import or Export pragma is used with three
arguments, as in:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma</span><span class="p"> </span><span class="n">Import</span> <span class="o">(</span><span class="n">C</span><span class="p">,</span> <span class="n">C_Routine</span><span class="p">,</span> <span class="s">&quot;C_routine&quot;</span><span class="o">)</span><span class="p">;</span>
</pre></div>
</div>
<p>In this case, the string literal normally provides the exact casing required
for the external name.  The second argument of pragma
<code class="docutils literal notranslate"><span class="pre">External_Name_Casing</span></code> may be used to modify this behavior.
If <code class="docutils literal notranslate"><span class="pre">Uppercase</span></code> is specified, then the name
will be forced to all uppercase letters.  If <code class="docutils literal notranslate"><span class="pre">Lowercase</span></code> is specified,
then the name will be forced to all lowercase letters.  A specification of
<code class="docutils literal notranslate"><span class="pre">As_Is</span></code> provides the normal default behavior in which the casing is
taken from the string provided.</p>
</li>
</ul>
<p>This pragma may appear anywhere that a pragma is valid. In particular, it
can be used as a configuration pragma in the <code class="file docutils literal notranslate"><span class="pre">gnat.adc</span></code> file, in which
case it applies to all subsequent compilations, or it can be used as a program
unit pragma, in which case it only applies to the current unit, or it can
be used more locally to control individual Import/Export pragmas.</p>
<p>It was primarily intended for use with OpenVMS systems, where many
compilers convert all symbols to upper case by default.  For interfacing to
such compilers (e.g., the DEC C compiler), it may be convenient to use
the pragma:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma</span><span class="p"> </span><span class="n">External_Name_Casing</span> <span class="o">(</span><span class="n">Uppercase</span><span class="p">,</span> <span class="n">Uppercase</span><span class="o">)</span><span class="p">;</span>
</pre></div>
</div>
<p>to enforce the upper casing of all external symbols.</p>
</div>
<div class="section" id="pragma-fast-math">
<h2><span class="section-number">2.66. </span>Pragma Fast_Math<a class="headerlink" href="#pragma-fast-math" title="Permalink to this headline">¶</a></h2>
<p>Syntax:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma</span><span class="p"> </span><span class="n">Fast_Math</span><span class="p">;</span>
</pre></div>
</div>
<p>This is a configuration pragma which activates a mode in which speed is
considered more important for floating-point operations than absolutely
accurate adherence to the requirements of the standard. Currently the
following operations are affected:</p>
<dl class="simple">
<dt><em>Complex Multiplication</em></dt><dd><p>The normal simple formula for complex multiplication can result in intermediate
overflows for numbers near the end of the range. The Ada standard requires that
this situation be detected and corrected by scaling, but in Fast_Math mode such
cases will simply result in overflow. Note that to take advantage of this you
must instantiate your own version of <code class="docutils literal notranslate"><span class="pre">Ada.Numerics.Generic_Complex_Types</span></code>
under control of the pragma, rather than use the preinstantiated versions.</p>
</dd>
</dl>
</div>
<div class="section" id="pragma-favor-top-level">
<span id="id13"></span><h2><span class="section-number">2.67. </span>Pragma Favor_Top_Level<a class="headerlink" href="#pragma-favor-top-level" title="Permalink to this headline">¶</a></h2>
<p>Syntax:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma</span><span class="p"> </span><span class="n">Favor_Top_Level</span> <span class="o">(</span><span class="n">type_NAME</span><span class="o">)</span><span class="p">;</span>
</pre></div>
</div>
<p>The argument of pragma <code class="docutils literal notranslate"><span class="pre">Favor_Top_Level</span></code> must be a named access-to-subprogram
type. This pragma is an efficiency hint to the compiler, regarding the use of
<code class="docutils literal notranslate"><span class="pre">'Access</span></code> or <code class="docutils literal notranslate"><span class="pre">'Unrestricted_Access</span></code> on nested (non-library-level) subprograms.
The pragma means that nested subprograms are not used with this type, or are
rare, so that the generated code should be efficient in the top-level case.
When this pragma is used, dynamically generated trampolines may be used on some
targets for nested subprograms. See restriction <code class="docutils literal notranslate"><span class="pre">No_Implicit_Dynamic_Code</span></code>.</p>
</div>
<div class="section" id="pragma-finalize-storage-only">
<h2><span class="section-number">2.68. </span>Pragma Finalize_Storage_Only<a class="headerlink" href="#pragma-finalize-storage-only" title="Permalink to this headline">¶</a></h2>
<p>Syntax:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma</span><span class="p"> </span><span class="n">Finalize_Storage_Only</span> <span class="o">(</span><span class="n">first_subtype_LOCAL_NAME</span><span class="o">)</span><span class="p">;</span>
</pre></div>
</div>
<p>The argument of pragma <code class="docutils literal notranslate"><span class="pre">Finalize_Storage_Only</span></code> must denote a local type which
is derived from <code class="docutils literal notranslate"><span class="pre">Ada.Finalization.Controlled</span></code> or <code class="docutils literal notranslate"><span class="pre">Limited_Controlled</span></code>. The
pragma suppresses the call to <code class="docutils literal notranslate"><span class="pre">Finalize</span></code> for declared library-level objects
of the argument type. This is mostly useful for types where finalization is
only used to deal with storage reclamation since in most environments it is
not necessary to reclaim memory just before terminating execution, hence the
name. Note that this pragma does not suppress Finalize calls for library-level
heap-allocated objects (see pragma <code class="docutils literal notranslate"><span class="pre">No_Heap_Finalization</span></code>).</p>
</div>
<div class="section" id="pragma-float-representation">
<h2><span class="section-number">2.69. </span>Pragma Float_Representation<a class="headerlink" href="#pragma-float-representation" title="Permalink to this headline">¶</a></h2>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pragma</span> <span class="n">Float_Representation</span> <span class="p">(</span><span class="n">FLOAT_REP</span><span class="p">[,</span> <span class="n">float_type_LOCAL_NAME</span><span class="p">]);</span>

<span class="n">FLOAT_REP</span> <span class="p">:</span><span class="o">:=</span> <span class="n">VAX_Float</span> <span class="o">|</span> <span class="n">IEEE_Float</span>
</pre></div>
</div>
<p>In the one argument form, this pragma is a configuration pragma which
allows control over the internal representation chosen for the predefined
floating point types declared in the packages <code class="docutils literal notranslate"><span class="pre">Standard</span></code> and
<code class="docutils literal notranslate"><span class="pre">System</span></code>. This pragma is only provided for compatibility and has no effect.</p>
<p>The two argument form specifies the representation to be used for
the specified floating-point type. The argument must
be <code class="docutils literal notranslate"><span class="pre">IEEE_Float</span></code> to specify the use of IEEE format, as follows:</p>
<ul class="simple">
<li><p>For a digits value of 6, 32-bit IEEE short format will be used.</p></li>
<li><p>For a digits value of 15, 64-bit IEEE long format will be used.</p></li>
<li><p>No other value of digits is permitted.</p></li>
</ul>
</div>
<div class="section" id="pragma-ghost">
<span id="id14"></span><h2><span class="section-number">2.70. </span>Pragma Ghost<a class="headerlink" href="#pragma-ghost" title="Permalink to this headline">¶</a></h2>
<p>Syntax:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma</span><span class="p"> </span><span class="n">Ghost</span> [ <span class="o">(</span><span class="n">boolean_EXPRESSION</span><span class="o">)</span> ]<span class="p">;</span>
</pre></div>
</div>
<p>For the semantics of this pragma, see the entry for aspect <code class="docutils literal notranslate"><span class="pre">Ghost</span></code> in the SPARK
2014 Reference Manual, section 6.9.</p>
</div>
<div class="section" id="pragma-global">
<span id="id15"></span><h2><span class="section-number">2.71. </span>Pragma Global<a class="headerlink" href="#pragma-global" title="Permalink to this headline">¶</a></h2>
<p>Syntax:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma</span><span class="p"> </span><span class="n">Global</span> <span class="o">(</span><span class="n">GLOBAL_SPECIFICATION</span><span class="o">)</span><span class="p">;</span>

<span class="n">GLOBAL_SPECIFICATION</span> <span class="o">::=</span>
     <span class="kr">null</span><span class="p"></span>
  <span class="o">|</span> <span class="o">(</span><span class="n">GLOBAL_LIST</span><span class="o">)</span>
  <span class="o">|</span> <span class="o">(</span><span class="n">MODED_GLOBAL_LIST</span> {<span class="p">,</span> <span class="n">MODED_GLOBAL_LIST</span>}<span class="o">)</span>

<span class="n">MODED_GLOBAL_LIST</span> <span class="o">::=</span> <span class="n">MODE_SELECTOR</span> <span class="o">=&gt;</span> <span class="n">GLOBAL_LIST</span>

<span class="n">MODE_SELECTOR</span> <span class="o">::=</span> <span class="n">In_Out</span> <span class="o">|</span> <span class="n">Input</span> <span class="o">|</span> <span class="n">Output</span> <span class="o">|</span> <span class="n">Proof_In</span>
<span class="n">GLOBAL_LIST</span>   <span class="o">::=</span> <span class="n">GLOBAL_ITEM</span> <span class="o">|</span> <span class="o">(</span><span class="n">GLOBAL_ITEM</span> {<span class="p">,</span> <span class="n">GLOBAL_ITEM</span>}<span class="o">)</span>
<span class="n">GLOBAL_ITEM</span>   <span class="o">::=</span> <span class="n">NAME</span>
</pre></div>
</div>
<p>For the semantics of this pragma, see the entry for aspect <code class="docutils literal notranslate"><span class="pre">Global</span></code> in the
SPARK 2014 Reference Manual, section 6.1.4.</p>
</div>
<div class="section" id="pragma-ident">
<h2><span class="section-number">2.72. </span>Pragma Ident<a class="headerlink" href="#pragma-ident" title="Permalink to this headline">¶</a></h2>
<p>Syntax:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma</span><span class="p"> </span><span class="n">Ident</span> <span class="o">(</span><span class="n">static_string_EXPRESSION</span><span class="o">)</span><span class="p">;</span>
</pre></div>
</div>
<p>This pragma is identical in effect to pragma <code class="docutils literal notranslate"><span class="pre">Comment</span></code>. It is provided
for compatibility with other Ada compilers providing this pragma.</p>
</div>
<div class="section" id="pragma-ignore-pragma">
<h2><span class="section-number">2.73. </span>Pragma Ignore_Pragma<a class="headerlink" href="#pragma-ignore-pragma" title="Permalink to this headline">¶</a></h2>
<p>Syntax:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma</span><span class="p"> </span><span class="n">Ignore_Pragma</span> <span class="o">(</span><span class="n">pragma_IDENTIFIER</span><span class="o">)</span><span class="p">;</span>
</pre></div>
</div>
<p>This is a configuration pragma
that takes a single argument that is a simple identifier. Any subsequent
use of a pragma whose pragma identifier matches this argument will be
silently ignored. This may be useful when legacy code or code intended
for compilation with some other compiler contains pragmas that match the
name, but not the exact implementation, of a GNAT pragma. The use of this
pragma allows such pragmas to be ignored, which may be useful in CodePeer
mode, or during porting of legacy code.</p>
</div>
<div class="section" id="pragma-implementation-defined">
<h2><span class="section-number">2.74. </span>Pragma Implementation_Defined<a class="headerlink" href="#pragma-implementation-defined" title="Permalink to this headline">¶</a></h2>
<p>Syntax:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma</span><span class="p"> </span><span class="n">Implementation_Defined</span> <span class="o">(</span><span class="n">local_NAME</span><span class="o">)</span><span class="p">;</span>
</pre></div>
</div>
<p>This pragma marks a previously declared entity as implementation-defined.
For an overloaded entity, applies to the most recent homonym.</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma</span><span class="p"> </span><span class="n">Implementation_Defined</span><span class="p">;</span>
</pre></div>
</div>
<p>The form with no arguments appears anywhere within a scope, most
typically a package spec, and indicates that all entities that are
defined within the package spec are Implementation_Defined.</p>
<p>This pragma is used within the GNAT runtime library to identify
implementation-defined entities introduced in language-defined units,
for the purpose of implementing the No_Implementation_Identifiers
restriction.</p>
</div>
<div class="section" id="pragma-implemented">
<h2><span class="section-number">2.75. </span>Pragma Implemented<a class="headerlink" href="#pragma-implemented" title="Permalink to this headline">¶</a></h2>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pragma</span> <span class="n">Implemented</span> <span class="p">(</span><span class="n">procedure_LOCAL_NAME</span><span class="p">,</span> <span class="n">implementation_kind</span><span class="p">);</span>

<span class="n">implementation_kind</span> <span class="p">:</span><span class="o">:=</span> <span class="n">By_Entry</span> <span class="o">|</span> <span class="n">By_Protected_Procedure</span> <span class="o">|</span> <span class="n">By_Any</span>
</pre></div>
</div>
<p>This is an Ada 2012 representation pragma which applies to protected, task
and synchronized interface primitives. The use of pragma Implemented provides
a way to impose a static requirement on the overriding operation by adhering
to one of the three implementation kinds: entry, protected procedure or any of
the above. This pragma is available in all earlier versions of Ada as an
implementation-defined pragma.</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">type</span><span class="p"> </span><span class="n">Synch_Iface</span> <span class="kr">is</span><span class="p"> </span><span class="kr">synchronized</span><span class="p"> </span><span class="kr">interface</span><span class="p">;</span>
<span class="k">procedure </span><span class="nf">Prim_Op</span> <span class="o">(</span><span class="n">Obj</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="kr">out</span><span class="p"> </span><span class="n">Iface</span><span class="o">)</span> <span class="kr">is</span><span class="p"> </span><span class="kr">abstract</span><span class="p">;</span>
<span class="kr">pragma</span><span class="p"> </span><span class="n">Implemented</span> <span class="o">(</span><span class="n">Prim_Op</span><span class="p">,</span> <span class="n">By_Protected_Procedure</span><span class="o">)</span><span class="p">;</span>

<span class="kr">protected</span><span class="p"> </span><span class="kr">type</span><span class="p"> </span><span class="n">Prot_1</span> <span class="kr">is</span><span class="p"> </span><span class="kr">new</span><span class="p"> </span><span class="n">Synch_Iface</span> <span class="kr">with</span><span class="p"></span>
   <span class="k">procedure </span><span class="nf">Prim_Op</span><span class="p">;</span>  <span class="c">--  Legal</span>
<span class="k">end </span><span class="nf">Prot_1</span><span class="p">;</span>

<span class="kr">protected</span><span class="p"> </span><span class="kr">type</span><span class="p"> </span><span class="n">Prot_2</span> <span class="kr">is</span><span class="p"> </span><span class="kr">new</span><span class="p"> </span><span class="n">Synch_Iface</span> <span class="kr">with</span><span class="p"></span>
   <span class="kr">entry</span><span class="p"> </span><span class="n">Prim_Op</span><span class="p">;</span>      <span class="c">--  Illegal</span>
<span class="k">end </span><span class="nf">Prot_2</span><span class="p">;</span>

<span class="kr">task</span><span class="p"> </span><span class="kr">type</span><span class="p"> </span><span class="n">Task_Typ</span> <span class="kr">is</span><span class="p"> </span><span class="kr">new</span><span class="p"> </span><span class="n">Synch_Iface</span> <span class="kr">with</span><span class="p"></span>
   <span class="kr">entry</span><span class="p"> </span><span class="n">Prim_Op</span><span class="p">;</span>      <span class="c">--  Illegal</span>
<span class="k">end </span><span class="nf">Task_Typ</span><span class="p">;</span>
</pre></div>
</div>
<p>When applied to the procedure_or_entry_NAME of a requeue statement, pragma
Implemented determines the runtime behavior of the requeue. Implementation kind
By_Entry guarantees that the action of requeueing will proceed from an entry to
another entry. Implementation kind By_Protected_Procedure transforms the
requeue into a dispatching call, thus eliminating the chance of blocking. Kind
By_Any shares the behavior of By_Entry and By_Protected_Procedure depending on
the target’s overriding subprogram kind.</p>
</div>
<div class="section" id="pragma-implicit-packing">
<h2><span class="section-number">2.76. </span>Pragma Implicit_Packing<a class="headerlink" href="#pragma-implicit-packing" title="Permalink to this headline">¶</a></h2>
<p id="index-43">Syntax:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma</span><span class="p"> </span><span class="n">Implicit_Packing</span><span class="p">;</span>
</pre></div>
</div>
<p>This is a configuration pragma that requests implicit packing for packed
arrays for which a size clause is given but no explicit pragma Pack or
specification of Component_Size is present. It also applies to records
where no record representation clause is present. Consider this example:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">type</span><span class="p"> </span><span class="n">R</span> <span class="kr">is</span><span class="p"> </span><span class="kr">array</span><span class="p"> </span><span class="o">(</span><span class="mi">0</span> <span class="o">..</span> <span class="mi">7</span><span class="o">)</span> <span class="kr">of</span><span class="p"> </span><span class="n">Boolean</span><span class="p">;</span>
<span class="kr">for</span><span class="p"> </span><span class="n">R</span><span class="na">&#39;Size</span> <span class="kr">use</span><span class="p"> </span><span class="mi">8</span><span class="p">;</span>
</pre></div>
</div>
<p>In accordance with the recommendation in the RM (RM 13.3(53)), a Size clause
does not change the layout of a composite object. So the Size clause in the
above example is normally rejected, since the default layout of the array uses
8-bit components, and thus the array requires a minimum of 64 bits.</p>
<p>If this declaration is compiled in a region of code covered by an occurrence
of the configuration pragma Implicit_Packing, then the Size clause in this
and similar examples will cause implicit packing and thus be accepted. For
this implicit packing to occur, the type in question must be an array of small
components whose size is known at compile time, and the Size clause must
specify the exact size that corresponds to the number of elements in the array
multiplied by the size in bits of the component type (both single and
multi-dimensioned arrays can be controlled with this pragma).</p>
<p id="index-44">Similarly, the following example shows the use in the record case</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">type</span><span class="p"> </span><span class="n">r</span> <span class="kr">is</span><span class="p"> </span><span class="kr">record</span><span class="p"></span>
   <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">h</span> <span class="o">:</span> <span class="n">boolean</span><span class="p">;</span>
   <span class="n">chr</span>                    <span class="o">:</span> <span class="n">character</span><span class="p">;</span>
<span class="k">end record</span><span class="p">;</span>
<span class="kr">for</span><span class="p"> </span><span class="n">r</span><span class="na">&#39;size</span> <span class="kr">use</span><span class="p"> </span><span class="mi">16</span><span class="p">;</span>
</pre></div>
</div>
<p>Without a pragma Pack, each Boolean field requires 8 bits, so the
minimum size is 72 bits, but with a pragma Pack, 16 bits would be
sufficient. The use of pragma Implicit_Packing allows this record
declaration to compile without an explicit pragma Pack.</p>
</div>
<div class="section" id="pragma-import-function">
<h2><span class="section-number">2.77. </span>Pragma Import_Function<a class="headerlink" href="#pragma-import-function" title="Permalink to this headline">¶</a></h2>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pragma</span> <span class="n">Import_Function</span> <span class="p">(</span>
     <span class="p">[</span><span class="n">Internal</span>                 <span class="o">=&gt;</span><span class="p">]</span> <span class="n">LOCAL_NAME</span><span class="p">,</span>
  <span class="p">[,</span> <span class="p">[</span><span class="n">External</span>                 <span class="o">=&gt;</span><span class="p">]</span> <span class="n">EXTERNAL_SYMBOL</span><span class="p">]</span>
  <span class="p">[,</span> <span class="p">[</span><span class="n">Parameter_Types</span>          <span class="o">=&gt;</span><span class="p">]</span> <span class="n">PARAMETER_TYPES</span><span class="p">]</span>
  <span class="p">[,</span> <span class="p">[</span><span class="n">Result_Type</span>              <span class="o">=&gt;</span><span class="p">]</span> <span class="n">SUBTYPE_MARK</span><span class="p">]</span>
  <span class="p">[,</span> <span class="p">[</span><span class="n">Mechanism</span>                <span class="o">=&gt;</span><span class="p">]</span> <span class="n">MECHANISM</span><span class="p">]</span>
  <span class="p">[,</span> <span class="p">[</span><span class="n">Result_Mechanism</span>         <span class="o">=&gt;</span><span class="p">]</span> <span class="n">MECHANISM_NAME</span><span class="p">]);</span>

<span class="n">EXTERNAL_SYMBOL</span> <span class="p">:</span><span class="o">:=</span>
  <span class="n">IDENTIFIER</span>
<span class="o">|</span> <span class="n">static_string_EXPRESSION</span>

<span class="n">PARAMETER_TYPES</span> <span class="p">:</span><span class="o">:=</span>
  <span class="n">null</span>
<span class="o">|</span> <span class="n">TYPE_DESIGNATOR</span> <span class="p">{,</span> <span class="n">TYPE_DESIGNATOR</span><span class="p">}</span>

<span class="n">TYPE_DESIGNATOR</span> <span class="p">:</span><span class="o">:=</span>
  <span class="n">subtype_NAME</span>
<span class="o">|</span> <span class="n">subtype_Name</span> <span class="s1">&#39; Access</span>

<span class="n">MECHANISM</span> <span class="p">:</span><span class="o">:=</span>
  <span class="n">MECHANISM_NAME</span>
<span class="o">|</span> <span class="p">(</span><span class="n">MECHANISM_ASSOCIATION</span> <span class="p">{,</span> <span class="n">MECHANISM_ASSOCIATION</span><span class="p">})</span>

<span class="n">MECHANISM_ASSOCIATION</span> <span class="p">:</span><span class="o">:=</span>
  <span class="p">[</span><span class="n">formal_parameter_NAME</span> <span class="o">=&gt;</span><span class="p">]</span> <span class="n">MECHANISM_NAME</span>

<span class="n">MECHANISM_NAME</span> <span class="p">:</span><span class="o">:=</span>
  <span class="n">Value</span>
<span class="o">|</span> <span class="n">Reference</span>
</pre></div>
</div>
<p>This pragma is used in conjunction with a pragma <code class="docutils literal notranslate"><span class="pre">Import</span></code> to
specify additional information for an imported function.  The pragma
<code class="docutils literal notranslate"><span class="pre">Import</span></code> (or equivalent pragma <code class="docutils literal notranslate"><span class="pre">Interface</span></code>) must precede the
<code class="docutils literal notranslate"><span class="pre">Import_Function</span></code> pragma and both must appear in the same
declarative part as the function specification.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">Internal</span></code> argument must uniquely designate
the function to which the
pragma applies.  If more than one function name exists of this name in
the declarative part you must use the <code class="docutils literal notranslate"><span class="pre">Parameter_Types</span></code> and
<code class="docutils literal notranslate"><span class="pre">Result_Type</span></code> parameters to achieve the required unique
designation.  Subtype marks in these parameters must exactly match the
subtypes in the corresponding function specification, using positional
notation to match parameters with subtype marks.
The form with an <code class="docutils literal notranslate"><span class="pre">'Access</span></code> attribute can be used to match an
anonymous access parameter.</p>
<p>You may optionally use the <code class="docutils literal notranslate"><span class="pre">Mechanism</span></code> and <code class="docutils literal notranslate"><span class="pre">Result_Mechanism</span></code>
parameters to specify passing mechanisms for the
parameters and result.  If you specify a single mechanism name, it
applies to all parameters.  Otherwise you may specify a mechanism on a
parameter by parameter basis using either positional or named
notation.  If the mechanism is not specified, the default mechanism
is used.</p>
</div>
<div class="section" id="pragma-import-object">
<h2><span class="section-number">2.78. </span>Pragma Import_Object<a class="headerlink" href="#pragma-import-object" title="Permalink to this headline">¶</a></h2>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pragma</span> <span class="n">Import_Object</span>
     <span class="p">[</span><span class="n">Internal</span> <span class="o">=&gt;</span><span class="p">]</span> <span class="n">LOCAL_NAME</span>
  <span class="p">[,</span> <span class="p">[</span><span class="n">External</span> <span class="o">=&gt;</span><span class="p">]</span> <span class="n">EXTERNAL_SYMBOL</span><span class="p">]</span>
  <span class="p">[,</span> <span class="p">[</span><span class="n">Size</span>     <span class="o">=&gt;</span><span class="p">]</span> <span class="n">EXTERNAL_SYMBOL</span><span class="p">]);</span>

<span class="n">EXTERNAL_SYMBOL</span> <span class="p">:</span><span class="o">:=</span>
  <span class="n">IDENTIFIER</span>
<span class="o">|</span> <span class="n">static_string_EXPRESSION</span>
</pre></div>
</div>
<p>This pragma designates an object as imported, and apart from the
extended rules for external symbols, is identical in effect to the use of
the normal <code class="docutils literal notranslate"><span class="pre">Import</span></code> pragma applied to an object.  Unlike the
subprogram case, you need not use a separate <code class="docutils literal notranslate"><span class="pre">Import</span></code> pragma,
although you may do so (and probably should do so from a portability
point of view).  <code class="docutils literal notranslate"><span class="pre">size</span></code> is syntax checked, but otherwise ignored by
GNAT.</p>
</div>
<div class="section" id="pragma-import-procedure">
<h2><span class="section-number">2.79. </span>Pragma Import_Procedure<a class="headerlink" href="#pragma-import-procedure" title="Permalink to this headline">¶</a></h2>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pragma</span> <span class="n">Import_Procedure</span> <span class="p">(</span>
     <span class="p">[</span><span class="n">Internal</span>                 <span class="o">=&gt;</span><span class="p">]</span> <span class="n">LOCAL_NAME</span>
  <span class="p">[,</span> <span class="p">[</span><span class="n">External</span>                 <span class="o">=&gt;</span><span class="p">]</span> <span class="n">EXTERNAL_SYMBOL</span><span class="p">]</span>
  <span class="p">[,</span> <span class="p">[</span><span class="n">Parameter_Types</span>          <span class="o">=&gt;</span><span class="p">]</span> <span class="n">PARAMETER_TYPES</span><span class="p">]</span>
  <span class="p">[,</span> <span class="p">[</span><span class="n">Mechanism</span>                <span class="o">=&gt;</span><span class="p">]</span> <span class="n">MECHANISM</span><span class="p">]);</span>

<span class="n">EXTERNAL_SYMBOL</span> <span class="p">:</span><span class="o">:=</span>
  <span class="n">IDENTIFIER</span>
<span class="o">|</span> <span class="n">static_string_EXPRESSION</span>

<span class="n">PARAMETER_TYPES</span> <span class="p">:</span><span class="o">:=</span>
  <span class="n">null</span>
<span class="o">|</span> <span class="n">TYPE_DESIGNATOR</span> <span class="p">{,</span> <span class="n">TYPE_DESIGNATOR</span><span class="p">}</span>

<span class="n">TYPE_DESIGNATOR</span> <span class="p">:</span><span class="o">:=</span>
  <span class="n">subtype_NAME</span>
<span class="o">|</span> <span class="n">subtype_Name</span> <span class="s1">&#39; Access</span>

<span class="n">MECHANISM</span> <span class="p">:</span><span class="o">:=</span>
  <span class="n">MECHANISM_NAME</span>
<span class="o">|</span> <span class="p">(</span><span class="n">MECHANISM_ASSOCIATION</span> <span class="p">{,</span> <span class="n">MECHANISM_ASSOCIATION</span><span class="p">})</span>

<span class="n">MECHANISM_ASSOCIATION</span> <span class="p">:</span><span class="o">:=</span>
  <span class="p">[</span><span class="n">formal_parameter_NAME</span> <span class="o">=&gt;</span><span class="p">]</span> <span class="n">MECHANISM_NAME</span>

<span class="n">MECHANISM_NAME</span> <span class="p">:</span><span class="o">:=</span> <span class="n">Value</span> <span class="o">|</span> <span class="n">Reference</span>
</pre></div>
</div>
<p>This pragma is identical to <code class="docutils literal notranslate"><span class="pre">Import_Function</span></code> except that it
applies to a procedure rather than a function and the parameters
<code class="docutils literal notranslate"><span class="pre">Result_Type</span></code> and <code class="docutils literal notranslate"><span class="pre">Result_Mechanism</span></code> are not permitted.</p>
</div>
<div class="section" id="pragma-import-valued-procedure">
<h2><span class="section-number">2.80. </span>Pragma Import_Valued_Procedure<a class="headerlink" href="#pragma-import-valued-procedure" title="Permalink to this headline">¶</a></h2>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pragma</span> <span class="n">Import_Valued_Procedure</span> <span class="p">(</span>
     <span class="p">[</span><span class="n">Internal</span>                 <span class="o">=&gt;</span><span class="p">]</span> <span class="n">LOCAL_NAME</span>
  <span class="p">[,</span> <span class="p">[</span><span class="n">External</span>                 <span class="o">=&gt;</span><span class="p">]</span> <span class="n">EXTERNAL_SYMBOL</span><span class="p">]</span>
  <span class="p">[,</span> <span class="p">[</span><span class="n">Parameter_Types</span>          <span class="o">=&gt;</span><span class="p">]</span> <span class="n">PARAMETER_TYPES</span><span class="p">]</span>
  <span class="p">[,</span> <span class="p">[</span><span class="n">Mechanism</span>                <span class="o">=&gt;</span><span class="p">]</span> <span class="n">MECHANISM</span><span class="p">]);</span>

<span class="n">EXTERNAL_SYMBOL</span> <span class="p">:</span><span class="o">:=</span>
  <span class="n">IDENTIFIER</span>
<span class="o">|</span> <span class="n">static_string_EXPRESSION</span>

<span class="n">PARAMETER_TYPES</span> <span class="p">:</span><span class="o">:=</span>
  <span class="n">null</span>
<span class="o">|</span> <span class="n">TYPE_DESIGNATOR</span> <span class="p">{,</span> <span class="n">TYPE_DESIGNATOR</span><span class="p">}</span>

<span class="n">TYPE_DESIGNATOR</span> <span class="p">:</span><span class="o">:=</span>
  <span class="n">subtype_NAME</span>
<span class="o">|</span> <span class="n">subtype_Name</span> <span class="s1">&#39; Access</span>

<span class="n">MECHANISM</span> <span class="p">:</span><span class="o">:=</span>
  <span class="n">MECHANISM_NAME</span>
<span class="o">|</span> <span class="p">(</span><span class="n">MECHANISM_ASSOCIATION</span> <span class="p">{,</span> <span class="n">MECHANISM_ASSOCIATION</span><span class="p">})</span>

<span class="n">MECHANISM_ASSOCIATION</span> <span class="p">:</span><span class="o">:=</span>
  <span class="p">[</span><span class="n">formal_parameter_NAME</span> <span class="o">=&gt;</span><span class="p">]</span> <span class="n">MECHANISM_NAME</span>

<span class="n">MECHANISM_NAME</span> <span class="p">:</span><span class="o">:=</span> <span class="n">Value</span> <span class="o">|</span> <span class="n">Reference</span>
</pre></div>
</div>
<p>This pragma is identical to <code class="docutils literal notranslate"><span class="pre">Import_Procedure</span></code> except that the
first parameter of <code class="docutils literal notranslate"><span class="pre">LOCAL_NAME</span></code>, which must be present, must be of
mode <code class="docutils literal notranslate"><span class="pre">out</span></code>, and externally the subprogram is treated as a function
with this parameter as the result of the function.  The purpose of this
capability is to allow the use of <code class="docutils literal notranslate"><span class="pre">out</span></code> and <code class="docutils literal notranslate"><span class="pre">in</span> <span class="pre">out</span></code>
parameters in interfacing to external functions (which are not permitted
in Ada functions).  You may optionally use the <code class="docutils literal notranslate"><span class="pre">Mechanism</span></code>
parameters to specify passing mechanisms for the parameters.
If you specify a single mechanism name, it applies to all parameters.
Otherwise you may specify a mechanism on a parameter by parameter
basis using either positional or named notation.  If the mechanism is not
specified, the default mechanism is used.</p>
<p>Note that it is important to use this pragma in conjunction with a separate
pragma Import that specifies the desired convention, since otherwise the
default convention is Ada, which is almost certainly not what is required.</p>
</div>
<div class="section" id="pragma-independent">
<h2><span class="section-number">2.81. </span>Pragma Independent<a class="headerlink" href="#pragma-independent" title="Permalink to this headline">¶</a></h2>
<p>Syntax:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma</span><span class="p"> </span><span class="n">Independent</span> <span class="o">(</span><span class="n">Local_NAME</span><span class="o">)</span><span class="p">;</span>
</pre></div>
</div>
<p>This pragma is standard in Ada 2012 mode (which also provides an aspect
of the same name). It is also available as an implementation-defined
pragma in all earlier versions. It specifies that the
designated object or all objects of the designated type must be
independently addressable. This means that separate tasks can safely
manipulate such objects. For example, if two components of a record are
independent, then two separate tasks may access these two components.
This may place
constraints on the representation of the object (for instance prohibiting
tight packing).</p>
</div>
<div class="section" id="pragma-independent-components">
<h2><span class="section-number">2.82. </span>Pragma Independent_Components<a class="headerlink" href="#pragma-independent-components" title="Permalink to this headline">¶</a></h2>
<p>Syntax:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma</span><span class="p"> </span><span class="n">Independent_Components</span> <span class="o">(</span><span class="n">Local_NAME</span><span class="o">)</span><span class="p">;</span>
</pre></div>
</div>
<p>This pragma is standard in Ada 2012 mode (which also provides an aspect
of the same name). It is also available as an implementation-defined
pragma in all earlier versions. It specifies that the components of the
designated object, or the components of each object of the designated
type, must be
independently addressable. This means that separate tasks can safely
manipulate separate components in the composite object. This may place
constraints on the representation of the object (for instance prohibiting
tight packing).</p>
</div>
<div class="section" id="pragma-initial-condition">
<span id="id16"></span><h2><span class="section-number">2.83. </span>Pragma Initial_Condition<a class="headerlink" href="#pragma-initial-condition" title="Permalink to this headline">¶</a></h2>
<p>Syntax:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma</span><span class="p"> </span><span class="n">Initial_Condition</span> <span class="o">(</span><span class="n">boolean_EXPRESSION</span><span class="o">)</span><span class="p">;</span>
</pre></div>
</div>
<p>For the semantics of this pragma, see the entry for aspect <code class="docutils literal notranslate"><span class="pre">Initial_Condition</span></code>
in the SPARK 2014 Reference Manual, section 7.1.6.</p>
</div>
<div class="section" id="pragma-initialize-scalars">
<h2><span class="section-number">2.84. </span>Pragma Initialize_Scalars<a class="headerlink" href="#pragma-initialize-scalars" title="Permalink to this headline">¶</a></h2>
<p id="index-45">Syntax:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma</span><span class="p"> </span><span class="n">Initialize_Scalars</span>
  [ <span class="o">(</span> <span class="n">TYPE_VALUE_PAIR</span> {<span class="p">,</span> <span class="n">TYPE_VALUE_PAIR</span>} <span class="o">)</span> ]<span class="p">;</span>

<span class="n">TYPE_VALUE_PAIR</span> <span class="o">::=</span>
  <span class="n">SCALAR_TYPE</span> <span class="o">=&gt;</span> <span class="n">static_EXPRESSION</span>

<span class="n">SCALAR_TYPE</span> <span class="o">:=</span>
  <span class="n">Short_Float</span>
<span class="o">|</span> <span class="n">Float</span>
<span class="o">|</span> <span class="n">Long_Float</span>
<span class="o">|</span> <span class="n">Long_Long_Flat</span>
<span class="o">|</span> <span class="n">Signed_8</span>
<span class="o">|</span> <span class="n">Signed_16</span>
<span class="o">|</span> <span class="n">Signed_32</span>
<span class="o">|</span> <span class="n">Signed_64</span>
<span class="o">|</span> <span class="n">Unsigned_8</span>
<span class="o">|</span> <span class="n">Unsigned_16</span>
<span class="o">|</span> <span class="n">Unsigned_32</span>
<span class="o">|</span> <span class="n">Unsigned_64</span>
</pre></div>
</div>
<p>This pragma is similar to <code class="docutils literal notranslate"><span class="pre">Normalize_Scalars</span></code> conceptually but has two
important differences.</p>
<p>First, there is no requirement for the pragma to be used uniformly in all units
of a partition. In particular, it is fine to use this just for some or all of
the application units of a partition, without needing to recompile the run-time
library. In the case where some units are compiled with the pragma, and some
without, then a declaration of a variable where the type is defined in package
Standard or is locally declared will always be subject to initialization, as
will any declaration of a scalar variable. For composite variables, whether the
variable is initialized may also depend on whether the package in which the
type of the variable is declared is compiled with the pragma.</p>
<p>The other important difference is that the programmer can control the value
used for initializing scalar objects. This effect can be achieved in several
different ways:</p>
<ul>
<li><p>At compile time, the programmer can specify the invalid value for a
particular family of scalar types using the optional arguments of the pragma.</p>
<p>The compile-time approach is intended to optimize the generated code for the
pragma, by possibly using fast operations such as <code class="docutils literal notranslate"><span class="pre">memset</span></code>. Note that such
optimizations require using values where the bytes all have the same binary
representation.</p>
</li>
<li><p>At bind time, the programmer has several options:</p>
<ul class="simple">
<li><p>Initialization with invalid values (similar to Normalize_Scalars, though
for Initialize_Scalars it is not always possible to determine the invalid
values in complex cases like signed component fields with nonstandard
sizes).</p></li>
<li><p>Initialization with high values.</p></li>
<li><p>Initialization with low values.</p></li>
<li><p>Initialization with a specific bit pattern.</p></li>
</ul>
<p>See the GNAT User’s Guide for binder options for specifying these cases.</p>
<p>The bind-time approach is intended to provide fast turnaround for testing
with different values, without having to recompile the program.</p>
</li>
<li><p>At execution time, the programmer can specify the invalid values using an
environment variable. See the GNAT User’s Guide for details.</p>
<p>The execution-time approach is intended to provide fast turnaround for
testing with different values, without having to recompile and rebind the
program.</p>
</li>
</ul>
<p>Note that pragma <code class="docutils literal notranslate"><span class="pre">Initialize_Scalars</span></code> is particularly useful in conjunction
with the enhanced validity checking that is now provided in GNAT, which checks
for invalid values under more conditions. Using this feature (see description
of the <em>-gnatV</em> flag in the GNAT User’s Guide) in conjunction with pragma
<code class="docutils literal notranslate"><span class="pre">Initialize_Scalars</span></code> provides a powerful new tool to assist in the detection
of problems caused by uninitialized variables.</p>
<p>Note: the use of <code class="docutils literal notranslate"><span class="pre">Initialize_Scalars</span></code> has a fairly extensive effect on the
generated code. This may cause your code to be substantially larger. It may
also cause an increase in the amount of stack required, so it is probably a
good idea to turn on stack checking (see description of stack checking in the
GNAT User’s Guide) when using this pragma.</p>
</div>
<div class="section" id="pragma-initializes">
<span id="id17"></span><h2><span class="section-number">2.85. </span>Pragma Initializes<a class="headerlink" href="#pragma-initializes" title="Permalink to this headline">¶</a></h2>
<p>Syntax:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma</span><span class="p"> </span><span class="n">Initializes</span> <span class="o">(</span><span class="n">INITIALIZATION_LIST</span><span class="o">)</span><span class="p">;</span>

<span class="n">INITIALIZATION_LIST</span> <span class="o">::=</span>
     <span class="kr">null</span><span class="p"></span>
  <span class="o">|</span> <span class="o">(</span><span class="n">INITIALIZATION_ITEM</span> {<span class="p">,</span> <span class="n">INITIALIZATION_ITEM</span>}<span class="o">)</span>

<span class="n">INITIALIZATION_ITEM</span> <span class="o">::=</span> <span class="n">name</span> [<span class="o">=&gt;</span> <span class="n">INPUT_LIST</span>]

<span class="n">INPUT_LIST</span> <span class="o">::=</span>
     <span class="kr">null</span><span class="p"></span>
  <span class="o">|</span>  <span class="n">INPUT</span>
  <span class="o">|</span> <span class="o">(</span><span class="n">INPUT</span> {<span class="p">,</span> <span class="n">INPUT</span>}<span class="o">)</span>

<span class="n">INPUT</span> <span class="o">::=</span> <span class="n">name</span>
</pre></div>
</div>
<p>For the semantics of this pragma, see the entry for aspect <code class="docutils literal notranslate"><span class="pre">Initializes</span></code> in the
SPARK 2014 Reference Manual, section 7.1.5.</p>
</div>
<div class="section" id="pragma-inline-always">
<span id="id18"></span><h2><span class="section-number">2.86. </span>Pragma Inline_Always<a class="headerlink" href="#pragma-inline-always" title="Permalink to this headline">¶</a></h2>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pragma</span> <span class="n">Inline_Always</span> <span class="p">(</span><span class="n">NAME</span> <span class="p">[,</span> <span class="n">NAME</span><span class="p">]);</span>
</pre></div>
</div>
<p>Similar to pragma <code class="docutils literal notranslate"><span class="pre">Inline</span></code> except that inlining is unconditional.
Inline_Always instructs the compiler to inline every direct call to the
subprogram or else to emit a compilation error, independently of any
option, in particular <em>-gnatn</em> or <em>-gnatN</em> or the optimization level.
It is an error to take the address or access of <code class="docutils literal notranslate"><span class="pre">NAME</span></code>. It is also an error to
apply this pragma to a primitive operation of a tagged type. Thanks to such
restrictions, the compiler is allowed to remove the out-of-line body of <code class="docutils literal notranslate"><span class="pre">NAME</span></code>.</p>
</div>
<div class="section" id="pragma-inline-generic">
<h2><span class="section-number">2.87. </span>Pragma Inline_Generic<a class="headerlink" href="#pragma-inline-generic" title="Permalink to this headline">¶</a></h2>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pragma</span> <span class="n">Inline_Generic</span> <span class="p">(</span><span class="n">GNAME</span> <span class="p">{,</span> <span class="n">GNAME</span><span class="p">});</span>

<span class="n">GNAME</span> <span class="p">:</span><span class="o">:=</span> <span class="n">generic_unit_NAME</span> <span class="o">|</span> <span class="n">generic_instance_NAME</span>
</pre></div>
</div>
<p>This pragma is provided for compatibility with Dec Ada 83. It has
no effect in GNAT (which always inlines generics), other
than to check that the given names are all names of generic units or
generic instances.</p>
</div>
<div class="section" id="pragma-interface">
<h2><span class="section-number">2.88. </span>Pragma Interface<a class="headerlink" href="#pragma-interface" title="Permalink to this headline">¶</a></h2>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pragma</span> <span class="n">Interface</span> <span class="p">(</span>
     <span class="p">[</span><span class="n">Convention</span>    <span class="o">=&gt;</span><span class="p">]</span> <span class="n">convention_identifier</span><span class="p">,</span>
     <span class="p">[</span><span class="n">Entity</span>        <span class="o">=&gt;</span><span class="p">]</span> <span class="n">local_NAME</span>
  <span class="p">[,</span> <span class="p">[</span><span class="n">External_Name</span> <span class="o">=&gt;</span><span class="p">]</span> <span class="n">static_string_expression</span><span class="p">]</span>
  <span class="p">[,</span> <span class="p">[</span><span class="n">Link_Name</span>     <span class="o">=&gt;</span><span class="p">]</span> <span class="n">static_string_expression</span><span class="p">]);</span>
</pre></div>
</div>
<p>This pragma is identical in syntax and semantics to
the standard Ada pragma <code class="docutils literal notranslate"><span class="pre">Import</span></code>.  It is provided for compatibility
with Ada 83.  The definition is upwards compatible both with pragma
<code class="docutils literal notranslate"><span class="pre">Interface</span></code> as defined in the Ada 83 Reference Manual, and also
with some extended implementations of this pragma in certain Ada 83
implementations.  The only difference between pragma <code class="docutils literal notranslate"><span class="pre">Interface</span></code>
and pragma <code class="docutils literal notranslate"><span class="pre">Import</span></code> is that there is special circuitry to allow
both pragmas to appear for the same subprogram entity (normally it
is illegal to have multiple <code class="docutils literal notranslate"><span class="pre">Import</span></code> pragmas. This is useful in
maintaining Ada 83/Ada 95 compatibility and is compatible with other
Ada 83 compilers.</p>
</div>
<div class="section" id="pragma-interface-name">
<h2><span class="section-number">2.89. </span>Pragma Interface_Name<a class="headerlink" href="#pragma-interface-name" title="Permalink to this headline">¶</a></h2>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pragma</span> <span class="n">Interface_Name</span> <span class="p">(</span>
     <span class="p">[</span><span class="n">Entity</span>        <span class="o">=&gt;</span><span class="p">]</span> <span class="n">LOCAL_NAME</span>
  <span class="p">[,</span> <span class="p">[</span><span class="n">External_Name</span> <span class="o">=&gt;</span><span class="p">]</span> <span class="n">static_string_EXPRESSION</span><span class="p">]</span>
  <span class="p">[,</span> <span class="p">[</span><span class="n">Link_Name</span>     <span class="o">=&gt;</span><span class="p">]</span> <span class="n">static_string_EXPRESSION</span><span class="p">]);</span>
</pre></div>
</div>
<p>This pragma provides an alternative way of specifying the interface name
for an interfaced subprogram, and is provided for compatibility with Ada
83 compilers that use the pragma for this purpose.  You must provide at
least one of <code class="docutils literal notranslate"><span class="pre">External_Name</span></code> or <code class="docutils literal notranslate"><span class="pre">Link_Name</span></code>.</p>
</div>
<div class="section" id="pragma-interrupt-handler">
<h2><span class="section-number">2.90. </span>Pragma Interrupt_Handler<a class="headerlink" href="#pragma-interrupt-handler" title="Permalink to this headline">¶</a></h2>
<p>Syntax:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma</span><span class="p"> </span><span class="n">Interrupt_Handler</span> <span class="o">(</span><span class="n">procedure_LOCAL_NAME</span><span class="o">)</span><span class="p">;</span>
</pre></div>
</div>
<p>This program unit pragma is supported for parameterless protected procedures
as described in Annex C of the Ada Reference Manual.</p>
</div>
<div class="section" id="pragma-interrupt-state">
<h2><span class="section-number">2.91. </span>Pragma Interrupt_State<a class="headerlink" href="#pragma-interrupt-state" title="Permalink to this headline">¶</a></h2>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pragma</span> <span class="n">Interrupt_State</span>
 <span class="p">([</span><span class="n">Name</span>  <span class="o">=&gt;</span><span class="p">]</span> <span class="n">value</span><span class="p">,</span>
  <span class="p">[</span><span class="n">State</span> <span class="o">=&gt;</span><span class="p">]</span> <span class="n">SYSTEM</span> <span class="o">|</span> <span class="n">RUNTIME</span> <span class="o">|</span> <span class="n">USER</span><span class="p">);</span>
</pre></div>
</div>
<p>Normally certain interrupts are reserved to the implementation.  Any attempt
to attach an interrupt causes Program_Error to be raised, as described in
RM C.3.2(22).  A typical example is the <code class="docutils literal notranslate"><span class="pre">SIGINT</span></code> interrupt used in
many systems for an <kbd class="kbd docutils literal notranslate"><kbd class="kbd docutils literal notranslate">Ctrl</kbd>-<kbd class="kbd docutils literal notranslate">C</kbd></kbd> interrupt.  Normally this interrupt is
reserved to the implementation, so that <kbd class="kbd docutils literal notranslate"><kbd class="kbd docutils literal notranslate">Ctrl</kbd>-<kbd class="kbd docutils literal notranslate">C</kbd></kbd> can be used to
interrupt execution.  Additionally, signals such as <code class="docutils literal notranslate"><span class="pre">SIGSEGV</span></code>,
<code class="docutils literal notranslate"><span class="pre">SIGABRT</span></code>, <code class="docutils literal notranslate"><span class="pre">SIGFPE</span></code> and <code class="docutils literal notranslate"><span class="pre">SIGILL</span></code> are often mapped to specific
Ada exceptions, or used to implement run-time functions such as the
<code class="docutils literal notranslate"><span class="pre">abort</span></code> statement and stack overflow checking.</p>
<p>Pragma <code class="docutils literal notranslate"><span class="pre">Interrupt_State</span></code> provides a general mechanism for overriding
such uses of interrupts.  It subsumes the functionality of pragma
<code class="docutils literal notranslate"><span class="pre">Unreserve_All_Interrupts</span></code>.  Pragma <code class="docutils literal notranslate"><span class="pre">Interrupt_State</span></code> is not
available on Windows.  On all other platforms than VxWorks,
it applies to signals; on VxWorks, it applies to vectored hardware interrupts
and may be used to mark interrupts required by the board support package
as reserved.</p>
<p>Interrupts can be in one of three states:</p>
<ul>
<li><p>System</p>
<p>The interrupt is reserved (no Ada handler can be installed), and the
Ada run-time may not install a handler. As a result you are guaranteed
standard system default action if this interrupt is raised. This also allows
installing a low level handler via C APIs such as sigaction(), outside
of Ada control.</p>
</li>
<li><p>Runtime</p>
<p>The interrupt is reserved (no Ada handler can be installed). The run time
is allowed to install a handler for internal control purposes, but is
not required to do so.</p>
</li>
<li><p>User</p>
<p>The interrupt is unreserved.  The user may install an Ada handler via
Ada.Interrupts and pragma Interrupt_Handler or Attach_Handler to provide
some other action.</p>
</li>
</ul>
<p>These states are the allowed values of the <code class="docutils literal notranslate"><span class="pre">State</span></code> parameter of the
pragma.  The <code class="docutils literal notranslate"><span class="pre">Name</span></code> parameter is a value of the type
<code class="docutils literal notranslate"><span class="pre">Ada.Interrupts.Interrupt_ID</span></code>.  Typically, it is a name declared in
<code class="docutils literal notranslate"><span class="pre">Ada.Interrupts.Names</span></code>.</p>
<p>This is a configuration pragma, and the binder will check that there
are no inconsistencies between different units in a partition in how a
given interrupt is specified. It may appear anywhere a pragma is legal.</p>
<p>The effect is to move the interrupt to the specified state.</p>
<p>By declaring interrupts to be SYSTEM, you guarantee the standard system
action, such as a core dump.</p>
<p>By declaring interrupts to be USER, you guarantee that you can install
a handler.</p>
<p>Note that certain signals on many operating systems cannot be caught and
handled by applications.  In such cases, the pragma is ignored.  See the
operating system documentation, or the value of the array <code class="docutils literal notranslate"><span class="pre">Reserved</span></code>
declared in the spec of package <code class="docutils literal notranslate"><span class="pre">System.OS_Interface</span></code>.</p>
<p>Overriding the default state of signals used by the Ada runtime may interfere
with an application’s runtime behavior in the cases of the synchronous signals,
and in the case of the signal used to implement the <code class="docutils literal notranslate"><span class="pre">abort</span></code> statement.</p>
</div>
<div class="section" id="pragma-invariant">
<span id="id19"></span><h2><span class="section-number">2.92. </span>Pragma Invariant<a class="headerlink" href="#pragma-invariant" title="Permalink to this headline">¶</a></h2>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pragma</span> <span class="n">Invariant</span>
  <span class="p">([</span><span class="n">Entity</span> <span class="o">=&gt;</span><span class="p">]</span>    <span class="n">private_type_LOCAL_NAME</span><span class="p">,</span>
   <span class="p">[</span><span class="n">Check</span>  <span class="o">=&gt;</span><span class="p">]</span>    <span class="n">EXPRESSION</span>
   <span class="p">[,[</span><span class="n">Message</span> <span class="o">=&gt;</span><span class="p">]</span> <span class="n">String_Expression</span><span class="p">]);</span>
</pre></div>
</div>
<p>This pragma provides exactly the same capabilities as the Type_Invariant aspect
defined in AI05-0146-1, and in the Ada 2012 Reference Manual. The
Type_Invariant aspect is fully implemented in Ada 2012 mode, but since it
requires the use of the aspect syntax, which is not available except in 2012
mode, it is not possible to use the Type_Invariant aspect in earlier versions
of Ada. However the Invariant pragma may be used in any version of Ada. Also
note that the aspect Invariant is a synonym in GNAT for the aspect
Type_Invariant, but there is no pragma Type_Invariant.</p>
<p>The pragma must appear within the visible part of the package specification,
after the type to which its Entity argument appears. As with the Invariant
aspect, the Check expression is not analyzed until the end of the visible
part of the package, so it may contain forward references. The Message
argument, if present, provides the exception message used if the invariant
is violated. If no Message parameter is provided, a default message that
identifies the line on which the pragma appears is used.</p>
<p>It is permissible to have multiple Invariants for the same type entity, in
which case they are and’ed together. It is permissible to use this pragma
in Ada 2012 mode, but you cannot have both an invariant aspect and an
invariant pragma for the same entity.</p>
<p>For further details on the use of this pragma, see the Ada 2012 documentation
of the Type_Invariant aspect.</p>
</div>
<div class="section" id="pragma-keep-names">
<h2><span class="section-number">2.93. </span>Pragma Keep_Names<a class="headerlink" href="#pragma-keep-names" title="Permalink to this headline">¶</a></h2>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pragma</span> <span class="n">Keep_Names</span> <span class="p">([</span><span class="n">On</span> <span class="o">=&gt;</span><span class="p">]</span> <span class="n">enumeration_first_subtype_LOCAL_NAME</span><span class="p">);</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">LOCAL_NAME</span></code> argument
must refer to an enumeration first subtype
in the current declarative part. The effect is to retain the enumeration
literal names for use by <code class="docutils literal notranslate"><span class="pre">Image</span></code> and <code class="docutils literal notranslate"><span class="pre">Value</span></code> even if a global
<code class="docutils literal notranslate"><span class="pre">Discard_Names</span></code> pragma applies. This is useful when you want to
generally suppress enumeration literal names and for example you therefore
use a <code class="docutils literal notranslate"><span class="pre">Discard_Names</span></code> pragma in the <code class="file docutils literal notranslate"><span class="pre">gnat.adc</span></code> file, but you
want to retain the names for specific enumeration types.</p>
</div>
<div class="section" id="pragma-license">
<h2><span class="section-number">2.94. </span>Pragma License<a class="headerlink" href="#pragma-license" title="Permalink to this headline">¶</a></h2>
<p id="index-46">Syntax:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma</span><span class="p"> </span><span class="n">License</span> <span class="o">(</span><span class="n">Unrestricted</span> <span class="o">|</span> <span class="n">GPL</span> <span class="o">|</span> <span class="n">Modified_GPL</span> <span class="o">|</span> <span class="n">Restricted</span><span class="o">)</span><span class="p">;</span>
</pre></div>
</div>
<p>This pragma is provided to allow automated checking for appropriate license
conditions with respect to the standard and modified GPL.  A pragma
<code class="docutils literal notranslate"><span class="pre">License</span></code>, which is a configuration pragma that typically appears at
the start of a source file or in a separate <code class="file docutils literal notranslate"><span class="pre">gnat.adc</span></code> file, specifies
the licensing conditions of a unit as follows:</p>
<ul class="simple">
<li><p>Unrestricted
This is used for a unit that can be freely used with no license restrictions.
Examples of such units are public domain units, and units from the Ada
Reference Manual.</p></li>
<li><p>GPL
This is used for a unit that is licensed under the unmodified GPL, and which
therefore cannot be <code class="docutils literal notranslate"><span class="pre">with</span></code>ed by a restricted unit.</p></li>
<li><p>Modified_GPL
This is used for a unit licensed under the GNAT modified GPL that includes
a special exception paragraph that specifically permits the inclusion of
the unit in programs without requiring the entire program to be released
under the GPL.</p></li>
<li><p>Restricted
This is used for a unit that is restricted in that it is not permitted to
depend on units that are licensed under the GPL.  Typical examples are
proprietary code that is to be released under more restrictive license
conditions.  Note that restricted units are permitted to <code class="docutils literal notranslate"><span class="pre">with</span></code> units
which are licensed under the modified GPL (this is the whole point of the
modified GPL).</p></li>
</ul>
<p>Normally a unit with no <code class="docutils literal notranslate"><span class="pre">License</span></code> pragma is considered to have an
unknown license, and no checking is done.  However, standard GNAT headers
are recognized, and license information is derived from them as follows.</p>
<p>A GNAT license header starts with a line containing 78 hyphens.  The following
comment text is searched for the appearance of any of the following strings.</p>
<p>If the string ‘GNU General Public License’ is found, then the unit is assumed
to have GPL license, unless the string ‘As a special exception’ follows, in
which case the license is assumed to be modified GPL.</p>
<p>If one of the strings
‘This specification is adapted from the Ada Semantic Interface’ or
‘This specification is derived from the Ada Reference Manual’ is found
then the unit is assumed to be unrestricted.</p>
<p>These default actions means that a program with a restricted license pragma
will automatically get warnings if a GPL unit is inappropriately
<code class="docutils literal notranslate"><span class="pre">with</span></code>ed.  For example, the program:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">with</span><span class="p"> </span><span class="n">Sem_Ch3</span><span class="p">;</span>
<span class="kr">with</span><span class="nn"> GNAT.Sockets;</span>
<span class="k">procedure </span><span class="nf">Secret_Stuff</span> <span class="kr">is</span><span class="p"></span>
  <span class="o">...</span>
<span class="k">end </span><span class="nf">Secret_Stuff</span>
</pre></div>
</div>
<p>if compiled with pragma <code class="docutils literal notranslate"><span class="pre">License</span></code> (<code class="docutils literal notranslate"><span class="pre">Restricted</span></code>) in a
<code class="file docutils literal notranslate"><span class="pre">gnat.adc</span></code> file will generate the warning:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mf">1.</span>  <span class="k">with</span> <span class="n">Sem_Ch3</span><span class="p">;</span>
        <span class="o">|</span>
   <span class="o">&gt;&gt;&gt;</span> <span class="n">license</span> <span class="n">of</span> <span class="n">withed</span> <span class="n">unit</span> <span class="s2">&quot;Sem_Ch3&quot;</span> <span class="ow">is</span> <span class="n">incompatible</span>

<span class="mf">2.</span>  <span class="k">with</span> <span class="n">GNAT</span><span class="o">.</span><span class="n">Sockets</span><span class="p">;</span>
<span class="mf">3.</span>  <span class="n">procedure</span> <span class="n">Secret_Stuff</span> <span class="ow">is</span>
</pre></div>
</div>
<p>Here we get a warning on <code class="docutils literal notranslate"><span class="pre">Sem_Ch3</span></code> since it is part of the GNAT
compiler and is licensed under the
GPL, but no warning for <code class="docutils literal notranslate"><span class="pre">GNAT.Sockets</span></code> which is part of the GNAT
run time, and is therefore licensed under the modified GPL.</p>
</div>
<div class="section" id="pragma-link-with">
<h2><span class="section-number">2.95. </span>Pragma Link_With<a class="headerlink" href="#pragma-link-with" title="Permalink to this headline">¶</a></h2>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pragma</span> <span class="n">Link_With</span> <span class="p">(</span><span class="n">static_string_EXPRESSION</span> <span class="p">{,</span><span class="n">static_string_EXPRESSION</span><span class="p">});</span>
</pre></div>
</div>
<p>This pragma is provided for compatibility with certain Ada 83 compilers.
It has exactly the same effect as pragma <code class="docutils literal notranslate"><span class="pre">Linker_Options</span></code> except
that spaces occurring within one of the string expressions are treated
as separators. For example, in the following case:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma</span><span class="p"> </span><span class="n">Link_With</span> <span class="o">(</span><span class="s">&quot;-labc -ldef&quot;</span><span class="o">)</span><span class="p">;</span>
</pre></div>
</div>
<p>results in passing the strings <code class="docutils literal notranslate"><span class="pre">-labc</span></code> and <code class="docutils literal notranslate"><span class="pre">-ldef</span></code> as two
separate arguments to the linker. In addition pragma Link_With allows
multiple arguments, with the same effect as successive pragmas.</p>
</div>
<div class="section" id="pragma-linker-alias">
<h2><span class="section-number">2.96. </span>Pragma Linker_Alias<a class="headerlink" href="#pragma-linker-alias" title="Permalink to this headline">¶</a></h2>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pragma</span> <span class="n">Linker_Alias</span> <span class="p">(</span>
  <span class="p">[</span><span class="n">Entity</span> <span class="o">=&gt;</span><span class="p">]</span> <span class="n">LOCAL_NAME</span><span class="p">,</span>
  <span class="p">[</span><span class="n">Target</span> <span class="o">=&gt;</span><span class="p">]</span> <span class="n">static_string_EXPRESSION</span><span class="p">);</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">LOCAL_NAME</span></code> must refer to an object that is declared at the library
level. This pragma establishes the given entity as a linker alias for the
given target. It is equivalent to <code class="docutils literal notranslate"><span class="pre">__attribute__((alias))</span></code> in GNU C
and causes <code class="docutils literal notranslate"><span class="pre">LOCAL_NAME</span></code> to be emitted as an alias for the symbol
<code class="docutils literal notranslate"><span class="pre">static_string_EXPRESSION</span></code> in the object file, that is to say no space
is reserved for <code class="docutils literal notranslate"><span class="pre">LOCAL_NAME</span></code> by the assembler and it will be resolved
to the same address as <code class="docutils literal notranslate"><span class="pre">static_string_EXPRESSION</span></code> by the linker.</p>
<p>The actual linker name for the target must be used (e.g., the fully
encoded name with qualification in Ada, or the mangled name in C++),
or it must be declared using the C convention with <code class="docutils literal notranslate"><span class="pre">pragma</span> <span class="pre">Import</span></code>
or <code class="docutils literal notranslate"><span class="pre">pragma</span> <span class="pre">Export</span></code>.</p>
<p>Not all target machines support this pragma. On some of them it is accepted
only if <code class="docutils literal notranslate"><span class="pre">pragma</span> <span class="pre">Weak_External</span></code> has been applied to <code class="docutils literal notranslate"><span class="pre">LOCAL_NAME</span></code>.</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="c">--  Example of the use of pragma Linker_Alias</span>

<span class="k">package </span><span class="nf">p</span> <span class="kr">is</span><span class="p"></span>
  <span class="n">i</span> <span class="o">:</span> <span class="n">Integer</span> <span class="o">:=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="kr">pragma</span><span class="p"> </span><span class="n">Export</span> <span class="o">(</span><span class="n">C</span><span class="p">,</span> <span class="n">i</span><span class="o">)</span><span class="p">;</span>

  <span class="n">new_name_for_i</span> <span class="o">:</span> <span class="n">Integer</span><span class="p">;</span>
  <span class="kr">pragma</span><span class="p"> </span><span class="n">Linker_Alias</span> <span class="o">(</span><span class="n">new_name_for_i</span><span class="p">,</span> <span class="s">&quot;i&quot;</span><span class="o">)</span><span class="p">;</span>
<span class="k">end </span><span class="nf">p</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="pragma-linker-constructor">
<h2><span class="section-number">2.97. </span>Pragma Linker_Constructor<a class="headerlink" href="#pragma-linker-constructor" title="Permalink to this headline">¶</a></h2>
<p>Syntax:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma</span><span class="p"> </span><span class="n">Linker_Constructor</span> <span class="o">(</span><span class="n">procedure_LOCAL_NAME</span><span class="o">)</span><span class="p">;</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">procedure_LOCAL_NAME</span></code> must refer to a parameterless procedure that
is declared at the library level. A procedure to which this pragma is
applied will be treated as an initialization routine by the linker.
It is equivalent to <code class="docutils literal notranslate"><span class="pre">__attribute__((constructor))</span></code> in GNU C and
causes <code class="docutils literal notranslate"><span class="pre">procedure_LOCAL_NAME</span></code> to be invoked before the entry point
of the executable is called (or immediately after the shared library is
loaded if the procedure is linked in a shared library), in particular
before the Ada run-time environment is set up.</p>
<p>Because of these specific contexts, the set of operations such a procedure
can perform is very limited and the type of objects it can manipulate is
essentially restricted to the elementary types. In particular, it must only
contain code to which pragma Restrictions (No_Elaboration_Code) applies.</p>
<p>This pragma is used by GNAT to implement auto-initialization of shared Stand
Alone Libraries, which provides a related capability without the restrictions
listed above. Where possible, the use of Stand Alone Libraries is preferable
to the use of this pragma.</p>
</div>
<div class="section" id="pragma-linker-destructor">
<h2><span class="section-number">2.98. </span>Pragma Linker_Destructor<a class="headerlink" href="#pragma-linker-destructor" title="Permalink to this headline">¶</a></h2>
<p>Syntax:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma</span><span class="p"> </span><span class="n">Linker_Destructor</span> <span class="o">(</span><span class="n">procedure_LOCAL_NAME</span><span class="o">)</span><span class="p">;</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">procedure_LOCAL_NAME</span></code> must refer to a parameterless procedure that
is declared at the library level. A procedure to which this pragma is
applied will be treated as a finalization routine by the linker.
It is equivalent to <code class="docutils literal notranslate"><span class="pre">__attribute__((destructor))</span></code> in GNU C and
causes <code class="docutils literal notranslate"><span class="pre">procedure_LOCAL_NAME</span></code> to be invoked after the entry point
of the executable has exited (or immediately before the shared library
is unloaded if the procedure is linked in a shared library), in particular
after the Ada run-time environment is shut down.</p>
<p>See <code class="docutils literal notranslate"><span class="pre">pragma</span> <span class="pre">Linker_Constructor</span></code> for the set of restrictions that apply
because of these specific contexts.</p>
</div>
<div class="section" id="pragma-linker-section">
<span id="id20"></span><h2><span class="section-number">2.99. </span>Pragma Linker_Section<a class="headerlink" href="#pragma-linker-section" title="Permalink to this headline">¶</a></h2>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pragma</span> <span class="n">Linker_Section</span> <span class="p">(</span>
  <span class="p">[</span><span class="n">Entity</span>  <span class="o">=&gt;</span><span class="p">]</span> <span class="n">LOCAL_NAME</span><span class="p">,</span>
  <span class="p">[</span><span class="n">Section</span> <span class="o">=&gt;</span><span class="p">]</span> <span class="n">static_string_EXPRESSION</span><span class="p">);</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">LOCAL_NAME</span></code> must refer to an object, type, or subprogram that is
declared at the library level. This pragma specifies the name of the
linker section for the given entity. It is equivalent to
<code class="docutils literal notranslate"><span class="pre">__attribute__((section))</span></code> in GNU C and causes <code class="docutils literal notranslate"><span class="pre">LOCAL_NAME</span></code> to
be placed in the <code class="docutils literal notranslate"><span class="pre">static_string_EXPRESSION</span></code> section of the
executable (assuming the linker doesn’t rename the section).
GNAT also provides an implementation defined aspect of the same name.</p>
<p>In the case of specifying this aspect for a type, the effect is to
specify the corresponding section for all library-level objects of
the type that do not have an explicit linker section set. Note that
this only applies to whole objects, not to components of composite objects.</p>
<p>In the case of a subprogram, the linker section applies to all previously
declared matching overloaded subprograms in the current declarative part
which do not already have a linker section assigned. The linker section
aspect is useful in this case for specifying different linker sections
for different elements of such an overloaded set.</p>
<p>Note that an empty string specifies that no linker section is specified.
This is not quite the same as omitting the pragma or aspect, since it
can be used to specify that one element of an overloaded set of subprograms
has the default linker section, or that one object of a type for which a
linker section is specified should has the default linker section.</p>
<p>The compiler normally places library-level entities in standard sections
depending on the class: procedures and functions generally go in the
<code class="docutils literal notranslate"><span class="pre">.text</span></code> section, initialized variables in the <code class="docutils literal notranslate"><span class="pre">.data</span></code> section
and uninitialized variables in the <code class="docutils literal notranslate"><span class="pre">.bss</span></code> section.</p>
<p>Other, special sections may exist on given target machines to map special
hardware, for example I/O ports or flash memory. This pragma is a means to
defer the final layout of the executable to the linker, thus fully working
at the symbolic level with the compiler.</p>
<p>Some file formats do not support arbitrary sections so not all target
machines support this pragma. The use of this pragma may cause a program
execution to be erroneous if it is used to place an entity into an
inappropriate section (e.g., a modified variable into the <code class="docutils literal notranslate"><span class="pre">.text</span></code>
section). See also <code class="docutils literal notranslate"><span class="pre">pragma</span> <span class="pre">Persistent_BSS</span></code>.</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="c">--  Example of the use of pragma Linker_Section</span>

<span class="k">package </span><span class="nf">IO_Card</span> <span class="kr">is</span><span class="p"></span>
  <span class="n">Port_A</span> <span class="o">:</span> <span class="n">Integer</span><span class="p">;</span>
  <span class="kr">pragma</span><span class="p"> </span><span class="n">Volatile</span> <span class="o">(</span><span class="n">Port_A</span><span class="o">)</span><span class="p">;</span>
  <span class="kr">pragma</span><span class="p"> </span><span class="n">Linker_Section</span> <span class="o">(</span><span class="n">Port_A</span><span class="p">,</span> <span class="s">&quot;.bss.port_a&quot;</span><span class="o">)</span><span class="p">;</span>

  <span class="n">Port_B</span> <span class="o">:</span> <span class="n">Integer</span><span class="p">;</span>
  <span class="kr">pragma</span><span class="p"> </span><span class="n">Volatile</span> <span class="o">(</span><span class="n">Port_B</span><span class="o">)</span><span class="p">;</span>
  <span class="kr">pragma</span><span class="p"> </span><span class="n">Linker_Section</span> <span class="o">(</span><span class="n">Port_B</span><span class="p">,</span> <span class="s">&quot;.bss.port_b&quot;</span><span class="o">)</span><span class="p">;</span>

  <span class="kr">type</span><span class="p"> </span><span class="n">Port_Type</span> <span class="kr">is</span><span class="p"> </span><span class="kr">new</span><span class="p"> </span><span class="n">Integer</span> <span class="kr">with</span><span class="p"> </span><span class="n">Linker_Section</span> <span class="o">=&gt;</span> <span class="s">&quot;.bss&quot;</span><span class="p">;</span>
  <span class="n">PA</span> <span class="o">:</span> <span class="n">Port_Type</span> <span class="kr">with</span><span class="p"> </span><span class="n">Linker_Section</span> <span class="o">=&gt;</span> <span class="s">&quot;.bss.PA&quot;</span><span class="p">;</span>
  <span class="n">PB</span> <span class="o">:</span> <span class="n">Port_Type</span><span class="p">;</span> <span class="c">--  ends up in linker section &quot;.bss&quot;</span>

  <span class="k">procedure </span><span class="nf">Q</span> <span class="kr">with</span><span class="p"> </span><span class="n">Linker_Section</span> <span class="o">=&gt;</span> <span class="s">&quot;Qsection&quot;</span><span class="p">;</span>
<span class="k">end </span><span class="nf">IO_Card</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="pragma-lock-free">
<span id="id21"></span><h2><span class="section-number">2.100. </span>Pragma Lock_Free<a class="headerlink" href="#pragma-lock-free" title="Permalink to this headline">¶</a></h2>
<p>Syntax:
This pragma may be specified for protected types or objects. It specifies that
the implementation of protected operations must be implemented without locks.
Compilation fails if the compiler cannot generate lock-free code for the
operations.</p>
<p>The current conditions required to support this pragma are:</p>
<ul class="simple">
<li><p>Protected type declarations may not contain entries</p></li>
<li><p>Protected subprogram declarations may not have nonelementary parameters</p></li>
</ul>
<p>In addition, each protected subprogram body must satisfy:</p>
<ul class="simple">
<li><p>May reference only one protected component</p></li>
<li><p>May not reference nonconstant entities outside the protected subprogram
scope.</p></li>
<li><p>May not contain address representation items, allocators, or quantified
expressions.</p></li>
<li><p>May not contain delay, goto, loop, or procedure-call statements.</p></li>
<li><p>May not contain exported and imported entities</p></li>
<li><p>May not dereferenced access values</p></li>
<li><p>Function calls and attribute references must be static</p></li>
</ul>
</div>
<div class="section" id="pragma-loop-invariant">
<h2><span class="section-number">2.101. </span>Pragma Loop_Invariant<a class="headerlink" href="#pragma-loop-invariant" title="Permalink to this headline">¶</a></h2>
<p>Syntax:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma</span><span class="p"> </span><span class="n">Loop_Invariant</span> <span class="o">(</span> <span class="n">boolean_EXPRESSION</span> <span class="o">)</span><span class="p">;</span>
</pre></div>
</div>
<p>The effect of this pragma is similar to that of pragma <code class="docutils literal notranslate"><span class="pre">Assert</span></code>,
except that in an <code class="docutils literal notranslate"><span class="pre">Assertion_Policy</span></code> pragma, the identifier
<code class="docutils literal notranslate"><span class="pre">Loop_Invariant</span></code> is used to control whether it is ignored or checked
(or disabled).</p>
<p><code class="docutils literal notranslate"><span class="pre">Loop_Invariant</span></code> can only appear as one of the items in the sequence
of statements of a loop body, or nested inside block statements that
appear in the sequence of statements of a loop body.
The intention is that it be used to
represent a “loop invariant” assertion, i.e. something that is true each
time through the loop, and which can be used to show that the loop is
achieving its purpose.</p>
<p>Multiple <code class="docutils literal notranslate"><span class="pre">Loop_Invariant</span></code> and <code class="docutils literal notranslate"><span class="pre">Loop_Variant</span></code> pragmas that
apply to the same loop should be grouped in the same sequence of
statements.</p>
<p>To aid in writing such invariants, the special attribute <code class="docutils literal notranslate"><span class="pre">Loop_Entry</span></code>
may be used to refer to the value of an expression on entry to the loop. This
attribute can only be used within the expression of a <code class="docutils literal notranslate"><span class="pre">Loop_Invariant</span></code>
pragma. For full details, see documentation of attribute <code class="docutils literal notranslate"><span class="pre">Loop_Entry</span></code>.</p>
</div>
<div class="section" id="pragma-loop-optimize">
<h2><span class="section-number">2.102. </span>Pragma Loop_Optimize<a class="headerlink" href="#pragma-loop-optimize" title="Permalink to this headline">¶</a></h2>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pragma</span> <span class="n">Loop_Optimize</span> <span class="p">(</span><span class="n">OPTIMIZATION_HINT</span> <span class="p">{,</span> <span class="n">OPTIMIZATION_HINT</span><span class="p">});</span>

<span class="n">OPTIMIZATION_HINT</span> <span class="p">:</span><span class="o">:=</span> <span class="n">Ivdep</span> <span class="o">|</span> <span class="n">No_Unroll</span> <span class="o">|</span> <span class="n">Unroll</span> <span class="o">|</span> <span class="n">No_Vector</span> <span class="o">|</span> <span class="n">Vector</span>
</pre></div>
</div>
<p>This pragma must appear immediately within a loop statement.  It allows the
programmer to specify optimization hints for the enclosing loop.  The hints
are not mutually exclusive and can be freely mixed, but not all combinations
will yield a sensible outcome.</p>
<p>There are five supported optimization hints for a loop:</p>
<ul>
<li><p>Ivdep</p>
<p>The programmer asserts that there are no loop-carried dependencies
which would prevent consecutive iterations of the loop from being
executed simultaneously.</p>
</li>
<li><p>No_Unroll</p>
<p>The loop must not be unrolled.  This is a strong hint: the compiler will not
unroll a loop marked with this hint.</p>
</li>
<li><p>Unroll</p>
<p>The loop should be unrolled.  This is a weak hint: the compiler will try to
apply unrolling to this loop preferably to other optimizations, notably
vectorization, but there is no guarantee that the loop will be unrolled.</p>
</li>
<li><p>No_Vector</p>
<p>The loop must not be vectorized.  This is a strong hint: the compiler will not
vectorize a loop marked with this hint.</p>
</li>
<li><p>Vector</p>
<p>The loop should be vectorized.  This is a weak hint: the compiler will try to
apply vectorization to this loop preferably to other optimizations, notably
unrolling, but there is no guarantee that the loop will be vectorized.</p>
</li>
</ul>
<p>These hints do not remove the need to pass the appropriate switches to the
compiler in order to enable the relevant optimizations, that is to say
<em>-funroll-loops</em> for unrolling and <em>-ftree-vectorize</em> for
vectorization.</p>
</div>
<div class="section" id="pragma-loop-variant">
<h2><span class="section-number">2.103. </span>Pragma Loop_Variant<a class="headerlink" href="#pragma-loop-variant" title="Permalink to this headline">¶</a></h2>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pragma</span> <span class="n">Loop_Variant</span> <span class="p">(</span> <span class="n">LOOP_VARIANT_ITEM</span> <span class="p">{,</span> <span class="n">LOOP_VARIANT_ITEM</span> <span class="p">}</span> <span class="p">);</span>
<span class="n">LOOP_VARIANT_ITEM</span> <span class="p">:</span><span class="o">:=</span> <span class="n">CHANGE_DIRECTION</span> <span class="o">=&gt;</span> <span class="n">discrete_EXPRESSION</span>
<span class="n">CHANGE_DIRECTION</span> <span class="p">:</span><span class="o">:=</span> <span class="n">Increases</span> <span class="o">|</span> <span class="n">Decreases</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">Loop_Variant</span></code> can only appear as one of the items in the sequence
of statements of a loop body, or nested inside block statements that
appear in the sequence of statements of a loop body.
It allows the specification of quantities which must always
decrease or increase in successive iterations of the loop. In its simplest
form, just one expression is specified, whose value must increase or decrease
on each iteration of the loop.</p>
<p>In a more complex form, multiple arguments can be given which are intepreted
in a nesting lexicographic manner. For example:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma</span><span class="p"> </span><span class="n">Loop_Variant</span> <span class="o">(</span><span class="n">Increases</span> <span class="o">=&gt;</span> <span class="n">X</span><span class="p">,</span> <span class="n">Decreases</span> <span class="o">=&gt;</span> <span class="n">Y</span><span class="o">)</span><span class="p">;</span>
</pre></div>
</div>
<p>specifies that each time through the loop either X increases, or X stays
the same and Y decreases. A <code class="docutils literal notranslate"><span class="pre">Loop_Variant</span></code> pragma ensures that the
loop is making progress. It can be useful in helping to show informally
or prove formally that the loop always terminates.</p>
<p><code class="docutils literal notranslate"><span class="pre">Loop_Variant</span></code> is an assertion whose effect can be controlled using
an <code class="docutils literal notranslate"><span class="pre">Assertion_Policy</span></code> with a check name of <code class="docutils literal notranslate"><span class="pre">Loop_Variant</span></code>. The
policy can be <code class="docutils literal notranslate"><span class="pre">Check</span></code> to enable the loop variant check, <code class="docutils literal notranslate"><span class="pre">Ignore</span></code>
to ignore the check (in which case the pragma has no effect on the program),
or <code class="docutils literal notranslate"><span class="pre">Disable</span></code> in which case the pragma is not even checked for correct
syntax.</p>
<p>Multiple <code class="docutils literal notranslate"><span class="pre">Loop_Invariant</span></code> and <code class="docutils literal notranslate"><span class="pre">Loop_Variant</span></code> pragmas that
apply to the same loop should be grouped in the same sequence of
statements.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">Loop_Entry</span></code> attribute may be used within the expressions of the
<code class="docutils literal notranslate"><span class="pre">Loop_Variant</span></code> pragma to refer to values on entry to the loop.</p>
</div>
<div class="section" id="pragma-machine-attribute">
<h2><span class="section-number">2.104. </span>Pragma Machine_Attribute<a class="headerlink" href="#pragma-machine-attribute" title="Permalink to this headline">¶</a></h2>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pragma</span> <span class="n">Machine_Attribute</span> <span class="p">(</span>
     <span class="p">[</span><span class="n">Entity</span>         <span class="o">=&gt;</span><span class="p">]</span> <span class="n">LOCAL_NAME</span><span class="p">,</span>
     <span class="p">[</span><span class="n">Attribute_Name</span> <span class="o">=&gt;</span><span class="p">]</span> <span class="n">static_string_EXPRESSION</span>
  <span class="p">[,</span> <span class="p">[</span><span class="n">Info</span>           <span class="o">=&gt;</span><span class="p">]</span> <span class="n">static_EXPRESSION</span> <span class="p">{,</span> <span class="n">static_EXPRESSION</span><span class="p">}]</span> <span class="p">);</span>
</pre></div>
</div>
<p>Machine-dependent attributes can be specified for types and/or
declarations.  This pragma is semantically equivalent to
<code class="samp docutils literal notranslate"><span class="pre">__attribute__((</span><em><span class="pre">attribute_name</span></em><span class="pre">))</span></code> (if <code class="docutils literal notranslate"><span class="pre">info</span></code> is not
specified) or <code class="samp docutils literal notranslate"><span class="pre">__attribute__((</span><em><span class="pre">attribute_name(info</span></em><span class="pre">)))</span></code>
or <code class="samp docutils literal notranslate"><span class="pre">__attribute__((</span><em><span class="pre">attribute_name(info,…</span></em><span class="pre">)))</span></code> in GNU C,
where <em>attribute_name</em> is recognized by the compiler middle-end
or the <code class="docutils literal notranslate"><span class="pre">TARGET_ATTRIBUTE_TABLE</span></code> machine specific macro.  Note
that a string literal for the optional parameter <code class="docutils literal notranslate"><span class="pre">info</span></code> or the
following ones is transformed by default into an identifier,
which may make this pragma unusable for some attributes.
For further information see <cite>GNU Compiler Collection (GCC) Internals</cite>.</p>
</div>
<div class="section" id="pragma-main">
<h2><span class="section-number">2.105. </span>Pragma Main<a class="headerlink" href="#pragma-main" title="Permalink to this headline">¶</a></h2>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pragma</span> <span class="n">Main</span>
 <span class="p">(</span><span class="n">MAIN_OPTION</span> <span class="p">[,</span> <span class="n">MAIN_OPTION</span><span class="p">]);</span>

<span class="n">MAIN_OPTION</span> <span class="p">:</span><span class="o">:=</span>
  <span class="p">[</span><span class="n">Stack_Size</span>              <span class="o">=&gt;</span><span class="p">]</span> <span class="n">static_integer_EXPRESSION</span>
<span class="o">|</span> <span class="p">[</span><span class="n">Task_Stack_Size_Default</span> <span class="o">=&gt;</span><span class="p">]</span> <span class="n">static_integer_EXPRESSION</span>
<span class="o">|</span> <span class="p">[</span><span class="n">Time_Slicing_Enabled</span>    <span class="o">=&gt;</span><span class="p">]</span> <span class="n">static_boolean_EXPRESSION</span>
</pre></div>
</div>
<p>This pragma is provided for compatibility with OpenVMS VAX Systems.  It has
no effect in GNAT, other than being syntax checked.</p>
</div>
<div class="section" id="pragma-main-storage">
<h2><span class="section-number">2.106. </span>Pragma Main_Storage<a class="headerlink" href="#pragma-main-storage" title="Permalink to this headline">¶</a></h2>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pragma</span> <span class="n">Main_Storage</span>
  <span class="p">(</span><span class="n">MAIN_STORAGE_OPTION</span> <span class="p">[,</span> <span class="n">MAIN_STORAGE_OPTION</span><span class="p">]);</span>

<span class="n">MAIN_STORAGE_OPTION</span> <span class="p">:</span><span class="o">:=</span>
  <span class="p">[</span><span class="n">WORKING_STORAGE</span> <span class="o">=&gt;</span><span class="p">]</span> <span class="n">static_SIMPLE_EXPRESSION</span>
<span class="o">|</span> <span class="p">[</span><span class="n">TOP_GUARD</span>       <span class="o">=&gt;</span><span class="p">]</span> <span class="n">static_SIMPLE_EXPRESSION</span>
</pre></div>
</div>
<p>This pragma is provided for compatibility with OpenVMS VAX Systems.  It has
no effect in GNAT, other than being syntax checked.</p>
</div>
<div class="section" id="pragma-max-queue-length">
<span id="id22"></span><h2><span class="section-number">2.107. </span>Pragma Max_Queue_Length<a class="headerlink" href="#pragma-max-queue-length" title="Permalink to this headline">¶</a></h2>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pragma</span> <span class="n">Max_Entry_Queue</span> <span class="p">(</span><span class="n">static_integer_EXPRESSION</span><span class="p">);</span>
</pre></div>
</div>
<p>This pragma is used to specify the maximum callers per entry queue for
individual protected entries and entry families. It accepts a single
integer (-1 or more) as a parameter and must appear after the declaration of an
entry.</p>
<p>A value of -1 represents no additional restriction on queue length.</p>
</div>
<div class="section" id="pragma-no-body">
<h2><span class="section-number">2.108. </span>Pragma No_Body<a class="headerlink" href="#pragma-no-body" title="Permalink to this headline">¶</a></h2>
<p>Syntax:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma</span><span class="p"> </span><span class="n">No_Body</span><span class="p">;</span>
</pre></div>
</div>
<p>There are a number of cases in which a package spec does not require a body,
and in fact a body is not permitted. GNAT will not permit the spec to be
compiled if there is a body around. The pragma No_Body allows you to provide
a body file, even in a case where no body is allowed. The body file must
contain only comments and a single No_Body pragma. This is recognized by
the compiler as indicating that no body is logically present.</p>
<p>This is particularly useful during maintenance when a package is modified in
such a way that a body needed before is no longer needed. The provision of a
dummy body with a No_Body pragma ensures that there is no interference from
earlier versions of the package body.</p>
</div>
<div class="section" id="pragma-no-caching">
<span id="id23"></span><h2><span class="section-number">2.109. </span>Pragma No_Caching<a class="headerlink" href="#pragma-no-caching" title="Permalink to this headline">¶</a></h2>
<p>Syntax:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma</span><span class="p"> </span><span class="n">No_Caching</span> [ <span class="o">(</span><span class="n">boolean_EXPRESSION</span><span class="o">)</span> ]<span class="p">;</span>
</pre></div>
</div>
<p>For the semantics of this pragma, see the entry for aspect <code class="docutils literal notranslate"><span class="pre">No_Caching</span></code> in
the SPARK 2014 Reference Manual, section 7.1.2.</p>
</div>
<div class="section" id="pragma-no-component-reordering">
<h2><span class="section-number">2.110. </span>Pragma No_Component_Reordering<a class="headerlink" href="#pragma-no-component-reordering" title="Permalink to this headline">¶</a></h2>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pragma</span> <span class="n">No_Component_Reordering</span> <span class="p">[([</span><span class="n">Entity</span> <span class="o">=&gt;</span><span class="p">]</span> <span class="n">type_LOCAL_NAME</span><span class="p">)];</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">type_LOCAL_NAME</span></code> must refer to a record type declaration in the current
declarative part. The effect is to preclude any reordering of components
for the layout of the record, i.e. the record is laid out by the compiler
in the order in which the components are declared textually. The form with
no argument is a configuration pragma which applies to all record types
declared in units to which the pragma applies and there is a requirement
that this pragma be used consistently within a partition.</p>
</div>
<div class="section" id="pragma-no-elaboration-code-all">
<span id="id24"></span><h2><span class="section-number">2.111. </span>Pragma No_Elaboration_Code_All<a class="headerlink" href="#pragma-no-elaboration-code-all" title="Permalink to this headline">¶</a></h2>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pragma</span> <span class="n">No_Elaboration_Code_All</span> <span class="p">[(</span><span class="n">program_unit_NAME</span><span class="p">)];</span>
</pre></div>
</div>
<p>This is a program unit pragma (there is also an equivalent aspect of the
same name) that establishes the restriction <code class="docutils literal notranslate"><span class="pre">No_Elaboration_Code</span></code> for
the current unit and any extended main source units (body and subunits).
It also has the effect of enforcing a transitive application of this
aspect, so that if any unit is implicitly or explicitly with’ed by the
current unit, it must also have the No_Elaboration_Code_All aspect set.
It may be applied to package or subprogram specs or their generic versions.</p>
</div>
<div class="section" id="pragma-no-heap-finalization">
<h2><span class="section-number">2.112. </span>Pragma No_Heap_Finalization<a class="headerlink" href="#pragma-no-heap-finalization" title="Permalink to this headline">¶</a></h2>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pragma</span> <span class="n">No_Heap_Finalization</span> <span class="p">[</span> <span class="p">(</span><span class="n">first_subtype_LOCAL_NAME</span><span class="p">)</span> <span class="p">];</span>
</pre></div>
</div>
<p>Pragma <code class="docutils literal notranslate"><span class="pre">No_Heap_Finalization</span></code> may be used as a configuration pragma or as a
type-specific pragma.</p>
<p>In its configuration form, the pragma must appear within a configuration file
such as gnat.adc, without an argument. The pragma suppresses the call to
<code class="docutils literal notranslate"><span class="pre">Finalize</span></code> for heap-allocated objects created through library-level named
access-to-object types in cases where the designated type requires finalization
actions.</p>
<p>In its type-specific form, the argument of the pragma must denote a
library-level named access-to-object type. The pragma suppresses the call to
<code class="docutils literal notranslate"><span class="pre">Finalize</span></code> for heap-allocated objects created through the specific access type
in cases where the designated type requires finalization actions.</p>
<p>It is still possible to finalize such heap-allocated objects by explicitly
deallocating them.</p>
<p>A library-level named access-to-object type declared within a generic unit will
lose its <code class="docutils literal notranslate"><span class="pre">No_Heap_Finalization</span></code> pragma when the corresponding instance does not
appear at the library level.</p>
</div>
<div class="section" id="pragma-no-inline">
<span id="id25"></span><h2><span class="section-number">2.113. </span>Pragma No_Inline<a class="headerlink" href="#pragma-no-inline" title="Permalink to this headline">¶</a></h2>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pragma</span> <span class="n">No_Inline</span> <span class="p">(</span><span class="n">NAME</span> <span class="p">{,</span> <span class="n">NAME</span><span class="p">});</span>
</pre></div>
</div>
<p>This pragma suppresses inlining for the callable entity or the instances of
the generic subprogram designated by <code class="docutils literal notranslate"><span class="pre">NAME</span></code>, including inlining that
results from the use of pragma <code class="docutils literal notranslate"><span class="pre">Inline</span></code>.  This pragma is always active,
in particular it is not subject to the use of option <em>-gnatn</em> or
<em>-gnatN</em>.  It is illegal to specify both pragma <code class="docutils literal notranslate"><span class="pre">No_Inline</span></code> and
pragma <code class="docutils literal notranslate"><span class="pre">Inline_Always</span></code> for the same <code class="docutils literal notranslate"><span class="pre">NAME</span></code>.</p>
</div>
<div class="section" id="pragma-no-return">
<h2><span class="section-number">2.114. </span>Pragma No_Return<a class="headerlink" href="#pragma-no-return" title="Permalink to this headline">¶</a></h2>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pragma</span> <span class="n">No_Return</span> <span class="p">(</span><span class="n">procedure_LOCAL_NAME</span> <span class="p">{,</span> <span class="n">procedure_LOCAL_NAME</span><span class="p">});</span>
</pre></div>
</div>
<p>Each <code class="docutils literal notranslate"><span class="pre">procedure_LOCAL_NAME</span></code> argument must refer to one or more procedure
declarations in the current declarative part.  A procedure to which this
pragma is applied may not contain any explicit <code class="docutils literal notranslate"><span class="pre">return</span></code> statements.
In addition, if the procedure contains any implicit returns from falling
off the end of a statement sequence, then execution of that implicit
return will cause Program_Error to be raised.</p>
<p>One use of this pragma is to identify procedures whose only purpose is to raise
an exception. Another use of this pragma is to suppress incorrect warnings
about missing returns in functions, where the last statement of a function
statement sequence is a call to such a procedure.</p>
<p>Note that in Ada 2005 mode, this pragma is part of the language. It is
available in all earlier versions of Ada as an implementation-defined
pragma.</p>
</div>
<div class="section" id="pragma-no-strict-aliasing">
<h2><span class="section-number">2.115. </span>Pragma No_Strict_Aliasing<a class="headerlink" href="#pragma-no-strict-aliasing" title="Permalink to this headline">¶</a></h2>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pragma</span> <span class="n">No_Strict_Aliasing</span> <span class="p">[([</span><span class="n">Entity</span> <span class="o">=&gt;</span><span class="p">]</span> <span class="n">type_LOCAL_NAME</span><span class="p">)];</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">type_LOCAL_NAME</span></code> must refer to an access type
declaration in the current declarative part.  The effect is to inhibit
strict aliasing optimization for the given type.  The form with no
arguments is a configuration pragma which applies to all access types
declared in units to which the pragma applies. For a detailed
description of the strict aliasing optimization, and the situations
in which it must be suppressed, see the section on Optimization and Strict Aliasing
in the <cite>GNAT User’s Guide</cite>.</p>
<p>This pragma currently has no effects on access to unconstrained array types.</p>
</div>
<div class="section" id="pragma-no-tagged-streams">
<span id="id26"></span><h2><span class="section-number">2.116. </span>Pragma No_Tagged_Streams<a class="headerlink" href="#pragma-no-tagged-streams" title="Permalink to this headline">¶</a></h2>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pragma</span> <span class="n">No_Tagged_Streams</span> <span class="p">[([</span><span class="n">Entity</span> <span class="o">=&gt;</span><span class="p">]</span> <span class="n">tagged_type_LOCAL_NAME</span><span class="p">)];</span>
</pre></div>
</div>
<p>Normally when a tagged type is introduced using a full type declaration,
part of the processing includes generating stream access routines to be
used by stream attributes referencing the type (or one of its subtypes
or derived types). This can involve the generation of significant amounts
of code which is wasted space if stream routines are not needed for the
type in question.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">No_Tagged_Streams</span></code> pragma causes the generation of these stream
routines to be skipped, and any attempt to use stream operations on
types subject to this pragma will be statically rejected as illegal.</p>
<p>There are two forms of the pragma. The form with no arguments must appear
in a declarative sequence or in the declarations of a package spec. This
pragma affects all subsequent root tagged types declared in the declaration
sequence, and specifies that no stream routines be generated. The form with
an argument (for which there is also a corresponding aspect) specifies a
single root tagged type for which stream routines are not to be generated.</p>
<p>Once the pragma has been given for a particular root tagged type, all subtypes
and derived types of this type inherit the pragma automatically, so the effect
applies to a complete hierarchy (this is necessary to deal with the class-wide
dispatching versions of the stream routines).</p>
<p>When pragmas <code class="docutils literal notranslate"><span class="pre">Discard_Names</span></code> and <code class="docutils literal notranslate"><span class="pre">No_Tagged_Streams</span></code> are simultaneously
applied to a tagged type its Expanded_Name and External_Tag are initialized
with empty strings. This is useful to avoid exposing entity names at binary
level but has a negative impact on the debuggability of tagged types.</p>
</div>
<div class="section" id="pragma-normalize-scalars">
<h2><span class="section-number">2.117. </span>Pragma Normalize_Scalars<a class="headerlink" href="#pragma-normalize-scalars" title="Permalink to this headline">¶</a></h2>
<p>Syntax:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma</span><span class="p"> </span><span class="n">Normalize_Scalars</span><span class="p">;</span>
</pre></div>
</div>
<p>This is a language defined pragma which is fully implemented in GNAT.  The
effect is to cause all scalar objects that are not otherwise initialized
to be initialized.  The initial values are implementation dependent and
are as follows:</p>
<dl>
<dt><em>Standard.Character</em></dt><dd><p>Objects whose root type is Standard.Character are initialized to
Character’Last unless the subtype range excludes NUL (in which case
NUL is used). This choice will always generate an invalid value if
one exists.</p>
</dd>
<dt><em>Standard.Wide_Character</em></dt><dd><p>Objects whose root type is Standard.Wide_Character are initialized to
Wide_Character’Last unless the subtype range excludes NUL (in which case
NUL is used). This choice will always generate an invalid value if
one exists.</p>
</dd>
<dt><em>Standard.Wide_Wide_Character</em></dt><dd><p>Objects whose root type is Standard.Wide_Wide_Character are initialized to
the invalid value 16#FFFF_FFFF# unless the subtype range excludes NUL (in
which case NUL is used). This choice will always generate an invalid value if
one exists.</p>
</dd>
<dt><em>Integer types</em></dt><dd><p>Objects of an integer type are treated differently depending on whether
negative values are present in the subtype. If no negative values are
present, then all one bits is used as the initial value except in the
special case where zero is excluded from the subtype, in which case
all zero bits are used. This choice will always generate an invalid
value if one exists.</p>
<p>For subtypes with negative values present, the largest negative number
is used, except in the unusual case where this largest negative number
is in the subtype, and the largest positive number is not, in which case
the largest positive value is used. This choice will always generate
an invalid value if one exists.</p>
</dd>
<dt><em>Floating-Point Types</em></dt><dd><p>Objects of all floating-point types are initialized to all 1-bits. For
standard IEEE format, this corresponds to a NaN (not a number) which is
indeed an invalid value.</p>
</dd>
<dt><em>Fixed-Point Types</em></dt><dd><p>Objects of all fixed-point types are treated as described above for integers,
with the rules applying to the underlying integer value used to represent
the fixed-point value.</p>
</dd>
<dt><em>Modular types</em></dt><dd><p>Objects of a modular type are initialized to all one bits, except in
the special case where zero is excluded from the subtype, in which
case all zero bits are used. This choice will always generate an
invalid value if one exists.</p>
</dd>
<dt><em>Enumeration types</em></dt><dd><p>Objects of an enumeration type are initialized to all one-bits, i.e., to
the value <code class="docutils literal notranslate"><span class="pre">2</span> <span class="pre">**</span> <span class="pre">typ'Size</span> <span class="pre">-</span> <span class="pre">1</span></code> unless the subtype excludes the literal
whose Pos value is zero, in which case a code of zero is used. This choice
will always generate an invalid value if one exists.</p>
</dd>
</dl>
</div>
<div class="section" id="pragma-obsolescent">
<span id="id27"></span><h2><span class="section-number">2.118. </span>Pragma Obsolescent<a class="headerlink" href="#pragma-obsolescent" title="Permalink to this headline">¶</a></h2>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pragma</span> <span class="n">Obsolescent</span><span class="p">;</span>

<span class="n">pragma</span> <span class="n">Obsolescent</span> <span class="p">(</span>
  <span class="p">[</span><span class="n">Message</span> <span class="o">=&gt;</span><span class="p">]</span> <span class="n">static_string_EXPRESSION</span>
<span class="p">[,[</span><span class="n">Version</span> <span class="o">=&gt;</span><span class="p">]</span> <span class="n">Ada_05</span><span class="p">]]);</span>

<span class="n">pragma</span> <span class="n">Obsolescent</span> <span class="p">(</span>
  <span class="p">[</span><span class="n">Entity</span>  <span class="o">=&gt;</span><span class="p">]</span> <span class="n">NAME</span>
<span class="p">[,[</span><span class="n">Message</span> <span class="o">=&gt;</span><span class="p">]</span> <span class="n">static_string_EXPRESSION</span>
<span class="p">[,[</span><span class="n">Version</span> <span class="o">=&gt;</span><span class="p">]</span> <span class="n">Ada_05</span><span class="p">]]</span> <span class="p">);</span>
</pre></div>
</div>
<p>This pragma can occur immediately following a declaration of an entity,
including the case of a record component. If no Entity argument is present,
then this declaration is the one to which the pragma applies. If an Entity
parameter is present, it must either match the name of the entity in this
declaration, or alternatively, the pragma can immediately follow an enumeration
type declaration, where the Entity argument names one of the enumeration
literals.</p>
<p>This pragma is used to indicate that the named entity
is considered obsolescent and should not be used. Typically this is
used when an API must be modified by eventually removing or modifying
existing subprograms or other entities. The pragma can be used at an
intermediate stage when the entity is still present, but will be
removed later.</p>
<p>The effect of this pragma is to output a warning message on a reference to
an entity thus marked that the subprogram is obsolescent if the appropriate
warning option in the compiler is activated. If the <code class="docutils literal notranslate"><span class="pre">Message</span></code> parameter is
present, then a second warning message is given containing this text. In
addition, a reference to the entity is considered to be a violation of pragma
<code class="docutils literal notranslate"><span class="pre">Restrictions</span> <span class="pre">(No_Obsolescent_Features)</span></code>.</p>
<p>This pragma can also be used as a program unit pragma for a package,
in which case the entity name is the name of the package, and the
pragma indicates that the entire package is considered
obsolescent. In this case a client <code class="docutils literal notranslate"><span class="pre">with</span></code>ing such a package
violates the restriction, and the <code class="docutils literal notranslate"><span class="pre">with</span></code> clause is
flagged with warnings if the warning option is set.</p>
<p>If the <code class="docutils literal notranslate"><span class="pre">Version</span></code> parameter is present (which must be exactly
the identifier <code class="docutils literal notranslate"><span class="pre">Ada_05</span></code>, no other argument is allowed), then the
indication of obsolescence applies only when compiling in Ada 2005
mode. This is primarily intended for dealing with the situations
in the predefined library where subprograms or packages
have become defined as obsolescent in Ada 2005
(e.g., in <code class="docutils literal notranslate"><span class="pre">Ada.Characters.Handling</span></code>), but may be used anywhere.</p>
<p>The following examples show typical uses of this pragma:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="k">package </span><span class="nf">p</span> <span class="kr">is</span><span class="p"></span>
   <span class="kr">pragma</span><span class="p"> </span><span class="n">Obsolescent</span> <span class="o">(</span><span class="n">p</span><span class="p">,</span> <span class="n">Message</span> <span class="o">=&gt;</span> <span class="s">&quot;use pp instead of p&quot;</span><span class="o">)</span><span class="p">;</span>
<span class="k">end </span><span class="nf">p</span><span class="p">;</span>

<span class="k">package </span><span class="nf">q</span> <span class="kr">is</span><span class="p"></span>
   <span class="k">procedure </span><span class="nf">q2</span><span class="p">;</span>
   <span class="kr">pragma</span><span class="p"> </span><span class="n">Obsolescent</span> <span class="o">(</span><span class="s">&quot;use q2new instead&quot;</span><span class="o">)</span><span class="p">;</span>

   <span class="kr">type</span><span class="p"> </span><span class="n">R</span> <span class="kr">is</span><span class="p"> </span><span class="kr">new</span><span class="p"> </span><span class="n">integer</span><span class="p">;</span>
   <span class="kr">pragma</span><span class="p"> </span><span class="n">Obsolescent</span>
     <span class="o">(</span><span class="n">Entity</span>  <span class="o">=&gt;</span> <span class="n">R</span><span class="p">,</span>
      <span class="n">Message</span> <span class="o">=&gt;</span> <span class="s">&quot;use RR in Ada 2005&quot;</span><span class="p">,</span>
      <span class="n">Version</span> <span class="o">=&gt;</span> <span class="n">Ada_05</span><span class="o">)</span><span class="p">;</span>

   <span class="kr">type</span><span class="p"> </span><span class="n">M</span> <span class="kr">is</span><span class="p"> </span><span class="kr">record</span><span class="p"></span>
      <span class="n">F1</span> <span class="o">:</span> <span class="n">Integer</span><span class="p">;</span>
      <span class="n">F2</span> <span class="o">:</span> <span class="n">Integer</span><span class="p">;</span>
      <span class="kr">pragma</span><span class="p"> </span><span class="n">Obsolescent</span><span class="p">;</span>
      <span class="n">F3</span> <span class="o">:</span> <span class="n">Integer</span><span class="p">;</span>
   <span class="k">end record</span><span class="p">;</span>

   <span class="kr">type</span><span class="p"> </span><span class="n">E</span> <span class="kr">is</span><span class="p"> </span><span class="o">(</span><span class="n">a</span><span class="p">,</span> <span class="n">bc</span><span class="p">,</span> <span class="sc">&#39;d&#39;</span><span class="p">,</span> <span class="n">quack</span><span class="o">)</span><span class="p">;</span>
   <span class="kr">pragma</span><span class="p"> </span><span class="n">Obsolescent</span> <span class="o">(</span><span class="n">Entity</span> <span class="o">=&gt;</span> <span class="n">bc</span><span class="o">)</span>
   <span class="kr">pragma</span><span class="p"> </span><span class="n">Obsolescent</span> <span class="o">(</span><span class="n">Entity</span> <span class="o">=&gt;</span> <span class="sc">&#39;d&#39;</span><span class="o">)</span>

   <span class="kr">function</span><span class="p"> </span><span class="s">&quot;+&quot;</span>
     <span class="o">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">:</span> <span class="n">character</span><span class="o">)</span> <span class="kr">return</span><span class="p"> </span><span class="n">character</span><span class="p">;</span>
   <span class="kr">pragma</span><span class="p"> </span><span class="n">Obsolescent</span> <span class="o">(</span><span class="n">Entity</span> <span class="o">=&gt;</span> <span class="s">&quot;+&quot;</span><span class="o">)</span><span class="p">;</span>
<span class="kr">end</span><span class="p">;</span>
</pre></div>
</div>
<p>Note that, as for all pragmas, if you use a pragma argument identifier,
then all subsequent parameters must also use a pragma argument identifier.
So if you specify <code class="docutils literal notranslate"><span class="pre">Entity</span> <span class="pre">=&gt;</span></code> for the <code class="docutils literal notranslate"><span class="pre">Entity</span></code> argument, and a <code class="docutils literal notranslate"><span class="pre">Message</span></code>
argument is present, it must be preceded by <code class="docutils literal notranslate"><span class="pre">Message</span> <span class="pre">=&gt;</span></code>.</p>
</div>
<div class="section" id="pragma-optimize-alignment">
<h2><span class="section-number">2.119. </span>Pragma Optimize_Alignment<a class="headerlink" href="#pragma-optimize-alignment" title="Permalink to this headline">¶</a></h2>
<p id="index-47">Syntax:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma</span><span class="p"> </span><span class="n">Optimize_Alignment</span> <span class="o">(</span><span class="n">TIME</span> <span class="o">|</span> <span class="n">SPACE</span> <span class="o">|</span> <span class="n">OFF</span><span class="o">)</span><span class="p">;</span>
</pre></div>
</div>
<p>This is a configuration pragma which affects the choice of default alignments
for types and objects where no alignment is explicitly specified. There is a
time/space trade-off in the selection of these values. Large alignments result
in more efficient code, at the expense of larger data space, since sizes have
to be increased to match these alignments. Smaller alignments save space, but
the access code is slower. The normal choice of default alignments for types
and individual alignment promotions for objects (which is what you get if you
do not use this pragma, or if you use an argument of OFF), tries to balance
these two requirements.</p>
<p>Specifying SPACE causes smaller default alignments to be chosen in two cases.
First any packed record is given an alignment of 1. Second, if a size is given
for the type, then the alignment is chosen to avoid increasing this size. For
example, consider:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">type</span><span class="p"> </span><span class="n">R</span> <span class="kr">is</span><span class="p"> </span><span class="kr">record</span><span class="p"></span>
   <span class="n">X</span> <span class="o">:</span> <span class="n">Integer</span><span class="p">;</span>
   <span class="n">Y</span> <span class="o">:</span> <span class="n">Character</span><span class="p">;</span>
<span class="k">end record</span><span class="p">;</span>

<span class="kr">for</span><span class="p"> </span><span class="n">R</span><span class="na">&#39;Size</span> <span class="kr">use</span><span class="p"> </span><span class="mi">5</span><span class="o">*</span><span class="mi">8</span><span class="p">;</span>
</pre></div>
</div>
<p>In the default mode, this type gets an alignment of 4, so that access to the
Integer field X are efficient. But this means that objects of the type end up
with a size of 8 bytes. This is a valid choice, since sizes of objects are
allowed to be bigger than the size of the type, but it can waste space if for
example fields of type R appear in an enclosing record. If the above type is
compiled in <code class="docutils literal notranslate"><span class="pre">Optimize_Alignment</span> <span class="pre">(Space)</span></code> mode, the alignment is set to 1.</p>
<p>However, there is one case in which SPACE is ignored. If a variable length
record (that is a discriminated record with a component which is an array
whose length depends on a discriminant), has a pragma Pack, then it is not
in general possible to set the alignment of such a record to one, so the
pragma is ignored in this case (with a warning).</p>
<p>Specifying SPACE also disables alignment promotions for standalone objects,
which occur when the compiler increases the alignment of a specific object
without changing the alignment of its type.</p>
<p>Specifying SPACE also disables component reordering in unpacked record types,
which can result in larger sizes in order to meet alignment requirements.</p>
<p>Specifying TIME causes larger default alignments to be chosen in the case of
small types with sizes that are not a power of 2. For example, consider:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">type</span><span class="p"> </span><span class="n">R</span> <span class="kr">is</span><span class="p"> </span><span class="kr">record</span><span class="p"></span>
   <span class="n">A</span> <span class="o">:</span> <span class="n">Character</span><span class="p">;</span>
   <span class="n">B</span> <span class="o">:</span> <span class="n">Character</span><span class="p">;</span>
   <span class="n">C</span> <span class="o">:</span> <span class="n">Boolean</span><span class="p">;</span>
<span class="k">end record</span><span class="p">;</span>

<span class="kr">pragma</span><span class="p"> </span><span class="n">Pack</span> <span class="o">(</span><span class="n">R</span><span class="o">)</span><span class="p">;</span>
<span class="kr">for</span><span class="p"> </span><span class="n">R</span><span class="na">&#39;Size</span> <span class="kr">use</span><span class="p"> </span><span class="mi">17</span><span class="p">;</span>
</pre></div>
</div>
<p>The default alignment for this record is normally 1, but if this type is
compiled in <code class="docutils literal notranslate"><span class="pre">Optimize_Alignment</span> <span class="pre">(Time)</span></code> mode, then the alignment is set
to 4, which wastes space for objects of the type, since they are now 4 bytes
long, but results in more efficient access when the whole record is referenced.</p>
<p>As noted above, this is a configuration pragma, and there is a requirement
that all units in a partition be compiled with a consistent setting of the
optimization setting. This would normally be achieved by use of a configuration
pragma file containing the appropriate setting. The exception to this rule is
that units with an explicit configuration pragma in the same file as the source
unit are excluded from the consistency check, as are all predefined units. The
latter are compiled by default in pragma Optimize_Alignment (Off) mode if no
pragma appears at the start of the file.</p>
</div>
<div class="section" id="pragma-ordered">
<h2><span class="section-number">2.120. </span>Pragma Ordered<a class="headerlink" href="#pragma-ordered" title="Permalink to this headline">¶</a></h2>
<p>Syntax:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma</span><span class="p"> </span><span class="n">Ordered</span> <span class="o">(</span><span class="n">enumeration_first_subtype_LOCAL_NAME</span><span class="o">)</span><span class="p">;</span>
</pre></div>
</div>
<p>Most enumeration types are from a conceptual point of view unordered.
For example, consider:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">type</span><span class="p"> </span><span class="n">Color</span> <span class="kr">is</span><span class="p"> </span><span class="o">(</span><span class="n">Red</span><span class="p">,</span> <span class="n">Blue</span><span class="p">,</span> <span class="n">Green</span><span class="p">,</span> <span class="n">Yellow</span><span class="o">)</span><span class="p">;</span>
</pre></div>
</div>
<p>By Ada semantics <code class="docutils literal notranslate"><span class="pre">Blue</span> <span class="pre">&gt;</span> <span class="pre">Red</span></code> and <code class="docutils literal notranslate"><span class="pre">Green</span> <span class="pre">&gt;</span> <span class="pre">Blue</span></code>,
but really these relations make no sense; the enumeration type merely
specifies a set of possible colors, and the order is unimportant.</p>
<p>For unordered enumeration types, it is generally a good idea if
clients avoid comparisons (other than equality or inequality) and
explicit ranges. (A <em>client</em> is a unit where the type is referenced,
other than the unit where the type is declared, its body, and its subunits.)
For example, if code buried in some client says:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">if</span><span class="p"> </span><span class="n">Current_Color</span> <span class="o">&lt;</span> <span class="n">Yellow</span> <span class="kr">then</span><span class="p"> </span><span class="o">...</span>
<span class="kr">if</span><span class="p"> </span><span class="n">Current_Color</span> <span class="kr">in</span><span class="p"> </span><span class="n">Blue</span> <span class="o">..</span> <span class="n">Green</span> <span class="kr">then</span><span class="p"> </span><span class="o">...</span>
</pre></div>
</div>
<p>then the client code is relying on the order, which is undesirable.
It makes the code hard to read and creates maintenance difficulties if
entries have to be added to the enumeration type. Instead,
the code in the client should list the possibilities, or an
appropriate subtype should be declared in the unit that declares
the original enumeration type. E.g., the following subtype could
be declared along with the type <code class="docutils literal notranslate"><span class="pre">Color</span></code>:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">subtype</span><span class="p"> </span><span class="n">RBG</span> <span class="kr">is</span><span class="p"> </span><span class="n">Color</span> <span class="kr">range</span><span class="p"> </span><span class="n">Red</span> <span class="o">..</span> <span class="n">Green</span><span class="p">;</span>
</pre></div>
</div>
<p>and then the client could write:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">if</span><span class="p"> </span><span class="n">Current_Color</span> <span class="kr">in</span><span class="p"> </span><span class="n">RBG</span> <span class="kr">then</span><span class="p"> </span><span class="o">...</span>
<span class="kr">if</span><span class="p"> </span><span class="n">Current_Color</span> <span class="o">=</span> <span class="n">Blue</span> <span class="kr">or</span><span class="p"> </span><span class="n">Current_Color</span> <span class="o">=</span> <span class="n">Green</span> <span class="kr">then</span><span class="p"> </span><span class="o">...</span>
</pre></div>
</div>
<p>However, some enumeration types are legitimately ordered from a conceptual
point of view. For example, if you declare:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">type</span><span class="p"> </span><span class="n">Day</span> <span class="kr">is</span><span class="p"> </span><span class="o">(</span><span class="n">Mon</span><span class="p">,</span> <span class="n">Tue</span><span class="p">,</span> <span class="n">Wed</span><span class="p">,</span> <span class="n">Thu</span><span class="p">,</span> <span class="n">Fri</span><span class="p">,</span> <span class="n">Sat</span><span class="p">,</span> <span class="n">Sun</span><span class="o">)</span><span class="p">;</span>
</pre></div>
</div>
<p>then the ordering imposed by the language is reasonable, and
clients can depend on it, writing for example:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">if</span><span class="p"> </span><span class="n">D</span> <span class="kr">in</span><span class="p"> </span><span class="n">Mon</span> <span class="o">..</span> <span class="n">Fri</span> <span class="kr">then</span><span class="p"> </span><span class="o">...</span>
<span class="kr">if</span><span class="p"> </span><span class="n">D</span> <span class="o">&lt;</span> <span class="n">Wed</span> <span class="kr">then</span><span class="p"> </span><span class="o">...</span>
</pre></div>
</div>
<p>The pragma <em>Ordered</em> is provided to mark enumeration types that
are conceptually ordered, alerting the reader that clients may depend
on the ordering. GNAT provides a pragma to mark enumerations as ordered
rather than one to mark them as unordered, since in our experience,
the great majority of enumeration types are conceptually unordered.</p>
<p>The types <code class="docutils literal notranslate"><span class="pre">Boolean</span></code>, <code class="docutils literal notranslate"><span class="pre">Character</span></code>, <code class="docutils literal notranslate"><span class="pre">Wide_Character</span></code>,
and <code class="docutils literal notranslate"><span class="pre">Wide_Wide_Character</span></code>
are considered to be ordered types, so each is declared with a
pragma <code class="docutils literal notranslate"><span class="pre">Ordered</span></code> in package <code class="docutils literal notranslate"><span class="pre">Standard</span></code>.</p>
<p>Normally pragma <code class="docutils literal notranslate"><span class="pre">Ordered</span></code> serves only as documentation and a guide for
coding standards, but GNAT provides a warning switch <em>-gnatw.u</em> that
requests warnings for inappropriate uses (comparisons and explicit
subranges) for unordered types. If this switch is used, then any
enumeration type not marked with pragma <code class="docutils literal notranslate"><span class="pre">Ordered</span></code> will be considered
as unordered, and will generate warnings for inappropriate uses.</p>
<p>Note that generic types are not considered ordered or unordered (since the
template can be instantiated for both cases), so we never generate warnings
for the case of generic enumerated types.</p>
<p>For additional information please refer to the description of the
<em>-gnatw.u</em> switch in the GNAT User’s Guide.</p>
</div>
<div class="section" id="pragma-overflow-mode">
<h2><span class="section-number">2.121. </span>Pragma Overflow_Mode<a class="headerlink" href="#pragma-overflow-mode" title="Permalink to this headline">¶</a></h2>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pragma</span> <span class="n">Overflow_Mode</span>
 <span class="p">(</span>  <span class="p">[</span><span class="n">General</span>    <span class="o">=&gt;</span><span class="p">]</span> <span class="n">MODE</span>
  <span class="p">[,[</span><span class="n">Assertions</span> <span class="o">=&gt;</span><span class="p">]</span> <span class="n">MODE</span><span class="p">]);</span>

<span class="n">MODE</span> <span class="p">:</span><span class="o">:=</span> <span class="n">STRICT</span> <span class="o">|</span> <span class="n">MINIMIZED</span> <span class="o">|</span> <span class="n">ELIMINATED</span>
</pre></div>
</div>
<p>This pragma sets the current overflow mode to the given setting. For details
of the meaning of these modes, please refer to the
‘Overflow Check Handling in GNAT’ appendix in the
GNAT User’s Guide. If only the <code class="docutils literal notranslate"><span class="pre">General</span></code> parameter is present,
the given mode applies to all expressions. If both parameters are present,
the <code class="docutils literal notranslate"><span class="pre">General</span></code> mode applies to expressions outside assertions, and
the <code class="docutils literal notranslate"><span class="pre">Eliminated</span></code> mode applies to expressions within assertions.</p>
<p>The case of the <code class="docutils literal notranslate"><span class="pre">MODE</span></code> parameter is ignored,
so <code class="docutils literal notranslate"><span class="pre">MINIMIZED</span></code>, <code class="docutils literal notranslate"><span class="pre">Minimized</span></code> and
<code class="docutils literal notranslate"><span class="pre">minimized</span></code> all have the same effect.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">Overflow_Mode</span></code> pragma has the same scoping and placement
rules as pragma <code class="docutils literal notranslate"><span class="pre">Suppress</span></code>, so it can occur either as a
configuration pragma, specifying a default for the whole
program, or in a declarative scope, where it applies to the
remaining declarations and statements in that scope.</p>
<p>The pragma <code class="docutils literal notranslate"><span class="pre">Suppress</span> <span class="pre">(Overflow_Check)</span></code> suppresses
overflow checking, but does not affect the overflow mode.</p>
<p>The pragma <code class="docutils literal notranslate"><span class="pre">Unsuppress</span> <span class="pre">(Overflow_Check)</span></code> unsuppresses (enables)
overflow checking, but does not affect the overflow mode.</p>
</div>
<div class="section" id="pragma-overriding-renamings">
<h2><span class="section-number">2.122. </span>Pragma Overriding_Renamings<a class="headerlink" href="#pragma-overriding-renamings" title="Permalink to this headline">¶</a></h2>
<span class="target" id="index-48"></span><p id="index-49">Syntax:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma</span><span class="p"> </span><span class="n">Overriding_Renamings</span><span class="p">;</span>
</pre></div>
</div>
<p>This is a GNAT configuration pragma to simplify porting
legacy code accepted by the Rational
Ada compiler. In the presence of this pragma, a renaming declaration that
renames an inherited operation declared in the same scope is legal if selected
notation is used as in:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma</span><span class="p"> </span><span class="n">Overriding_Renamings</span><span class="p">;</span>
<span class="o">...</span>
<span class="k">package </span><span class="nf">R</span> <span class="kr">is</span><span class="p"></span>
  <span class="k">function </span><span class="nf">F</span> <span class="o">(..)</span><span class="p">;</span>
  <span class="o">...</span>
  <span class="k">function </span><span class="nf">F</span> <span class="o">(..)</span> <span class="kr">renames</span><span class="p"> </span><span class="n">R.F</span><span class="p">;</span>
<span class="k">end </span><span class="nf">R</span><span class="p">;</span>
</pre></div>
</div>
<p>even though
RM 8.3 (15) stipulates that an overridden operation is not visible within the
declaration of the overriding operation.</p>
</div>
<div class="section" id="pragma-partition-elaboration-policy">
<h2><span class="section-number">2.123. </span>Pragma Partition_Elaboration_Policy<a class="headerlink" href="#pragma-partition-elaboration-policy" title="Permalink to this headline">¶</a></h2>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pragma</span> <span class="n">Partition_Elaboration_Policy</span> <span class="p">(</span><span class="n">POLICY_IDENTIFIER</span><span class="p">);</span>

<span class="n">POLICY_IDENTIFIER</span> <span class="p">:</span><span class="o">:=</span> <span class="n">Concurrent</span> <span class="o">|</span> <span class="n">Sequential</span>
</pre></div>
</div>
<p>This pragma is standard in Ada 2005, but is available in all earlier
versions of Ada as an implementation-defined pragma.
See Ada 2012 Reference Manual for details.</p>
</div>
<div class="section" id="pragma-part-of">
<span id="id28"></span><h2><span class="section-number">2.124. </span>Pragma Part_Of<a class="headerlink" href="#pragma-part-of" title="Permalink to this headline">¶</a></h2>
<p>Syntax:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma</span><span class="p"> </span><span class="n">Part_Of</span> <span class="o">(</span><span class="n">ABSTRACT_STATE</span><span class="o">)</span><span class="p">;</span>

<span class="n">ABSTRACT_STATE</span> <span class="o">::=</span> <span class="n">NAME</span>
</pre></div>
</div>
<p>For the semantics of this pragma, see the entry for aspect <code class="docutils literal notranslate"><span class="pre">Part_Of</span></code> in the
SPARK 2014 Reference Manual, section 7.2.6.</p>
</div>
<div class="section" id="pragma-passive">
<h2><span class="section-number">2.125. </span>Pragma Passive<a class="headerlink" href="#pragma-passive" title="Permalink to this headline">¶</a></h2>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pragma</span> <span class="n">Passive</span> <span class="p">[(</span><span class="n">Semaphore</span> <span class="o">|</span> <span class="n">No</span><span class="p">)];</span>
</pre></div>
</div>
<p>Syntax checked, but otherwise ignored by GNAT.  This is recognized for
compatibility with DEC Ada 83 implementations, where it is used within a
task definition to request that a task be made passive.  If the argument
<code class="docutils literal notranslate"><span class="pre">Semaphore</span></code> is present, or the argument is omitted, then DEC Ada 83
treats the pragma as an assertion that the containing task is passive
and that optimization of context switch with this task is permitted and
desired.  If the argument <code class="docutils literal notranslate"><span class="pre">No</span></code> is present, the task must not be
optimized.  GNAT does not attempt to optimize any tasks in this manner
(since protected objects are available in place of passive tasks).</p>
<p>For more information on the subject of passive tasks, see the section
‘Passive Task Optimization’ in the GNAT Users Guide.</p>
</div>
<div class="section" id="pragma-persistent-bss">
<span id="id29"></span><h2><span class="section-number">2.126. </span>Pragma Persistent_BSS<a class="headerlink" href="#pragma-persistent-bss" title="Permalink to this headline">¶</a></h2>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pragma</span> <span class="n">Persistent_BSS</span> <span class="p">[(</span><span class="n">LOCAL_NAME</span><span class="p">)]</span>
</pre></div>
</div>
<p>This pragma allows selected objects to be placed in the <code class="docutils literal notranslate"><span class="pre">.persistent_bss</span></code>
section. On some targets the linker and loader provide for special
treatment of this section, allowing a program to be reloaded without
affecting the contents of this data (hence the name persistent).</p>
<p>There are two forms of usage. If an argument is given, it must be the
local name of a library-level object, with no explicit initialization
and whose type is potentially persistent. If no argument is given, then
the pragma is a configuration pragma, and applies to all library-level
objects with no explicit initialization of potentially persistent types.</p>
<p>A potentially persistent type is a scalar type, or an untagged,
non-discriminated record, all of whose components have no explicit
initialization and are themselves of a potentially persistent type,
or an array, all of whose constraints are static, and whose component
type is potentially persistent.</p>
<p>If this pragma is used on a target where this feature is not supported,
then the pragma will be ignored. See also <code class="docutils literal notranslate"><span class="pre">pragma</span> <span class="pre">Linker_Section</span></code>.</p>
</div>
<div class="section" id="pragma-post">
<h2><span class="section-number">2.127. </span>Pragma Post<a class="headerlink" href="#pragma-post" title="Permalink to this headline">¶</a></h2>
<span class="target" id="index-50"></span><p id="index-51">Syntax:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma</span><span class="p"> </span><span class="n">Post</span> <span class="o">(</span><span class="n">Boolean_Expression</span><span class="o">)</span><span class="p">;</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">Post</span></code> pragma is intended to be an exact replacement for
the language-defined
<code class="docutils literal notranslate"><span class="pre">Post</span></code> aspect, and shares its restrictions and semantics.
It must appear either immediately following the corresponding
subprogram declaration (only other pragmas may intervene), or
if there is no separate subprogram declaration, then it can
appear at the start of the declarations in a subprogram body
(preceded only by other pragmas).</p>
</div>
<div class="section" id="pragma-postcondition">
<h2><span class="section-number">2.128. </span>Pragma Postcondition<a class="headerlink" href="#pragma-postcondition" title="Permalink to this headline">¶</a></h2>
<span class="target" id="index-52"></span><p id="index-53">Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pragma</span> <span class="n">Postcondition</span> <span class="p">(</span>
   <span class="p">[</span><span class="n">Check</span>   <span class="o">=&gt;</span><span class="p">]</span> <span class="n">Boolean_Expression</span>
 <span class="p">[,[</span><span class="n">Message</span> <span class="o">=&gt;</span><span class="p">]</span> <span class="n">String_Expression</span><span class="p">]);</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">Postcondition</span></code> pragma allows specification of automatic
postcondition checks for subprograms. These checks are similar to
assertions, but are automatically inserted just prior to the return
statements of the subprogram with which they are associated (including
implicit returns at the end of procedure bodies and associated
exception handlers).</p>
<p>In addition, the boolean expression which is the condition which
must be true may contain references to function’Result in the case
of a function to refer to the returned value.</p>
<p><code class="docutils literal notranslate"><span class="pre">Postcondition</span></code> pragmas may appear either immediately following the
(separate) declaration of a subprogram, or at the start of the
declarations of a subprogram body. Only other pragmas may intervene
(that is appear between the subprogram declaration and its
postconditions, or appear before the postcondition in the
declaration sequence in a subprogram body). In the case of a
postcondition appearing after a subprogram declaration, the
formal arguments of the subprogram are visible, and can be
referenced in the postcondition expressions.</p>
<p>The postconditions are collected and automatically tested just
before any return (implicit or explicit) in the subprogram body.
A postcondition is only recognized if postconditions are active
at the time the pragma is encountered. The compiler switch <em>gnata</em>
turns on all postconditions by default, and pragma <code class="docutils literal notranslate"><span class="pre">Check_Policy</span></code>
with an identifier of <code class="docutils literal notranslate"><span class="pre">Postcondition</span></code> can also be used to
control whether postconditions are active.</p>
<p>The general approach is that postconditions are placed in the spec
if they represent functional aspects which make sense to the client.
For example we might have:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="k">function </span><span class="nf">Direction</span> <span class="kr">return</span><span class="p"> </span><span class="n">Integer</span><span class="p">;</span>
<span class="kr">pragma</span><span class="p"> </span><span class="n">Postcondition</span>
 <span class="o">(</span><span class="n">Direction</span><span class="na">&#39;Result</span> <span class="o">=</span> <span class="o">+</span><span class="mi">1</span>
    <span class="kr">or</span><span class="p"> </span><span class="kr">else</span><span class="p"></span>
  <span class="n">Direction</span><span class="na">&#39;Result</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span><span class="p">;</span>
</pre></div>
</div>
<p>which serves to document that the result must be +1 or -1, and
will test that this is the case at run time if postcondition
checking is active.</p>
<p>Postconditions within the subprogram body can be used to
check that some internal aspect of the implementation,
not visible to the client, is operating as expected.
For instance if a square root routine keeps an internal
counter of the number of times it is called, then we
might have the following postcondition:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="n">Sqrt_Calls</span> <span class="o">:</span> <span class="n">Natural</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span>

<span class="k">function </span><span class="nf">Sqrt</span> <span class="o">(</span><span class="n">Arg</span> <span class="o">:</span> <span class="n">Float</span><span class="o">)</span> <span class="kr">return</span><span class="p"> </span><span class="n">Float</span> <span class="kr">is</span><span class="p"></span>
  <span class="kr">pragma</span><span class="p"> </span><span class="n">Postcondition</span>
    <span class="o">(</span><span class="n">Sqrt_Calls</span> <span class="o">=</span> <span class="n">Sqrt_Calls</span><span class="na">&#39;Old</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span><span class="p">;</span>
  <span class="o">...</span>
<span class="k">end </span><span class="nf">Sqrt</span>
</pre></div>
</div>
<p>As this example, shows, the use of the <code class="docutils literal notranslate"><span class="pre">Old</span></code> attribute
is often useful in postconditions to refer to the state on
entry to the subprogram.</p>
<p>Note that postconditions are only checked on normal returns
from the subprogram. If an abnormal return results from
raising an exception, then the postconditions are not checked.</p>
<p>If a postcondition fails, then the exception
<code class="docutils literal notranslate"><span class="pre">System.Assertions.Assert_Failure</span></code> is raised. If
a message argument was supplied, then the given string
will be used as the exception message. If no message
argument was supplied, then the default message has
the form “Postcondition failed at file_name:line”. The
exception is raised in the context of the subprogram
body, so it is possible to catch postcondition failures
within the subprogram body itself.</p>
<p>Within a package spec, normal visibility rules
in Ada would prevent forward references within a
postcondition pragma to functions defined later in
the same package. This would introduce undesirable
ordering constraints. To avoid this problem, all
postcondition pragmas are analyzed at the end of
the package spec, allowing forward references.</p>
<p>The following example shows that this even allows
mutually recursive postconditions as in:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="k">package </span><span class="nf">Parity_Functions</span> <span class="kr">is</span><span class="p"></span>
   <span class="k">function </span><span class="nf">Odd</span>  <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">Natural</span><span class="o">)</span> <span class="kr">return</span><span class="p"> </span><span class="n">Boolean</span><span class="p">;</span>
   <span class="kr">pragma</span><span class="p"> </span><span class="n">Postcondition</span>
     <span class="o">(</span><span class="n">Odd</span><span class="na">&#39;Result</span> <span class="o">=</span>
        <span class="o">(</span><span class="n">x</span> <span class="o">=</span> <span class="mi">1</span>
          <span class="kr">or</span><span class="p"> </span><span class="kr">else</span><span class="p"></span>
        <span class="o">(</span><span class="n">x</span> <span class="o">/=</span> <span class="mi">0</span> <span class="kr">and</span><span class="p"> </span><span class="kr">then</span><span class="p"> </span><span class="n">Even</span> <span class="o">(</span><span class="n">X</span> <span class="o">-</span> <span class="mi">1</span><span class="o">))))</span><span class="p">;</span>

   <span class="k">function </span><span class="nf">Even</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">Natural</span><span class="o">)</span> <span class="kr">return</span><span class="p"> </span><span class="n">Boolean</span><span class="p">;</span>
   <span class="kr">pragma</span><span class="p"> </span><span class="n">Postcondition</span>
     <span class="o">(</span><span class="n">Even</span><span class="na">&#39;Result</span> <span class="o">=</span>
        <span class="o">(</span><span class="n">x</span> <span class="o">=</span> <span class="mi">0</span>
          <span class="kr">or</span><span class="p"> </span><span class="kr">else</span><span class="p"></span>
        <span class="o">(</span><span class="n">x</span> <span class="o">/=</span> <span class="mi">1</span> <span class="kr">and</span><span class="p"> </span><span class="kr">then</span><span class="p"> </span><span class="n">Odd</span> <span class="o">(</span><span class="n">X</span> <span class="o">-</span> <span class="mi">1</span><span class="o">))))</span><span class="p">;</span>

<span class="k">end </span><span class="nf">Parity_Functions</span><span class="p">;</span>
</pre></div>
</div>
<p>There are no restrictions on the complexity or form of
conditions used within <code class="docutils literal notranslate"><span class="pre">Postcondition</span></code> pragmas.
The following example shows that it is even possible
to verify performance behavior.</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="k">package </span><span class="nf">Sort</span> <span class="kr">is</span><span class="p"></span>

   <span class="n">Performance</span> <span class="o">:</span> <span class="kr">constant</span><span class="p"> </span><span class="n">Float</span><span class="p">;</span>
   <span class="c">--  Performance constant set by implementation</span>
   <span class="c">--  to match target architecture behavior.</span>

   <span class="k">procedure </span><span class="nf">Treesort</span> <span class="o">(</span><span class="n">Arg</span> <span class="o">:</span> <span class="n">String</span><span class="o">)</span><span class="p">;</span>
   <span class="c">--  Sorts characters of argument using N*logN sort</span>
   <span class="kr">pragma</span><span class="p"> </span><span class="n">Postcondition</span>
     <span class="o">(</span><span class="n">Float</span> <span class="o">(</span><span class="n">Clock</span> <span class="o">-</span> <span class="n">Clock</span><span class="na">&#39;Old</span><span class="o">)</span> <span class="o">&lt;=</span>
        <span class="n">Float</span> <span class="o">(</span><span class="n">Arg</span><span class="na">&#39;Length</span><span class="o">)</span> <span class="o">*</span>
        <span class="n">log</span> <span class="o">(</span><span class="n">Float</span> <span class="o">(</span><span class="n">Arg</span><span class="na">&#39;Length</span><span class="o">))</span> <span class="o">*</span>
        <span class="n">Performance</span><span class="o">)</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Sort</span><span class="p">;</span>
</pre></div>
</div>
<p>Note: postcondition pragmas associated with subprograms that are
marked as Inline_Always, or those marked as Inline with front-end
inlining (-gnatN option set) are accepted and legality-checked
by the compiler, but are ignored at run-time even if postcondition
checking is enabled.</p>
<p>Note that pragma <code class="docutils literal notranslate"><span class="pre">Postcondition</span></code> differs from the language-defined
<code class="docutils literal notranslate"><span class="pre">Post</span></code> aspect (and corresponding <code class="docutils literal notranslate"><span class="pre">Post</span></code> pragma) in allowing
multiple occurrences, allowing occurences in the body even if there
is a separate spec, and allowing a second string parameter, and the
use of the pragma identifier <code class="docutils literal notranslate"><span class="pre">Check</span></code>. Historically, pragma
<code class="docutils literal notranslate"><span class="pre">Postcondition</span></code> was implemented prior to the development of
Ada 2012, and has been retained in its original form for
compatibility purposes.</p>
</div>
<div class="section" id="pragma-post-class">
<h2><span class="section-number">2.129. </span>Pragma Post_Class<a class="headerlink" href="#pragma-post-class" title="Permalink to this headline">¶</a></h2>
<span class="target" id="index-54"></span><p id="index-55">Syntax:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma</span><span class="p"> </span><span class="n">Post_Class</span> <span class="o">(</span><span class="n">Boolean_Expression</span><span class="o">)</span><span class="p">;</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">Post_Class</span></code> pragma is intended to be an exact replacement for
the language-defined
<code class="docutils literal notranslate"><span class="pre">Post'Class</span></code> aspect, and shares its restrictions and semantics.
It must appear either immediately following the corresponding
subprogram declaration (only other pragmas may intervene), or
if there is no separate subprogram declaration, then it can
appear at the start of the declarations in a subprogram body
(preceded only by other pragmas).</p>
<p>Note: This pragma is called <code class="docutils literal notranslate"><span class="pre">Post_Class</span></code> rather than
<code class="docutils literal notranslate"><span class="pre">Post'Class</span></code> because the latter would not be strictly
conforming to the allowed syntax for pragmas. The motivation
for provinding pragmas equivalent to the aspects is to allow a program
to be written using the pragmas, and then compiled if necessary
using an Ada compiler that does not recognize the pragmas or
aspects, but is prepared to ignore the pragmas. The assertion
policy that controls this pragma is <code class="docutils literal notranslate"><span class="pre">Post'Class</span></code>, not
<code class="docutils literal notranslate"><span class="pre">Post_Class</span></code>.</p>
</div>
<div class="section" id="pragma-rename-pragma">
<h2><span class="section-number">2.130. </span>Pragma Rename_Pragma<a class="headerlink" href="#pragma-rename-pragma" title="Permalink to this headline">¶</a></h2>
<p id="index-56">Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pragma</span> <span class="n">Rename_Pragma</span> <span class="p">(</span>
         <span class="p">[</span><span class="n">New_Name</span> <span class="o">=&gt;</span><span class="p">]</span> <span class="n">IDENTIFIER</span><span class="p">,</span>
         <span class="p">[</span><span class="n">Renamed</span>  <span class="o">=&gt;</span><span class="p">]</span> <span class="n">pragma_IDENTIFIER</span><span class="p">);</span>
</pre></div>
</div>
<p>This pragma provides a mechanism for supplying new names for existing
pragmas. The <code class="docutils literal notranslate"><span class="pre">New_Name</span></code> identifier can subsequently be used as a synonym for
the Renamed pragma. For example, suppose you have code that was originally
developed on a compiler that supports Inline_Only as an implementation defined
pragma. And suppose the semantics of pragma Inline_Only are identical to (or at
least very similar to) the GNAT implementation defined pragma
Inline_Always. You could globally replace Inline_Only with Inline_Always.</p>
<p>However, to avoid that source modification, you could instead add a
configuration pragma:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma</span><span class="p"> </span><span class="n">Rename_Pragma</span> <span class="o">(</span>
         <span class="n">New_Name</span> <span class="o">=&gt;</span> <span class="n">Inline_Only</span><span class="p">,</span>
         <span class="n">Renamed</span>  <span class="o">=&gt;</span> <span class="n">Inline_Always</span><span class="o">)</span><span class="p">;</span>
</pre></div>
</div>
<p>Then GNAT will treat “pragma Inline_Only …” as if you had written
“pragma Inline_Always …”.</p>
<p>Pragma Inline_Only will not necessarily mean the same thing as the other Ada
compiler; it’s up to you to make sure the semantics are close enough.</p>
</div>
<div class="section" id="pragma-pre">
<h2><span class="section-number">2.131. </span>Pragma Pre<a class="headerlink" href="#pragma-pre" title="Permalink to this headline">¶</a></h2>
<span class="target" id="index-57"></span><p id="index-58">Syntax:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma</span><span class="p"> </span><span class="n">Pre</span> <span class="o">(</span><span class="n">Boolean_Expression</span><span class="o">)</span><span class="p">;</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">Pre</span></code> pragma is intended to be an exact replacement for
the language-defined
<code class="docutils literal notranslate"><span class="pre">Pre</span></code> aspect, and shares its restrictions and semantics.
It must appear either immediately following the corresponding
subprogram declaration (only other pragmas may intervene), or
if there is no separate subprogram declaration, then it can
appear at the start of the declarations in a subprogram body
(preceded only by other pragmas).</p>
</div>
<div class="section" id="pragma-precondition">
<h2><span class="section-number">2.132. </span>Pragma Precondition<a class="headerlink" href="#pragma-precondition" title="Permalink to this headline">¶</a></h2>
<span class="target" id="index-59"></span><p id="index-60">Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pragma</span> <span class="n">Precondition</span> <span class="p">(</span>
   <span class="p">[</span><span class="n">Check</span>   <span class="o">=&gt;</span><span class="p">]</span> <span class="n">Boolean_Expression</span>
 <span class="p">[,[</span><span class="n">Message</span> <span class="o">=&gt;</span><span class="p">]</span> <span class="n">String_Expression</span><span class="p">]);</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">Precondition</span></code> pragma is similar to <code class="docutils literal notranslate"><span class="pre">Postcondition</span></code>
except that the corresponding checks take place immediately upon
entry to the subprogram, and if a precondition fails, the exception
is raised in the context of the caller, and the attribute ‘Result
cannot be used within the precondition expression.</p>
<p>Otherwise, the placement and visibility rules are identical to those
described for postconditions. The following is an example of use
within a package spec:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="k">package </span><span class="nf">Math_Functions</span> <span class="kr">is</span><span class="p"></span>
   <span class="o">...</span>
   <span class="k">function </span><span class="nf">Sqrt</span> <span class="o">(</span><span class="n">Arg</span> <span class="o">:</span> <span class="n">Float</span><span class="o">)</span> <span class="kr">return</span><span class="p"> </span><span class="n">Float</span><span class="p">;</span>
   <span class="kr">pragma</span><span class="p"> </span><span class="n">Precondition</span> <span class="o">(</span><span class="n">Arg</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">.</span><span class="mi">0</span><span class="o">)</span>
   <span class="o">...</span>
<span class="k">end </span><span class="nf">Math_Functions</span><span class="p">;</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">Precondition</span></code> pragmas may appear either immediately following the
(separate) declaration of a subprogram, or at the start of the
declarations of a subprogram body. Only other pragmas may intervene
(that is appear between the subprogram declaration and its
postconditions, or appear before the postcondition in the
declaration sequence in a subprogram body).</p>
<p>Note: precondition pragmas associated with subprograms that are
marked as Inline_Always, or those marked as Inline with front-end
inlining (-gnatN option set) are accepted and legality-checked
by the compiler, but are ignored at run-time even if precondition
checking is enabled.</p>
<p>Note that pragma <code class="docutils literal notranslate"><span class="pre">Precondition</span></code> differs from the language-defined
<code class="docutils literal notranslate"><span class="pre">Pre</span></code> aspect (and corresponding <code class="docutils literal notranslate"><span class="pre">Pre</span></code> pragma) in allowing
multiple occurrences, allowing occurences in the body even if there
is a separate spec, and allowing a second string parameter, and the
use of the pragma identifier <code class="docutils literal notranslate"><span class="pre">Check</span></code>. Historically, pragma
<code class="docutils literal notranslate"><span class="pre">Precondition</span></code> was implemented prior to the development of
Ada 2012, and has been retained in its original form for
compatibility purposes.</p>
</div>
<div class="section" id="pragma-predicate">
<span id="id30"></span><h2><span class="section-number">2.133. </span>Pragma Predicate<a class="headerlink" href="#pragma-predicate" title="Permalink to this headline">¶</a></h2>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pragma</span> <span class="n">Predicate</span>
  <span class="p">([</span><span class="n">Entity</span> <span class="o">=&gt;</span><span class="p">]</span> <span class="n">type_LOCAL_NAME</span><span class="p">,</span>
   <span class="p">[</span><span class="n">Check</span>  <span class="o">=&gt;</span><span class="p">]</span> <span class="n">EXPRESSION</span><span class="p">);</span>
</pre></div>
</div>
<p>This pragma (available in all versions of Ada in GNAT) encompasses both
the <code class="docutils literal notranslate"><span class="pre">Static_Predicate</span></code> and <code class="docutils literal notranslate"><span class="pre">Dynamic_Predicate</span></code> aspects in
Ada 2012. A predicate is regarded as static if it has an allowed form
for <code class="docutils literal notranslate"><span class="pre">Static_Predicate</span></code> and is otherwise treated as a
<code class="docutils literal notranslate"><span class="pre">Dynamic_Predicate</span></code>. Otherwise, predicates specified by this
pragma behave exactly as described in the Ada 2012 reference manual.
For example, if we have</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">type</span><span class="p"> </span><span class="n">R</span> <span class="kr">is</span><span class="p"> </span><span class="kr">range</span><span class="p"> </span><span class="mi">1</span> <span class="o">..</span> <span class="mi">10</span><span class="p">;</span>
<span class="kr">subtype</span><span class="p"> </span><span class="n">S</span> <span class="kr">is</span><span class="p"> </span><span class="n">R</span><span class="p">;</span>
<span class="kr">pragma</span><span class="p"> </span><span class="n">Predicate</span> <span class="o">(</span><span class="n">Entity</span> <span class="o">=&gt;</span> <span class="n">S</span><span class="p">,</span> <span class="n">Check</span> <span class="o">=&gt;</span> <span class="n">S</span> <span class="kr">not</span><span class="p"> </span><span class="kr">in</span><span class="p"> </span><span class="mi">4</span> <span class="o">..</span> <span class="mi">6</span><span class="o">)</span><span class="p">;</span>
<span class="kr">subtype</span><span class="p"> </span><span class="n">Q</span> <span class="kr">is</span><span class="p"> </span><span class="n">R</span>
<span class="kr">pragma</span><span class="p"> </span><span class="n">Predicate</span> <span class="o">(</span><span class="n">Entity</span> <span class="o">=&gt;</span> <span class="n">Q</span><span class="p">,</span> <span class="n">Check</span> <span class="o">=&gt;</span> <span class="n">F</span><span class="o">(</span><span class="n">Q</span><span class="o">)</span> <span class="kr">or</span><span class="p"> </span><span class="n">G</span><span class="o">(</span><span class="n">Q</span><span class="o">))</span><span class="p">;</span>
</pre></div>
</div>
<p>the effect is identical to the following Ada 2012 code:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">type</span><span class="p"> </span><span class="n">R</span> <span class="kr">is</span><span class="p"> </span><span class="kr">range</span><span class="p"> </span><span class="mi">1</span> <span class="o">..</span> <span class="mi">10</span><span class="p">;</span>
<span class="kr">subtype</span><span class="p"> </span><span class="n">S</span> <span class="kr">is</span><span class="p"> </span><span class="n">R</span> <span class="kr">with</span><span class="p"></span>
  <span class="n">Static_Predicate</span> <span class="o">=&gt;</span> <span class="n">S</span> <span class="kr">not</span><span class="p"> </span><span class="kr">in</span><span class="p"> </span><span class="mi">4</span> <span class="o">..</span> <span class="mi">6</span><span class="p">;</span>
<span class="kr">subtype</span><span class="p"> </span><span class="n">Q</span> <span class="kr">is</span><span class="p"> </span><span class="n">R</span> <span class="kr">with</span><span class="p"></span>
  <span class="n">Dynamic_Predicate</span> <span class="o">=&gt;</span> <span class="n">F</span><span class="o">(</span><span class="n">Q</span><span class="o">)</span> <span class="kr">or</span><span class="p"> </span><span class="n">G</span><span class="o">(</span><span class="n">Q</span><span class="o">)</span><span class="p">;</span>
</pre></div>
</div>
<p>Note that there are no pragmas <code class="docutils literal notranslate"><span class="pre">Dynamic_Predicate</span></code>
or <code class="docutils literal notranslate"><span class="pre">Static_Predicate</span></code>. That is
because these pragmas would affect legality and semantics of
the program and thus do not have a neutral effect if ignored.
The motivation behind providing pragmas equivalent to
corresponding aspects is to allow a program to be written
using the pragmas, and then compiled with a compiler that
will ignore the pragmas. That doesn’t work in the case of
static and dynamic predicates, since if the corresponding
pragmas are ignored, then the behavior of the program is
fundamentally changed (for example a membership test
<code class="docutils literal notranslate"><span class="pre">A</span> <span class="pre">in</span> <span class="pre">B</span></code> would not take into account a predicate
defined for subtype B). When following this approach, the
use of predicates should be avoided.</p>
</div>
<div class="section" id="pragma-predicate-failure">
<h2><span class="section-number">2.134. </span>Pragma Predicate_Failure<a class="headerlink" href="#pragma-predicate-failure" title="Permalink to this headline">¶</a></h2>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pragma</span> <span class="n">Predicate_Failure</span>
  <span class="p">([</span><span class="n">Entity</span>  <span class="o">=&gt;</span><span class="p">]</span> <span class="n">type_LOCAL_NAME</span><span class="p">,</span>
   <span class="p">[</span><span class="n">Message</span> <span class="o">=&gt;</span><span class="p">]</span> <span class="n">String_Expression</span><span class="p">);</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">Predicate_Failure</span></code> pragma is intended to be an exact replacement for
the language-defined
<code class="docutils literal notranslate"><span class="pre">Predicate_Failure</span></code> aspect, and shares its restrictions and semantics.</p>
</div>
<div class="section" id="pragma-preelaborable-initialization">
<h2><span class="section-number">2.135. </span>Pragma Preelaborable_Initialization<a class="headerlink" href="#pragma-preelaborable-initialization" title="Permalink to this headline">¶</a></h2>
<p>Syntax:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma</span><span class="p"> </span><span class="n">Preelaborable_Initialization</span> <span class="o">(</span><span class="n">DIRECT_NAME</span><span class="o">)</span><span class="p">;</span>
</pre></div>
</div>
<p>This pragma is standard in Ada 2005, but is available in all earlier
versions of Ada as an implementation-defined pragma.
See Ada 2012 Reference Manual for details.</p>
</div>
<div class="section" id="pragma-prefix-exception-messages">
<h2><span class="section-number">2.136. </span>Pragma Prefix_Exception_Messages<a class="headerlink" href="#pragma-prefix-exception-messages" title="Permalink to this headline">¶</a></h2>
<span class="target" id="index-61"></span><span class="target" id="index-62"></span><p id="index-63">Syntax:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma</span><span class="p"> </span><span class="n">Prefix_Exception_Messages</span><span class="p">;</span>
</pre></div>
</div>
<p>This is an implementation-defined configuration pragma that affects the
behavior of raise statements with a message given as a static string
constant (typically a string literal). In such cases, the string will
be automatically prefixed by the name of the enclosing entity (giving
the package and subprogram containing the raise statement). This helps
to identify where messages are coming from, and this mode is automatic
for the run-time library.</p>
<p>The pragma has no effect if the message is computed with an expression other
than a static string constant, since the assumption in this case is that
the program computes exactly the string it wants. If you still want the
prefixing in this case, you can always call
<code class="docutils literal notranslate"><span class="pre">GNAT.Source_Info.Enclosing_Entity</span></code> and prepend the string manually.</p>
</div>
<div class="section" id="pragma-pre-class">
<h2><span class="section-number">2.137. </span>Pragma Pre_Class<a class="headerlink" href="#pragma-pre-class" title="Permalink to this headline">¶</a></h2>
<span class="target" id="index-64"></span><p id="index-65">Syntax:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma</span><span class="p"> </span><span class="n">Pre_Class</span> <span class="o">(</span><span class="n">Boolean_Expression</span><span class="o">)</span><span class="p">;</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">Pre_Class</span></code> pragma is intended to be an exact replacement for
the language-defined
<code class="docutils literal notranslate"><span class="pre">Pre'Class</span></code> aspect, and shares its restrictions and semantics.
It must appear either immediately following the corresponding
subprogram declaration (only other pragmas may intervene), or
if there is no separate subprogram declaration, then it can
appear at the start of the declarations in a subprogram body
(preceded only by other pragmas).</p>
<p>Note: This pragma is called <code class="docutils literal notranslate"><span class="pre">Pre_Class</span></code> rather than
<code class="docutils literal notranslate"><span class="pre">Pre'Class</span></code> because the latter would not be strictly
conforming to the allowed syntax for pragmas. The motivation
for providing pragmas equivalent to the aspects is to allow a program
to be written using the pragmas, and then compiled if necessary
using an Ada compiler that does not recognize the pragmas or
aspects, but is prepared to ignore the pragmas. The assertion
policy that controls this pragma is <code class="docutils literal notranslate"><span class="pre">Pre'Class</span></code>, not
<code class="docutils literal notranslate"><span class="pre">Pre_Class</span></code>.</p>
</div>
<div class="section" id="pragma-priority-specific-dispatching">
<h2><span class="section-number">2.138. </span>Pragma Priority_Specific_Dispatching<a class="headerlink" href="#pragma-priority-specific-dispatching" title="Permalink to this headline">¶</a></h2>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pragma</span> <span class="n">Priority_Specific_Dispatching</span> <span class="p">(</span>
   <span class="n">POLICY_IDENTIFIER</span><span class="p">,</span>
   <span class="n">first_priority_EXPRESSION</span><span class="p">,</span>
   <span class="n">last_priority_EXPRESSION</span><span class="p">)</span>

<span class="n">POLICY_IDENTIFIER</span> <span class="p">:</span><span class="o">:=</span>
   <span class="n">EDF_Across_Priorities</span>            <span class="o">|</span>
   <span class="n">FIFO_Within_Priorities</span>           <span class="o">|</span>
   <span class="n">Non_Preemptive_Within_Priorities</span> <span class="o">|</span>
   <span class="n">Round_Robin_Within_Priorities</span>
</pre></div>
</div>
<p>This pragma is standard in Ada 2005, but is available in all earlier
versions of Ada as an implementation-defined pragma.
See Ada 2012 Reference Manual for details.</p>
</div>
<div class="section" id="pragma-profile">
<h2><span class="section-number">2.139. </span>Pragma Profile<a class="headerlink" href="#pragma-profile" title="Permalink to this headline">¶</a></h2>
<p>Syntax:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma</span><span class="p"> </span><span class="n">Profile</span> <span class="o">(</span><span class="n">Ravenscar</span> <span class="o">|</span> <span class="n">Restricted</span> <span class="o">|</span> <span class="n">Rational</span> <span class="o">|</span> <span class="n">Jorvik</span> <span class="o">|</span>
                <span class="n">GNAT_Extended_Ravenscar</span> <span class="o">|</span> <span class="n">GNAT_Ravenscar_EDF</span> <span class="o">)</span><span class="p">;</span>
</pre></div>
</div>
<p>This pragma is standard in Ada 2005, but is available in all earlier
versions of Ada as an implementation-defined pragma. This is a
configuration pragma that establishes a set of configuration pragmas
that depend on the argument. <code class="docutils literal notranslate"><span class="pre">Ravenscar</span></code> is standard in Ada 2005.
<code class="docutils literal notranslate"><span class="pre">Jorvik</span></code> is standard in Ada 202x.
The other possibilities (<code class="docutils literal notranslate"><span class="pre">Restricted</span></code>, <code class="docutils literal notranslate"><span class="pre">Rational</span></code>,
<code class="docutils literal notranslate"><span class="pre">GNAT_Extended_Ravenscar</span></code>, <code class="docutils literal notranslate"><span class="pre">GNAT_Ravenscar_EDF</span></code>)
are implementation-defined.  <code class="docutils literal notranslate"><span class="pre">GNAT_Extended_Ravenscar</span></code> is an alias for <code class="docutils literal notranslate"><span class="pre">Jorvik</span></code>.</p>
<p>The set of configuration pragmas is defined in the following sections.</p>
<ul>
<li><p>Pragma Profile (Ravenscar)</p>
<p>The <code class="docutils literal notranslate"><span class="pre">Ravenscar</span></code> profile is standard in Ada 2005,
but is available in all earlier
versions of Ada as an implementation-defined pragma. This profile
establishes the following set of configuration pragmas:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">Task_Dispatching_Policy</span> <span class="pre">(FIFO_Within_Priorities)</span></code></p>
<p>[RM D.2.2] Tasks are dispatched following a preemptive
priority-ordered scheduling policy.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">Locking_Policy</span> <span class="pre">(Ceiling_Locking)</span></code></p>
<p>[RM D.3] While tasks and interrupts execute a protected action, they inherit
the ceiling priority of the corresponding protected object.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">Detect_Blocking</span></code></p>
<p>This pragma forces the detection of potentially blocking operations within a
protected operation, and to raise Program_Error if that happens.</p>
</li>
</ul>
<p>plus the following set of restrictions:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">Max_Entry_Queue_Length</span> <span class="pre">=&gt;</span> <span class="pre">1</span></code></p>
<p>No task can be queued on a protected entry.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">Max_Protected_Entries</span> <span class="pre">=&gt;</span> <span class="pre">1</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Max_Task_Entries</span> <span class="pre">=&gt;</span> <span class="pre">0</span></code></p>
<p>No rendezvous statements are allowed.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">No_Abort_Statements</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">No_Dynamic_Attachment</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">No_Dynamic_Priorities</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">No_Implicit_Heap_Allocations</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">No_Local_Protected_Objects</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">No_Local_Timing_Events</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">No_Protected_Type_Allocators</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">No_Relative_Delay</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">No_Requeue_Statements</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">No_Select_Statements</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">No_Specific_Termination_Handlers</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">No_Task_Allocators</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">No_Task_Hierarchy</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">No_Task_Termination</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Simple_Barriers</span></code></p></li>
</ul>
<p>The Ravenscar profile also includes the following restrictions that specify
that there are no semantic dependencies on the corresponding predefined
packages:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">No_Dependence</span> <span class="pre">=&gt;</span> <span class="pre">Ada.Asynchronous_Task_Control</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">No_Dependence</span> <span class="pre">=&gt;</span> <span class="pre">Ada.Calendar</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">No_Dependence</span> <span class="pre">=&gt;</span> <span class="pre">Ada.Execution_Time.Group_Budget</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">No_Dependence</span> <span class="pre">=&gt;</span> <span class="pre">Ada.Execution_Time.Timers</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">No_Dependence</span> <span class="pre">=&gt;</span> <span class="pre">Ada.Task_Attributes</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">No_Dependence</span> <span class="pre">=&gt;</span> <span class="pre">System.Multiprocessors.Dispatching_Domains</span></code></p></li>
</ul>
<p>This set of configuration pragmas and restrictions correspond to the
definition of the ‘Ravenscar Profile’ for limited tasking, devised and
published by the <cite>International Real-Time Ada Workshop, 1997</cite>.
A description is also available at
<a class="reference external" href="http://www-users.cs.york.ac.uk/~burns/ravenscar.ps">http://www-users.cs.york.ac.uk/~burns/ravenscar.ps</a>.</p>
<p>The original definition of the profile was revised at subsequent IRTAW
meetings. It has been included in the ISO
<cite>Guide for the Use of the Ada Programming Language in High Integrity Systems</cite>,
and was made part of the Ada 2005 standard.
The formal definition given by
the Ada Rapporteur Group (ARG) can be found in two Ada Issues (AI-249 and
AI-305) available at
<a class="reference external" href="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/ais/ai-00249.txt">http://www.ada-auth.org/cgi-bin/cvsweb.cgi/ais/ai-00249.txt</a> and
<a class="reference external" href="http://www.ada-auth.org/cgi-bin/cvsweb.cgi/ais/ai-00305.txt">http://www.ada-auth.org/cgi-bin/cvsweb.cgi/ais/ai-00305.txt</a>.</p>
<p>The above set is a superset of the restrictions provided by pragma
<code class="docutils literal notranslate"><span class="pre">Profile</span> <span class="pre">(Restricted)</span></code>, it includes six additional restrictions
(<code class="docutils literal notranslate"><span class="pre">Simple_Barriers</span></code>, <code class="docutils literal notranslate"><span class="pre">No_Select_Statements</span></code>,
<code class="docutils literal notranslate"><span class="pre">No_Calendar</span></code>, <code class="docutils literal notranslate"><span class="pre">No_Implicit_Heap_Allocations</span></code>,
<code class="docutils literal notranslate"><span class="pre">No_Relative_Delay</span></code> and <code class="docutils literal notranslate"><span class="pre">No_Task_Termination</span></code>).  This means
that pragma <code class="docutils literal notranslate"><span class="pre">Profile</span> <span class="pre">(Ravenscar)</span></code>, like the pragma
<code class="docutils literal notranslate"><span class="pre">Profile</span> <span class="pre">(Restricted)</span></code>,
automatically causes the use of a simplified,
more efficient version of the tasking run-time library.</p>
</li>
<li><p>Pragma Profile (Jorvik)</p>
<p><code class="docutils literal notranslate"><span class="pre">Jorvik</span></code> is the new profile added to the Ada 202x draft standard,
previously implemented under the name <code class="docutils literal notranslate"><span class="pre">GNAT_Extended_Ravenscar</span></code>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">No_Implicit_Heap_Allocations</span></code> restriction has been replaced
by <code class="docutils literal notranslate"><span class="pre">No_Implicit_Task_Allocations</span></code> and
<code class="docutils literal notranslate"><span class="pre">No_Implicit_Protected_Object_Allocations</span></code>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">Simple_Barriers</span></code> restriction has been replaced by
<code class="docutils literal notranslate"><span class="pre">Pure_Barriers</span></code>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">Max_Protected_Entries</span></code>, <code class="docutils literal notranslate"><span class="pre">Max_Entry_Queue_Length</span></code>, and
<code class="docutils literal notranslate"><span class="pre">No_Relative_Delay</span></code> restrictions have been removed.</p>
<p>Details on the rationale for <code class="docutils literal notranslate"><span class="pre">Jorvik</span></code> and implications for use may be
found in <cite>A New Ravenscar-Based Profile</cite> by P. Rogers, J. Ruiz,
T. Gingold and P. Bernardi, in <cite>Reliable Software Technologies –
Ada Europe 2017</cite>, Springer-Verlag Lecture Notes in Computer Science,
Number 10300.</p>
</li>
<li><p>Pragma Profile (GNAT_Ravenscar_EDF)</p>
<p>This profile corresponds to the Ravenscar profile but using
EDF_Across_Priority as the Task_Scheduling_Policy.</p>
</li>
<li><p>Pragma Profile (Restricted)</p>
<p>This profile corresponds to the GNAT restricted run time. It
establishes the following set of restrictions:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">No_Abort_Statements</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">No_Entry_Queue</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">No_Task_Hierarchy</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">No_Task_Allocators</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">No_Dynamic_Priorities</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">No_Terminate_Alternatives</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">No_Dynamic_Attachment</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">No_Protected_Type_Allocators</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">No_Local_Protected_Objects</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">No_Requeue_Statements</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">No_Task_Attributes_Package</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Max_Asynchronous_Select_Nesting</span> <span class="pre">=</span>&#160; <span class="pre">0</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Max_Task_Entries</span> <span class="pre">=</span>&#160; <span class="pre">0</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Max_Protected_Entries</span> <span class="pre">=</span> <span class="pre">1</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Max_Select_Alternatives</span> <span class="pre">=</span> <span class="pre">0</span></code></p></li>
</ul>
<p>This set of restrictions causes the automatic selection of a simplified
version of the run time that provides improved performance for the
limited set of tasking functionality permitted by this set of restrictions.</p>
</li>
<li><p>Pragma Profile (Rational)</p>
<p>The Rational profile is intended to facilitate porting legacy code that
compiles with the Rational APEX compiler, even when the code includes non-
conforming Ada constructs.  The profile enables the following three pragmas:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pragma</span> <span class="pre">Implicit_Packing</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pragma</span> <span class="pre">Overriding_Renamings</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pragma</span> <span class="pre">Use_VADS_Size</span></code></p></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="pragma-profile-warnings">
<h2><span class="section-number">2.140. </span>Pragma Profile_Warnings<a class="headerlink" href="#pragma-profile-warnings" title="Permalink to this headline">¶</a></h2>
<p>Syntax:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma</span><span class="p"> </span><span class="n">Profile_Warnings</span> <span class="o">(</span><span class="n">Ravenscar</span> <span class="o">|</span> <span class="n">Restricted</span> <span class="o">|</span> <span class="n">Rational</span><span class="o">)</span><span class="p">;</span>
</pre></div>
</div>
<p>This is an implementation-defined pragma that is similar in
effect to <code class="docutils literal notranslate"><span class="pre">pragma</span> <span class="pre">Profile</span></code> except that instead of
generating <code class="docutils literal notranslate"><span class="pre">Restrictions</span></code> pragmas, it generates
<code class="docutils literal notranslate"><span class="pre">Restriction_Warnings</span></code> pragmas. The result is that
violations of the profile generate warning messages instead
of error messages.</p>
</div>
<div class="section" id="pragma-propagate-exceptions">
<h2><span class="section-number">2.141. </span>Pragma Propagate_Exceptions<a class="headerlink" href="#pragma-propagate-exceptions" title="Permalink to this headline">¶</a></h2>
<p id="index-66">Syntax:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma</span><span class="p"> </span><span class="n">Propagate_Exceptions</span><span class="p">;</span>
</pre></div>
</div>
<p>This pragma is now obsolete and, other than generating a warning if warnings
on obsolescent features are enabled, is ignored.
It is retained for compatibility
purposes. It used to be used in connection with optimization of
a now-obsolete mechanism for implementation of exceptions.</p>
</div>
<div class="section" id="pragma-provide-shift-operators">
<h2><span class="section-number">2.142. </span>Pragma Provide_Shift_Operators<a class="headerlink" href="#pragma-provide-shift-operators" title="Permalink to this headline">¶</a></h2>
<p id="index-67">Syntax:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma</span><span class="p"> </span><span class="n">Provide_Shift_Operators</span> <span class="o">(</span><span class="n">integer_first_subtype_LOCAL_NAME</span><span class="o">)</span><span class="p">;</span>
</pre></div>
</div>
<p>This pragma can be applied to a first subtype local name that specifies
either an unsigned or signed type. It has the effect of providing the
five shift operators (Shift_Left, Shift_Right, Shift_Right_Arithmetic,
Rotate_Left and Rotate_Right) for the given type. It is similar to
including the function declarations for these five operators, together
with the pragma Import (Intrinsic, …) statements.</p>
</div>
<div class="section" id="pragma-psect-object">
<h2><span class="section-number">2.143. </span>Pragma Psect_Object<a class="headerlink" href="#pragma-psect-object" title="Permalink to this headline">¶</a></h2>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pragma</span> <span class="n">Psect_Object</span> <span class="p">(</span>
     <span class="p">[</span><span class="n">Internal</span> <span class="o">=&gt;</span><span class="p">]</span> <span class="n">LOCAL_NAME</span><span class="p">,</span>
  <span class="p">[,</span> <span class="p">[</span><span class="n">External</span> <span class="o">=&gt;</span><span class="p">]</span> <span class="n">EXTERNAL_SYMBOL</span><span class="p">]</span>
  <span class="p">[,</span> <span class="p">[</span><span class="n">Size</span>     <span class="o">=&gt;</span><span class="p">]</span> <span class="n">EXTERNAL_SYMBOL</span><span class="p">]);</span>

<span class="n">EXTERNAL_SYMBOL</span> <span class="p">:</span><span class="o">:=</span>
  <span class="n">IDENTIFIER</span>
<span class="o">|</span> <span class="n">static_string_EXPRESSION</span>
</pre></div>
</div>
<p>This pragma is identical in effect to pragma <code class="docutils literal notranslate"><span class="pre">Common_Object</span></code>.</p>
</div>
<div class="section" id="pragma-pure-function">
<span id="id31"></span><h2><span class="section-number">2.144. </span>Pragma Pure_Function<a class="headerlink" href="#pragma-pure-function" title="Permalink to this headline">¶</a></h2>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pragma</span> <span class="n">Pure_Function</span> <span class="p">([</span><span class="n">Entity</span> <span class="o">=&gt;</span><span class="p">]</span> <span class="n">function_LOCAL_NAME</span><span class="p">);</span>
</pre></div>
</div>
<p>This pragma appears in the same declarative part as a function
declaration (or a set of function declarations if more than one
overloaded declaration exists, in which case the pragma applies
to all entities).  It specifies that the function <code class="docutils literal notranslate"><span class="pre">Entity</span></code> is
to be considered pure for the purposes of code generation.  This means
that the compiler can assume that there are no side effects, and
in particular that two calls with identical arguments produce the
same result.  It also means that the function can be used in an
address clause.</p>
<p>Note that, quite deliberately, there are no static checks to try
to ensure that this promise is met, so <code class="docutils literal notranslate"><span class="pre">Pure_Function</span></code> can be used
with functions that are conceptually pure, even if they do modify
global variables.  For example, a square root function that is
instrumented to count the number of times it is called is still
conceptually pure, and can still be optimized, even though it
modifies a global variable (the count).  Memo functions are another
example (where a table of previous calls is kept and consulted to
avoid re-computation).</p>
<p>Note also that the normal rules excluding optimization of subprograms
in pure units (when parameter types are descended from System.Address,
or when the full view of a parameter type is limited), do not apply
for the Pure_Function case. If you explicitly specify Pure_Function,
the compiler may optimize away calls with identical arguments, and
if that results in unexpected behavior, the proper action is not to
use the pragma for subprograms that are not (conceptually) pure.</p>
<p>Note: Most functions in a <code class="docutils literal notranslate"><span class="pre">Pure</span></code> package are automatically pure, and
there is no need to use pragma <code class="docutils literal notranslate"><span class="pre">Pure_Function</span></code> for such functions.  One
exception is any function that has at least one formal of type
<code class="docutils literal notranslate"><span class="pre">System.Address</span></code> or a type derived from it.  Such functions are not
considered pure by default, since the compiler assumes that the
<code class="docutils literal notranslate"><span class="pre">Address</span></code> parameter may be functioning as a pointer and that the
referenced data may change even if the address value does not.
Similarly, imported functions are not considered to be pure by default,
since there is no way of checking that they are in fact pure.  The use
of pragma <code class="docutils literal notranslate"><span class="pre">Pure_Function</span></code> for such a function will override these default
assumption, and cause the compiler to treat a designated subprogram as pure
in these cases.</p>
<p>Note: If pragma <code class="docutils literal notranslate"><span class="pre">Pure_Function</span></code> is applied to a renamed function, it
applies to the underlying renamed function.  This can be used to
disambiguate cases of overloading where some but not all functions
in a set of overloaded functions are to be designated as pure.</p>
<p>If pragma <code class="docutils literal notranslate"><span class="pre">Pure_Function</span></code> is applied to a library-level function, the
function is also considered pure from an optimization point of view, but the
unit is not a Pure unit in the categorization sense. So for example, a function
thus marked is free to <code class="docutils literal notranslate"><span class="pre">with</span></code> non-pure units.</p>
</div>
<div class="section" id="pragma-rational">
<h2><span class="section-number">2.145. </span>Pragma Rational<a class="headerlink" href="#pragma-rational" title="Permalink to this headline">¶</a></h2>
<p>Syntax:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma</span><span class="p"> </span><span class="n">Rational</span><span class="p">;</span>
</pre></div>
</div>
<p>This pragma is considered obsolescent, but is retained for
compatibility purposes. It is equivalent to:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma</span><span class="p"> </span><span class="n">Profile</span> <span class="o">(</span><span class="n">Rational</span><span class="o">)</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="pragma-ravenscar">
<h2><span class="section-number">2.146. </span>Pragma Ravenscar<a class="headerlink" href="#pragma-ravenscar" title="Permalink to this headline">¶</a></h2>
<p>Syntax:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma</span><span class="p"> </span><span class="n">Ravenscar</span><span class="p">;</span>
</pre></div>
</div>
<p>This pragma is considered obsolescent, but is retained for
compatibility purposes. It is equivalent to:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma</span><span class="p"> </span><span class="n">Profile</span> <span class="o">(</span><span class="n">Ravenscar</span><span class="o">)</span><span class="p">;</span>
</pre></div>
</div>
<p>which is the preferred method of setting the <code class="docutils literal notranslate"><span class="pre">Ravenscar</span></code> profile.</p>
</div>
<div class="section" id="pragma-refined-depends">
<span id="id32"></span><h2><span class="section-number">2.147. </span>Pragma Refined_Depends<a class="headerlink" href="#pragma-refined-depends" title="Permalink to this headline">¶</a></h2>
<p>Syntax:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma</span><span class="p"> </span><span class="n">Refined_Depends</span> <span class="o">(</span><span class="n">DEPENDENCY_RELATION</span><span class="o">)</span><span class="p">;</span>

<span class="n">DEPENDENCY_RELATION</span> <span class="o">::=</span>
     <span class="kr">null</span><span class="p"></span>
  <span class="o">|</span> <span class="o">(</span><span class="n">DEPENDENCY_CLAUSE</span> {<span class="p">,</span> <span class="n">DEPENDENCY_CLAUSE</span>}<span class="o">)</span>

<span class="n">DEPENDENCY_CLAUSE</span> <span class="o">::=</span>
    <span class="n">OUTPUT_LIST</span> <span class="o">=&gt;</span>[<span class="o">+</span>] <span class="n">INPUT_LIST</span>
  <span class="o">|</span> <span class="n">NULL_DEPENDENCY_CLAUSE</span>

<span class="n">NULL_DEPENDENCY_CLAUSE</span> <span class="o">::=</span> <span class="kr">null</span><span class="p"> </span><span class="o">=&gt;</span> <span class="n">INPUT_LIST</span>

<span class="n">OUTPUT_LIST</span> <span class="o">::=</span> <span class="n">OUTPUT</span> <span class="o">|</span> <span class="o">(</span><span class="n">OUTPUT</span> {<span class="p">,</span> <span class="n">OUTPUT</span>}<span class="o">)</span>

<span class="n">INPUT_LIST</span> <span class="o">::=</span> <span class="kr">null</span><span class="p"> </span><span class="o">|</span> <span class="n">INPUT</span> <span class="o">|</span> <span class="o">(</span><span class="n">INPUT</span> {<span class="p">,</span> <span class="n">INPUT</span>}<span class="o">)</span>

<span class="n">OUTPUT</span> <span class="o">::=</span> <span class="n">NAME</span> <span class="o">|</span> <span class="n">FUNCTION_RESULT</span>
<span class="n">INPUT</span>  <span class="o">::=</span> <span class="n">NAME</span>

<span class="n">where</span> <span class="n">FUNCTION_RESULT</span> <span class="kr">is</span><span class="p"> </span><span class="n">a</span> <span class="k">function </span><span class="nf">Result</span> <span class="n">attribute_reference</span>
</pre></div>
</div>
<p>For the semantics of this pragma, see the entry for aspect <code class="docutils literal notranslate"><span class="pre">Refined_Depends</span></code> in
the SPARK 2014 Reference Manual, section 6.1.5.</p>
</div>
<div class="section" id="pragma-refined-global">
<span id="id33"></span><h2><span class="section-number">2.148. </span>Pragma Refined_Global<a class="headerlink" href="#pragma-refined-global" title="Permalink to this headline">¶</a></h2>
<p>Syntax:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma</span><span class="p"> </span><span class="n">Refined_Global</span> <span class="o">(</span><span class="n">GLOBAL_SPECIFICATION</span><span class="o">)</span><span class="p">;</span>

<span class="n">GLOBAL_SPECIFICATION</span> <span class="o">::=</span>
     <span class="kr">null</span><span class="p"></span>
  <span class="o">|</span> <span class="o">(</span><span class="n">GLOBAL_LIST</span><span class="o">)</span>
  <span class="o">|</span> <span class="o">(</span><span class="n">MODED_GLOBAL_LIST</span> {<span class="p">,</span> <span class="n">MODED_GLOBAL_LIST</span>}<span class="o">)</span>

<span class="n">MODED_GLOBAL_LIST</span> <span class="o">::=</span> <span class="n">MODE_SELECTOR</span> <span class="o">=&gt;</span> <span class="n">GLOBAL_LIST</span>

<span class="n">MODE_SELECTOR</span> <span class="o">::=</span> <span class="n">In_Out</span> <span class="o">|</span> <span class="n">Input</span> <span class="o">|</span> <span class="n">Output</span> <span class="o">|</span> <span class="n">Proof_In</span>
<span class="n">GLOBAL_LIST</span>   <span class="o">::=</span> <span class="n">GLOBAL_ITEM</span> <span class="o">|</span> <span class="o">(</span><span class="n">GLOBAL_ITEM</span> {<span class="p">,</span> <span class="n">GLOBAL_ITEM</span>}<span class="o">)</span>
<span class="n">GLOBAL_ITEM</span>   <span class="o">::=</span> <span class="n">NAME</span>
</pre></div>
</div>
<p>For the semantics of this pragma, see the entry for aspect <code class="docutils literal notranslate"><span class="pre">Refined_Global</span></code> in
the SPARK 2014 Reference Manual, section 6.1.4.</p>
</div>
<div class="section" id="pragma-refined-post">
<span id="id34"></span><h2><span class="section-number">2.149. </span>Pragma Refined_Post<a class="headerlink" href="#pragma-refined-post" title="Permalink to this headline">¶</a></h2>
<p>Syntax:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma</span><span class="p"> </span><span class="n">Refined_Post</span> <span class="o">(</span><span class="n">boolean_EXPRESSION</span><span class="o">)</span><span class="p">;</span>
</pre></div>
</div>
<p>For the semantics of this pragma, see the entry for aspect <code class="docutils literal notranslate"><span class="pre">Refined_Post</span></code> in
the SPARK 2014 Reference Manual, section 7.2.7.</p>
</div>
<div class="section" id="pragma-refined-state">
<span id="id35"></span><h2><span class="section-number">2.150. </span>Pragma Refined_State<a class="headerlink" href="#pragma-refined-state" title="Permalink to this headline">¶</a></h2>
<p>Syntax:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma</span><span class="p"> </span><span class="n">Refined_State</span> <span class="o">(</span><span class="n">REFINEMENT_LIST</span><span class="o">)</span><span class="p">;</span>

<span class="n">REFINEMENT_LIST</span> <span class="o">::=</span>
  <span class="o">(</span><span class="n">REFINEMENT_CLAUSE</span> {<span class="p">,</span> <span class="n">REFINEMENT_CLAUSE</span>}<span class="o">)</span>

<span class="n">REFINEMENT_CLAUSE</span> <span class="o">::=</span> <span class="n">state_NAME</span> <span class="o">=&gt;</span> <span class="n">CONSTITUENT_LIST</span>

<span class="n">CONSTITUENT_LIST</span> <span class="o">::=</span>
     <span class="kr">null</span><span class="p"></span>
  <span class="o">|</span>  <span class="n">CONSTITUENT</span>
  <span class="o">|</span> <span class="o">(</span><span class="n">CONSTITUENT</span> {<span class="p">,</span> <span class="n">CONSTITUENT</span>}<span class="o">)</span>

<span class="n">CONSTITUENT</span> <span class="o">::=</span> <span class="n">object_NAME</span> <span class="o">|</span> <span class="n">state_NAME</span>
</pre></div>
</div>
<p>For the semantics of this pragma, see the entry for aspect <code class="docutils literal notranslate"><span class="pre">Refined_State</span></code> in
the SPARK 2014 Reference Manual, section 7.2.2.</p>
</div>
<div class="section" id="pragma-relative-deadline">
<h2><span class="section-number">2.151. </span>Pragma Relative_Deadline<a class="headerlink" href="#pragma-relative-deadline" title="Permalink to this headline">¶</a></h2>
<p>Syntax:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma</span><span class="p"> </span><span class="n">Relative_Deadline</span> <span class="o">(</span><span class="n">time_span_EXPRESSION</span><span class="o">)</span><span class="p">;</span>
</pre></div>
</div>
<p>This pragma is standard in Ada 2005, but is available in all earlier
versions of Ada as an implementation-defined pragma.
See Ada 2012 Reference Manual for details.</p>
</div>
<div class="section" id="pragma-remote-access-type">
<span id="id36"></span><h2><span class="section-number">2.152. </span>Pragma Remote_Access_Type<a class="headerlink" href="#pragma-remote-access-type" title="Permalink to this headline">¶</a></h2>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pragma</span> <span class="n">Remote_Access_Type</span> <span class="p">([</span><span class="n">Entity</span> <span class="o">=&gt;</span><span class="p">]</span> <span class="n">formal_access_type_LOCAL_NAME</span><span class="p">);</span>
</pre></div>
</div>
<p>This pragma appears in the formal part of a generic declaration.
It specifies an exception to the RM rule from E.2.2(17/2), which forbids
the use of a remote access to class-wide type as actual for a formal
access type.</p>
<p>When this pragma applies to a formal access type <code class="docutils literal notranslate"><span class="pre">Entity</span></code>, that
type is treated as a remote access to class-wide type in the generic.
It must be a formal general access type, and its designated type must
be the class-wide type of a formal tagged limited private type from the
same generic declaration.</p>
<p>In the generic unit, the formal type is subject to all restrictions
pertaining to remote access to class-wide types. At instantiation, the
actual type must be a remote access to class-wide type.</p>
</div>
<div class="section" id="pragma-restricted-run-time">
<h2><span class="section-number">2.153. </span>Pragma Restricted_Run_Time<a class="headerlink" href="#pragma-restricted-run-time" title="Permalink to this headline">¶</a></h2>
<p>Syntax:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma</span><span class="p"> </span><span class="n">Restricted_Run_Time</span><span class="p">;</span>
</pre></div>
</div>
<p>This pragma is considered obsolescent, but is retained for
compatibility purposes. It is equivalent to:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma</span><span class="p"> </span><span class="n">Profile</span> <span class="o">(</span><span class="n">Restricted</span><span class="o">)</span><span class="p">;</span>
</pre></div>
</div>
<p>which is the preferred method of setting the restricted run time
profile.</p>
</div>
<div class="section" id="pragma-restriction-warnings">
<h2><span class="section-number">2.154. </span>Pragma Restriction_Warnings<a class="headerlink" href="#pragma-restriction-warnings" title="Permalink to this headline">¶</a></h2>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pragma</span> <span class="n">Restriction_Warnings</span>
  <span class="p">(</span><span class="n">restriction_IDENTIFIER</span> <span class="p">{,</span> <span class="n">restriction_IDENTIFIER</span><span class="p">});</span>
</pre></div>
</div>
<p>This pragma allows a series of restriction identifiers to be
specified (the list of allowed identifiers is the same as for
pragma <code class="docutils literal notranslate"><span class="pre">Restrictions</span></code>). For each of these identifiers
the compiler checks for violations of the restriction, but
generates a warning message rather than an error message
if the restriction is violated.</p>
<p>One use of this is in situations where you want to know
about violations of a restriction, but you want to ignore some of
these violations. Consider this example, where you want to set
Ada_95 mode and enable style checks, but you want to know about
any other use of implementation pragmas:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma</span><span class="p"> </span><span class="n">Restriction_Warnings</span> <span class="o">(</span><span class="n">No_Implementation_Pragmas</span><span class="o">)</span><span class="p">;</span>
<span class="kr">pragma</span><span class="p"> </span><span class="n">Warnings</span> <span class="o">(</span><span class="n">Off</span><span class="p">,</span> <span class="s">&quot;violation of No_Implementation_Pragmas&quot;</span><span class="o">)</span><span class="p">;</span>
<span class="kr">pragma</span><span class="p"> </span><span class="n">Ada_95</span><span class="p">;</span>
<span class="kr">pragma</span><span class="p"> </span><span class="n">Style_Checks</span> <span class="o">(</span><span class="s">&quot;2bfhkM160&quot;</span><span class="o">)</span><span class="p">;</span>
<span class="kr">pragma</span><span class="p"> </span><span class="n">Warnings</span> <span class="o">(</span><span class="n">On</span><span class="p">,</span> <span class="s">&quot;violation of No_Implementation_Pragmas&quot;</span><span class="o">)</span><span class="p">;</span>
</pre></div>
</div>
<p>By including the above lines in a configuration pragmas file,
the Ada_95 and Style_Checks pragmas are accepted without
generating a warning, but any other use of implementation
defined pragmas will cause a warning to be generated.</p>
</div>
<div class="section" id="pragma-reviewable">
<h2><span class="section-number">2.155. </span>Pragma Reviewable<a class="headerlink" href="#pragma-reviewable" title="Permalink to this headline">¶</a></h2>
<p>Syntax:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma</span><span class="p"> </span><span class="n">Reviewable</span><span class="p">;</span>
</pre></div>
</div>
<p>This pragma is an RM-defined standard pragma, but has no effect on the
program being compiled, or on the code generated for the program.</p>
<p>To obtain the required output specified in RM H.3.1, the compiler must be
run with various special switches as follows:</p>
<ul>
<li><p><em>Where compiler-generated run-time checks remain</em></p>
<p>The switch <em>-gnatGL</em>
may be used to list the expanded code in pseudo-Ada form.
Runtime checks show up in the listing either as explicit
checks or operators marked with {} to indicate a check is present.</p>
</li>
<li><p><em>An identification of known exceptions at compile time</em></p>
<p>If the program is compiled with <em>-gnatwa</em>,
the compiler warning messages will indicate all cases where the compiler
detects that an exception is certain to occur at run time.</p>
</li>
<li><p><em>Possible reads of uninitialized variables</em></p>
<p>The compiler warns of many such cases, but its output is incomplete.</p>
</li>
</ul>
<p>The CodePeer analysis tool
may be used to obtain a comprehensive list of all
possible points at which uninitialized data may be read.</p>
<ul>
<li><p><em>Where run-time support routines are implicitly invoked</em></p>
<p>In the output from <em>-gnatGL</em>,
run-time calls are explicitly listed as calls to the relevant
run-time routine.</p>
</li>
<li><p><em>Object code listing</em></p>
<p>This may be obtained either by using the <em>-S</em> switch,
or the objdump utility.</p>
</li>
<li><p><em>Constructs known to be erroneous at compile time</em></p>
<p>These are identified by warnings issued by the compiler (use <em>-gnatwa</em>).</p>
</li>
<li><p><em>Stack usage information</em></p>
<p>Static stack usage data (maximum per-subprogram) can be obtained via the
<em>-fstack-usage</em> switch to the compiler.
Dynamic stack usage data (per task) can be obtained via the <em>-u</em> switch
to gnatbind</p>
</li>
</ul>
<p>The gnatstack utility
can be used to provide additional information on stack usage.</p>
<ul>
<li><p><em>Object code listing of entire partition</em></p>
<p>This can be obtained by compiling the partition with <em>-S</em>,
or by applying objdump
to all the object files that are part of the partition.</p>
</li>
<li><p><em>A description of the run-time model</em></p>
<p>The full sources of the run-time are available, and the documentation of
these routines describes how these run-time routines interface to the
underlying operating system facilities.</p>
</li>
<li><p><em>Control and data-flow information</em></p></li>
</ul>
<p>The CodePeer tool
may be used to obtain complete control and data-flow information, as well as
comprehensive messages identifying possible problems based on this
information.</p>
</div>
<div class="section" id="pragma-secondary-stack-size">
<span id="id37"></span><h2><span class="section-number">2.156. </span>Pragma Secondary_Stack_Size<a class="headerlink" href="#pragma-secondary-stack-size" title="Permalink to this headline">¶</a></h2>
<p>Syntax:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma</span><span class="p"> </span><span class="n">Secondary_Stack_Size</span> <span class="o">(</span><span class="n">integer_EXPRESSION</span><span class="o">)</span><span class="p">;</span>
</pre></div>
</div>
<p>This pragma appears within the task definition of a single task declaration
or a task type declaration (like pragma <code class="docutils literal notranslate"><span class="pre">Storage_Size</span></code>) and applies to all
task objects of that type. The argument specifies the size of the secondary
stack to be used by these task objects, and must be of an integer type. The
secondary stack is used to handle functions that return a variable-sized
result, for example a function returning an unconstrained String.</p>
<p>Note this pragma only applies to targets using fixed secondary stacks, like
VxWorks 653 and bare board targets, where a fixed block for the
secondary stack is allocated from the primary stack of the task. By default,
these targets assign a percentage of the primary stack for the secondary stack,
as defined by <code class="docutils literal notranslate"><span class="pre">System.Parameter.Sec_Stack_Percentage</span></code>. With this pragma,
an <code class="docutils literal notranslate"><span class="pre">integer_EXPRESSION</span></code> of bytes is assigned from the primary stack instead.</p>
<p>For most targets, the pragma does not apply as the secondary stack grows on
demand: allocated as a chain of blocks in the heap. The default size of these
blocks can be modified via the <code class="switch docutils literal notranslate"><span class="pre">-D</span></code> binder option as described in
<cite>GNAT User’s Guide</cite>.</p>
<p>Note that no check is made to see if the secondary stack can fit inside the
primary stack.</p>
<p>Note the pragma cannot appear when the restriction <code class="docutils literal notranslate"><span class="pre">No_Secondary_Stack</span></code>
is in effect.</p>
</div>
<div class="section" id="pragma-share-generic">
<h2><span class="section-number">2.157. </span>Pragma Share_Generic<a class="headerlink" href="#pragma-share-generic" title="Permalink to this headline">¶</a></h2>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pragma</span> <span class="n">Share_Generic</span> <span class="p">(</span><span class="n">GNAME</span> <span class="p">{,</span> <span class="n">GNAME</span><span class="p">});</span>

<span class="n">GNAME</span> <span class="p">:</span><span class="o">:=</span> <span class="n">generic_unit_NAME</span> <span class="o">|</span> <span class="n">generic_instance_NAME</span>
</pre></div>
</div>
<p>This pragma is provided for compatibility with Dec Ada 83. It has
no effect in GNAT (which does not implement shared generics), other
than to check that the given names are all names of generic units or
generic instances.</p>
</div>
<div class="section" id="pragma-shared">
<span id="id38"></span><h2><span class="section-number">2.158. </span>Pragma Shared<a class="headerlink" href="#pragma-shared" title="Permalink to this headline">¶</a></h2>
<p>This pragma is provided for compatibility with Ada 83. The syntax and
semantics are identical to pragma Atomic.</p>
</div>
<div class="section" id="pragma-short-circuit-and-or">
<h2><span class="section-number">2.159. </span>Pragma Short_Circuit_And_Or<a class="headerlink" href="#pragma-short-circuit-and-or" title="Permalink to this headline">¶</a></h2>
<p>Syntax:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma</span><span class="p"> </span><span class="n">Short_Circuit_And_Or</span><span class="p">;</span>
</pre></div>
</div>
<p>This configuration pragma causes any occurrence of the AND operator applied to
operands of type Standard.Boolean to be short-circuited (i.e. the AND operator
is treated as if it were AND THEN). Or is similarly treated as OR ELSE. This
may be useful in the context of certification protocols requiring the use of
short-circuited logical operators. If this configuration pragma occurs locally
within the file being compiled, it applies only to the file being compiled.
There is no requirement that all units in a partition use this option.</p>
</div>
<div class="section" id="pragma-short-descriptors">
<h2><span class="section-number">2.160. </span>Pragma Short_Descriptors<a class="headerlink" href="#pragma-short-descriptors" title="Permalink to this headline">¶</a></h2>
<p>Syntax:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma</span><span class="p"> </span><span class="n">Short_Descriptors</span>
</pre></div>
</div>
<p>This pragma is provided for compatibility with other Ada implementations. It
is recognized but ignored by all current versions of GNAT.</p>
</div>
<div class="section" id="pragma-simple-storage-pool-type">
<span id="id39"></span><h2><span class="section-number">2.161. </span>Pragma Simple_Storage_Pool_Type<a class="headerlink" href="#pragma-simple-storage-pool-type" title="Permalink to this headline">¶</a></h2>
<span class="target" id="index-68"></span><p id="index-69">Syntax:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma</span><span class="p"> </span><span class="n">Simple_Storage_Pool_Type</span> <span class="o">(</span><span class="n">type_LOCAL_NAME</span><span class="o">)</span><span class="p">;</span>
</pre></div>
</div>
<p>A type can be established as a ‘simple storage pool type’ by applying
the representation pragma <code class="docutils literal notranslate"><span class="pre">Simple_Storage_Pool_Type</span></code> to the type.
A type named in the pragma must be a library-level immutably limited record
type or limited tagged type declared immediately within a package declaration.
The type can also be a limited private type whose full type is allowed as
a simple storage pool type.</p>
<p>For a simple storage pool type <code class="docutils literal notranslate"><span class="pre">SSP</span></code>, nonabstract primitive subprograms
<code class="docutils literal notranslate"><span class="pre">Allocate</span></code>, <code class="docutils literal notranslate"><span class="pre">Deallocate</span></code>, and <code class="docutils literal notranslate"><span class="pre">Storage_Size</span></code> can be declared that
are subtype conformant with the following subprogram declarations:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="k">procedure </span><span class="nf">Allocate</span>
  <span class="o">(</span><span class="n">Pool</span>                     <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="kr">out</span><span class="p"> </span><span class="n">SSP</span><span class="p">;</span>
   <span class="n">Storage_Address</span>          <span class="o">:</span> <span class="kr">out</span><span class="p"> </span><span class="n">System.Address</span><span class="p">;</span>
   <span class="n">Size_In_Storage_Elements</span> <span class="o">:</span> <span class="n">System.Storage_Elements.Storage_Count</span><span class="p">;</span>
   <span class="n">Alignment</span>                <span class="o">:</span> <span class="n">System.Storage_Elements.Storage_Count</span><span class="o">)</span><span class="p">;</span>

<span class="k">procedure </span><span class="nf">Deallocate</span>
  <span class="o">(</span><span class="n">Pool</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="kr">out</span><span class="p"> </span><span class="n">SSP</span><span class="p">;</span>
   <span class="n">Storage_Address</span>          <span class="o">:</span> <span class="n">System.Address</span><span class="p">;</span>
   <span class="n">Size_In_Storage_Elements</span> <span class="o">:</span> <span class="n">System.Storage_Elements.Storage_Count</span><span class="p">;</span>
   <span class="n">Alignment</span>                <span class="o">:</span> <span class="n">System.Storage_Elements.Storage_Count</span><span class="o">)</span><span class="p">;</span>

<span class="k">function </span><span class="nf">Storage_Size</span> <span class="o">(</span><span class="n">Pool</span> <span class="o">:</span> <span class="n">SSP</span><span class="o">)</span>
  <span class="kr">return</span><span class="p"> </span><span class="n">System.Storage_Elements.Storage_Count</span><span class="p">;</span>
</pre></div>
</div>
<p>Procedure <code class="docutils literal notranslate"><span class="pre">Allocate</span></code> must be declared, whereas <code class="docutils literal notranslate"><span class="pre">Deallocate</span></code> and
<code class="docutils literal notranslate"><span class="pre">Storage_Size</span></code> are optional. If <code class="docutils literal notranslate"><span class="pre">Deallocate</span></code> is not declared, then
applying an unchecked deallocation has no effect other than to set its actual
parameter to null. If <code class="docutils literal notranslate"><span class="pre">Storage_Size</span></code> is not declared, then the
<code class="docutils literal notranslate"><span class="pre">Storage_Size</span></code> attribute applied to an access type associated with
a pool object of type SSP returns zero. Additional operations can be declared
for a simple storage pool type (such as for supporting a mark/release
storage-management discipline).</p>
<p>An object of a simple storage pool type can be associated with an access
type by specifying the attribute
<a class="reference internal" href="implementation_defined_attributes.html#attribute-simple-storage-pool"><span class="std std-ref">Simple_Storage_Pool</span></a>. For example:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="n">My_Pool</span> <span class="o">:</span> <span class="n">My_Simple_Storage_Pool_Type</span><span class="p">;</span>

<span class="kr">type</span><span class="p"> </span><span class="n">Acc</span> <span class="kr">is</span><span class="p"> </span><span class="kr">access</span><span class="p"> </span><span class="n">My_Data_Type</span><span class="p">;</span>

<span class="kr">for</span><span class="p"> </span><span class="n">Acc</span><span class="na">&#39;Simple_Storage_Pool</span> <span class="kr">use</span><span class="p"> </span><span class="n">My_Pool</span><span class="p">;</span>
</pre></div>
</div>
<p>See attribute <a class="reference internal" href="implementation_defined_attributes.html#attribute-simple-storage-pool"><span class="std std-ref">Simple_Storage_Pool</span></a>
for further details.</p>
</div>
<div class="section" id="pragma-source-file-name">
<span id="id40"></span><h2><span class="section-number">2.162. </span>Pragma Source_File_Name<a class="headerlink" href="#pragma-source-file-name" title="Permalink to this headline">¶</a></h2>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pragma</span> <span class="n">Source_File_Name</span> <span class="p">(</span>
  <span class="p">[</span><span class="n">Unit_Name</span>   <span class="o">=&gt;</span><span class="p">]</span> <span class="n">unit_NAME</span><span class="p">,</span>
  <span class="n">Spec_File_Name</span> <span class="o">=&gt;</span>  <span class="n">STRING_LITERAL</span><span class="p">,</span>
  <span class="p">[</span><span class="n">Index</span> <span class="o">=&gt;</span> <span class="n">INTEGER_LITERAL</span><span class="p">]);</span>

<span class="n">pragma</span> <span class="n">Source_File_Name</span> <span class="p">(</span>
  <span class="p">[</span><span class="n">Unit_Name</span>   <span class="o">=&gt;</span><span class="p">]</span> <span class="n">unit_NAME</span><span class="p">,</span>
  <span class="n">Body_File_Name</span> <span class="o">=&gt;</span>  <span class="n">STRING_LITERAL</span><span class="p">,</span>
  <span class="p">[</span><span class="n">Index</span> <span class="o">=&gt;</span> <span class="n">INTEGER_LITERAL</span><span class="p">]);</span>
</pre></div>
</div>
<p>Use this to override the normal naming convention.  It is a configuration
pragma, and so has the usual applicability of configuration pragmas
(i.e., it applies to either an entire partition, or to all units in a
compilation, or to a single unit, depending on how it is used.
<code class="docutils literal notranslate"><span class="pre">unit_name</span></code> is mapped to <code class="docutils literal notranslate"><span class="pre">file_name_literal</span></code>.  The identifier for
the second argument is required, and indicates whether this is the file
name for the spec or for the body.</p>
<p>The optional Index argument should be used when a file contains multiple
units, and when you do not want to use <code class="docutils literal notranslate"><span class="pre">gnatchop</span></code> to separate then
into multiple files (which is the recommended procedure to limit the
number of recompilations that are needed when some sources change).
For instance, if the source file <code class="file docutils literal notranslate"><span class="pre">source.ada</span></code> contains</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="k">package </span><span class="nf">B</span> <span class="kr">is</span><span class="p"></span>
<span class="o">...</span>
<span class="k">end </span><span class="nf">B</span><span class="p">;</span>

<span class="kr">with</span><span class="nn"> B;</span>
<span class="k">procedure </span><span class="nf">A</span> <span class="kr">is</span><span class="p"></span>
<span class="kr">begin</span><span class="p"></span>
   <span class="o">..</span>
<span class="k">end </span><span class="nf">A</span><span class="p">;</span>
</pre></div>
</div>
<p>you could use the following configuration pragmas:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma</span><span class="p"> </span><span class="n">Source_File_Name</span>
  <span class="o">(</span><span class="n">B</span><span class="p">,</span> <span class="n">Spec_File_Name</span> <span class="o">=&gt;</span> <span class="s">&quot;source.ada&quot;</span><span class="p">,</span> <span class="n">Index</span> <span class="o">=&gt;</span> <span class="mi">1</span><span class="o">)</span><span class="p">;</span>
<span class="kr">pragma</span><span class="p"> </span><span class="n">Source_File_Name</span>
  <span class="o">(</span><span class="n">A</span><span class="p">,</span> <span class="n">Body_File_Name</span> <span class="o">=&gt;</span> <span class="s">&quot;source.ada&quot;</span><span class="p">,</span> <span class="n">Index</span> <span class="o">=&gt;</span> <span class="mi">2</span><span class="o">)</span><span class="p">;</span>
</pre></div>
</div>
<p>Note that the <code class="docutils literal notranslate"><span class="pre">gnatname</span></code> utility can also be used to generate those
configuration pragmas.</p>
<p>Another form of the <code class="docutils literal notranslate"><span class="pre">Source_File_Name</span></code> pragma allows
the specification of patterns defining alternative file naming schemes
to apply to all files.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pragma</span> <span class="n">Source_File_Name</span>
  <span class="p">(</span>  <span class="p">[</span><span class="n">Spec_File_Name</span>  <span class="o">=&gt;</span><span class="p">]</span> <span class="n">STRING_LITERAL</span>
   <span class="p">[,[</span><span class="n">Casing</span>          <span class="o">=&gt;</span><span class="p">]</span> <span class="n">CASING_SPEC</span><span class="p">]</span>
   <span class="p">[,[</span><span class="n">Dot_Replacement</span> <span class="o">=&gt;</span><span class="p">]</span> <span class="n">STRING_LITERAL</span><span class="p">]);</span>

<span class="n">pragma</span> <span class="n">Source_File_Name</span>
  <span class="p">(</span>  <span class="p">[</span><span class="n">Body_File_Name</span>  <span class="o">=&gt;</span><span class="p">]</span> <span class="n">STRING_LITERAL</span>
   <span class="p">[,[</span><span class="n">Casing</span>          <span class="o">=&gt;</span><span class="p">]</span> <span class="n">CASING_SPEC</span><span class="p">]</span>
   <span class="p">[,[</span><span class="n">Dot_Replacement</span> <span class="o">=&gt;</span><span class="p">]</span> <span class="n">STRING_LITERAL</span><span class="p">]);</span>

<span class="n">pragma</span> <span class="n">Source_File_Name</span>
  <span class="p">(</span>  <span class="p">[</span><span class="n">Subunit_File_Name</span> <span class="o">=&gt;</span><span class="p">]</span> <span class="n">STRING_LITERAL</span>
   <span class="p">[,[</span><span class="n">Casing</span>            <span class="o">=&gt;</span><span class="p">]</span> <span class="n">CASING_SPEC</span><span class="p">]</span>
   <span class="p">[,[</span><span class="n">Dot_Replacement</span>   <span class="o">=&gt;</span><span class="p">]</span> <span class="n">STRING_LITERAL</span><span class="p">]);</span>

<span class="n">CASING_SPEC</span> <span class="p">:</span><span class="o">:=</span> <span class="n">Lowercase</span> <span class="o">|</span> <span class="n">Uppercase</span> <span class="o">|</span> <span class="n">Mixedcase</span>
</pre></div>
</div>
<p>The first argument is a pattern that contains a single asterisk indicating
the point at which the unit name is to be inserted in the pattern string
to form the file name.  The second argument is optional.  If present it
specifies the casing of the unit name in the resulting file name string.
The default is lower case.  Finally the third argument allows for systematic
replacement of any dots in the unit name by the specified string literal.</p>
<p>Note that Source_File_Name pragmas should not be used if you are using
project files. The reason for this rule is that the project manager is not
aware of these pragmas, and so other tools that use the projet file would not
be aware of the intended naming conventions. If you are using project files,
file naming is controlled by Source_File_Name_Project pragmas, which are
usually supplied automatically by the project manager. A pragma
Source_File_Name cannot appear after a <a class="reference internal" href="#pragma-source-file-name-project"><span class="std std-ref">Pragma Source_File_Name_Project</span></a>.</p>
<p>For more details on the use of the <code class="docutils literal notranslate"><span class="pre">Source_File_Name</span></code> pragma, see the
sections on <cite>Using Other File Names</cite> and <cite>Alternative File Naming Schemes</cite>
in the <cite>GNAT User’s Guide</cite>.</p>
</div>
<div class="section" id="pragma-source-file-name-project">
<span id="id41"></span><h2><span class="section-number">2.163. </span>Pragma Source_File_Name_Project<a class="headerlink" href="#pragma-source-file-name-project" title="Permalink to this headline">¶</a></h2>
<p>This pragma has the same syntax and semantics as pragma Source_File_Name.
It is only allowed as a stand-alone configuration pragma.
It cannot appear after a <a class="reference internal" href="#pragma-source-file-name"><span class="std std-ref">Pragma Source_File_Name</span></a>, and
most importantly, once pragma Source_File_Name_Project appears,
no further Source_File_Name pragmas are allowed.</p>
<p>The intention is that Source_File_Name_Project pragmas are always
generated by the Project Manager in a manner consistent with the naming
specified in a project file, and when naming is controlled in this manner,
it is not permissible to attempt to modify this naming scheme using
Source_File_Name or Source_File_Name_Project pragmas (which would not be
known to the project manager).</p>
</div>
<div class="section" id="pragma-source-reference">
<h2><span class="section-number">2.164. </span>Pragma Source_Reference<a class="headerlink" href="#pragma-source-reference" title="Permalink to this headline">¶</a></h2>
<p>Syntax:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma</span><span class="p"> </span><span class="n">Source_Reference</span> <span class="o">(</span><span class="n">INTEGER_LITERAL</span><span class="p">,</span> <span class="n">STRING_LITERAL</span><span class="o">)</span><span class="p">;</span>
</pre></div>
</div>
<p>This pragma must appear as the first line of a source file.
<code class="docutils literal notranslate"><span class="pre">integer_literal</span></code> is the logical line number of the line following
the pragma line (for use in error messages and debugging
information).  <code class="docutils literal notranslate"><span class="pre">string_literal</span></code> is a static string constant that
specifies the file name to be used in error messages and debugging
information.  This is most notably used for the output of <code class="docutils literal notranslate"><span class="pre">gnatchop</span></code>
with the <em>-r</em> switch, to make sure that the original unchopped
source file is the one referred to.</p>
<p>The second argument must be a string literal, it cannot be a static
string expression other than a string literal.  This is because its value
is needed for error messages issued by all phases of the compiler.</p>
</div>
<div class="section" id="pragma-spark-mode">
<span id="id42"></span><h2><span class="section-number">2.165. </span>Pragma SPARK_Mode<a class="headerlink" href="#pragma-spark-mode" title="Permalink to this headline">¶</a></h2>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pragma</span> <span class="n">SPARK_Mode</span> <span class="p">[(</span><span class="n">On</span> <span class="o">|</span> <span class="n">Off</span><span class="p">)]</span> <span class="p">;</span>
</pre></div>
</div>
<p>In general a program can have some parts that are in SPARK 2014 (and
follow all the rules in the SPARK Reference Manual), and some parts
that are full Ada 2012.</p>
<p>The SPARK_Mode pragma is used to identify which parts are in SPARK
2014 (by default programs are in full Ada). The SPARK_Mode pragma can
be used in the following places:</p>
<ul class="simple">
<li><p>As a configuration pragma, in which case it sets the default mode for
all units compiled with this pragma.</p></li>
<li><p>Immediately following a library-level subprogram spec</p></li>
<li><p>Immediately within a library-level package body</p></li>
<li><p>Immediately following the <code class="docutils literal notranslate"><span class="pre">private</span></code> keyword of a library-level
package spec</p></li>
<li><p>Immediately following the <code class="docutils literal notranslate"><span class="pre">begin</span></code> keyword of a library-level
package body</p></li>
<li><p>Immediately within a library-level subprogram body</p></li>
</ul>
<p>Normally a subprogram or package spec/body inherits the current mode
that is active at the point it is declared. But this can be overridden
by pragma within the spec or body as above.</p>
<p>The basic consistency rule is that you can’t turn SPARK_Mode back
<code class="docutils literal notranslate"><span class="pre">On</span></code>, once you have explicitly (with a pragma) turned if
<code class="docutils literal notranslate"><span class="pre">Off</span></code>. So the following rules apply:</p>
<p>If a subprogram spec has SPARK_Mode <code class="docutils literal notranslate"><span class="pre">Off</span></code>, then the body must
also have SPARK_Mode <code class="docutils literal notranslate"><span class="pre">Off</span></code>.</p>
<p>For a package, we have four parts:</p>
<ul class="simple">
<li><p>the package public declarations</p></li>
<li><p>the package private part</p></li>
<li><p>the body of the package</p></li>
<li><p>the elaboration code after <code class="docutils literal notranslate"><span class="pre">begin</span></code></p></li>
</ul>
<p>For a package, the rule is that if you explicitly turn SPARK_Mode
<code class="docutils literal notranslate"><span class="pre">Off</span></code> for any part, then all the following parts must have
SPARK_Mode <code class="docutils literal notranslate"><span class="pre">Off</span></code>. Note that this may require repeating a pragma
SPARK_Mode (<code class="docutils literal notranslate"><span class="pre">Off</span></code>) in the body. For example, if we have a
configuration pragma SPARK_Mode (<code class="docutils literal notranslate"><span class="pre">On</span></code>) that turns the mode on by
default everywhere, and one particular package spec has pragma
SPARK_Mode (<code class="docutils literal notranslate"><span class="pre">Off</span></code>), then that pragma will need to be repeated in
the package body.</p>
</div>
<div class="section" id="pragma-static-elaboration-desired">
<h2><span class="section-number">2.166. </span>Pragma Static_Elaboration_Desired<a class="headerlink" href="#pragma-static-elaboration-desired" title="Permalink to this headline">¶</a></h2>
<p>Syntax:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma</span><span class="p"> </span><span class="n">Static_Elaboration_Desired</span><span class="p">;</span>
</pre></div>
</div>
<p>This pragma is used to indicate that the compiler should attempt to initialize
statically the objects declared in the library unit to which the pragma applies,
when these objects are initialized (explicitly or implicitly) by an aggregate.
In the absence of this pragma, aggregates in object declarations are expanded
into assignments and loops, even when the aggregate components are static
constants. When the aggregate is present the compiler builds a static expression
that requires no run-time code, so that the initialized object can be placed in
read-only data space. If the components are not static, or the aggregate has
more that 100 components, the compiler emits a warning that the pragma cannot
be obeyed. (See also the restriction No_Implicit_Loops, which supports static
construction of larger aggregates with static components that include an others
choice.)</p>
</div>
<div class="section" id="pragma-stream-convert">
<h2><span class="section-number">2.167. </span>Pragma Stream_Convert<a class="headerlink" href="#pragma-stream-convert" title="Permalink to this headline">¶</a></h2>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pragma</span> <span class="n">Stream_Convert</span> <span class="p">(</span>
  <span class="p">[</span><span class="n">Entity</span> <span class="o">=&gt;</span><span class="p">]</span> <span class="n">type_LOCAL_NAME</span><span class="p">,</span>
  <span class="p">[</span><span class="n">Read</span>   <span class="o">=&gt;</span><span class="p">]</span> <span class="n">function_NAME</span><span class="p">,</span>
  <span class="p">[</span><span class="n">Write</span>  <span class="o">=&gt;</span><span class="p">]</span> <span class="n">function_NAME</span><span class="p">);</span>
</pre></div>
</div>
<p>This pragma provides an efficient way of providing user-defined stream
attributes.  Not only is it simpler to use than specifying the attributes
directly, but more importantly, it allows the specification to be made in such
a way that the predefined unit Ada.Streams is not loaded unless it is actually
needed (i.e. unless the stream attributes are actually used); the use of
the Stream_Convert pragma adds no overhead at all, unless the stream
attributes are actually used on the designated type.</p>
<p>The first argument specifies the type for which stream functions are
provided.  The second parameter provides a function used to read values
of this type.  It must name a function whose argument type may be any
subtype, and whose returned type must be the type given as the first
argument to the pragma.</p>
<p>The meaning of the <code class="docutils literal notranslate"><span class="pre">Read</span></code> parameter is that if a stream attribute directly
or indirectly specifies reading of the type given as the first parameter,
then a value of the type given as the argument to the Read function is
read from the stream, and then the Read function is used to convert this
to the required target type.</p>
<p>Similarly the <code class="docutils literal notranslate"><span class="pre">Write</span></code> parameter specifies how to treat write attributes
that directly or indirectly apply to the type given as the first parameter.
It must have an input parameter of the type specified by the first parameter,
and the return type must be the same as the input type of the Read function.
The effect is to first call the Write function to convert to the given stream
type, and then write the result type to the stream.</p>
<p>The Read and Write functions must not be overloaded subprograms.  If necessary
renamings can be supplied to meet this requirement.
The usage of this attribute is best illustrated by a simple example, taken
from the GNAT implementation of package Ada.Strings.Unbounded:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="k">function </span><span class="nf">To_Unbounded</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">String</span><span class="o">)</span> <span class="kr">return</span><span class="p"> </span><span class="n">Unbounded_String</span>
  <span class="kr">renames</span><span class="p"> </span><span class="n">To_Unbounded_String</span><span class="p">;</span>

<span class="kr">pragma</span><span class="p"> </span><span class="n">Stream_Convert</span>
  <span class="o">(</span><span class="n">Unbounded_String</span><span class="p">,</span> <span class="n">To_Unbounded</span><span class="p">,</span> <span class="n">To_String</span><span class="o">)</span><span class="p">;</span>
</pre></div>
</div>
<p>The specifications of the referenced functions, as given in the Ada
Reference Manual are:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="k">function </span><span class="nf">To_Unbounded_String</span> <span class="o">(</span><span class="n">Source</span> <span class="o">:</span> <span class="n">String</span><span class="o">)</span>
  <span class="kr">return</span><span class="p"> </span><span class="n">Unbounded_String</span><span class="p">;</span>

<span class="k">function </span><span class="nf">To_String</span> <span class="o">(</span><span class="n">Source</span> <span class="o">:</span> <span class="n">Unbounded_String</span><span class="o">)</span>
  <span class="kr">return</span><span class="p"> </span><span class="n">String</span><span class="p">;</span>
</pre></div>
</div>
<p>The effect is that if the value of an unbounded string is written to a stream,
then the representation of the item in the stream is in the same format that
would be used for <code class="docutils literal notranslate"><span class="pre">Standard.String'Output</span></code>, and this same representation
is expected when a value of this type is read from the stream. Note that the
value written always includes the bounds, even for Unbounded_String’Write,
since Unbounded_String is not an array type.</p>
<p>Note that the <code class="docutils literal notranslate"><span class="pre">Stream_Convert</span></code> pragma is not effective in the case of
a derived type of a non-limited tagged type. If such a type is specified then
the pragma is silently ignored, and the default implementation of the stream
attributes is used instead.</p>
</div>
<div class="section" id="pragma-style-checks">
<h2><span class="section-number">2.168. </span>Pragma Style_Checks<a class="headerlink" href="#pragma-style-checks" title="Permalink to this headline">¶</a></h2>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pragma</span> <span class="n">Style_Checks</span> <span class="p">(</span><span class="n">string_LITERAL</span> <span class="o">|</span> <span class="n">ALL_CHECKS</span> <span class="o">|</span>
                     <span class="n">On</span> <span class="o">|</span> <span class="n">Off</span> <span class="p">[,</span> <span class="n">LOCAL_NAME</span><span class="p">]);</span>
</pre></div>
</div>
<p>This pragma is used in conjunction with compiler switches to control the
built in style checking provided by GNAT.  The compiler switches, if set,
provide an initial setting for the switches, and this pragma may be used
to modify these settings, or the settings may be provided entirely by
the use of the pragma.  This pragma can be used anywhere that a pragma
is legal, including use as a configuration pragma (including use in
the <code class="file docutils literal notranslate"><span class="pre">gnat.adc</span></code> file).</p>
<p>The form with a string literal specifies which style options are to be
activated.  These are additive, so they apply in addition to any previously
set style check options.  The codes for the options are the same as those
used in the <em>-gnaty</em> switch to <em>gcc</em> or <em>gnatmake</em>.
For example the following two methods can be used to enable
layout checking:</p>
<ul>
<li><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pragma</span> <span class="n">Style_Checks</span> <span class="p">(</span><span class="s2">&quot;l&quot;</span><span class="p">);</span>
</pre></div>
</div>
</li>
<li><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">gcc</span> <span class="o">-</span><span class="n">c</span> <span class="o">-</span><span class="n">gnatyl</span> <span class="o">...</span>
</pre></div>
</div>
</li>
</ul>
<p>The form <code class="docutils literal notranslate"><span class="pre">ALL_CHECKS</span></code> activates all standard checks (its use is equivalent
to the use of the <code class="switch docutils literal notranslate"><span class="pre">gnaty</span></code> switch with no options.
See the <cite>GNAT User’s Guide</cite> for details.)</p>
<p>Note: the behavior is slightly different in GNAT mode (<code class="switch docutils literal notranslate"><span class="pre">-gnatg</span></code> used).
In this case, <code class="docutils literal notranslate"><span class="pre">ALL_CHECKS</span></code> implies the standard set of GNAT mode style check
options (i.e. equivalent to <code class="switch docutils literal notranslate"><span class="pre">-gnatyg</span></code>).</p>
<p>The forms with <code class="docutils literal notranslate"><span class="pre">Off</span></code> and <code class="docutils literal notranslate"><span class="pre">On</span></code>
can be used to temporarily disable style checks
as shown in the following example:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma</span><span class="p"> </span><span class="n">Style_Checks</span> <span class="o">(</span><span class="s">&quot;k&quot;</span><span class="o">)</span><span class="p">;</span> <span class="c">-- requires keywords in lower case</span>
<span class="kr">pragma</span><span class="p"> </span><span class="n">Style_Checks</span> <span class="o">(</span><span class="n">Off</span><span class="o">)</span><span class="p">;</span> <span class="c">-- turn off style checks</span>
<span class="kr">NULL</span><span class="p">;</span>                      <span class="c">-- this will not generate an error message</span>
<span class="kr">pragma</span><span class="p"> </span><span class="n">Style_Checks</span> <span class="o">(</span><span class="n">On</span><span class="o">)</span><span class="p">;</span>  <span class="c">-- turn style checks back on</span>
<span class="kr">NULL</span><span class="p">;</span>                      <span class="c">-- this will generate an error message</span>
</pre></div>
</div>
<p>Finally the two argument form is allowed only if the first argument is
<code class="docutils literal notranslate"><span class="pre">On</span></code> or <code class="docutils literal notranslate"><span class="pre">Off</span></code>.  The effect is to turn of semantic style checks
for the specified entity, as shown in the following example:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma</span><span class="p"> </span><span class="n">Style_Checks</span> <span class="o">(</span><span class="s">&quot;r&quot;</span><span class="o">)</span><span class="p">;</span> <span class="c">-- require consistency of identifier casing</span>
<span class="n">Arg</span> <span class="o">:</span> <span class="n">Integer</span><span class="p">;</span>
<span class="n">Rf1</span> <span class="o">:</span> <span class="n">Integer</span> <span class="o">:=</span> <span class="n">ARG</span><span class="p">;</span>      <span class="c">-- incorrect, wrong case</span>
<span class="kr">pragma</span><span class="p"> </span><span class="n">Style_Checks</span> <span class="o">(</span><span class="n">Off</span><span class="p">,</span> <span class="n">Arg</span><span class="o">)</span><span class="p">;</span>
<span class="n">Rf2</span> <span class="o">:</span> <span class="n">Integer</span> <span class="o">:=</span> <span class="n">ARG</span><span class="p">;</span>      <span class="c">-- OK, no error</span>
</pre></div>
</div>
</div>
<div class="section" id="pragma-subtitle">
<h2><span class="section-number">2.169. </span>Pragma Subtitle<a class="headerlink" href="#pragma-subtitle" title="Permalink to this headline">¶</a></h2>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pragma</span> <span class="n">Subtitle</span> <span class="p">([</span><span class="n">Subtitle</span> <span class="o">=&gt;</span><span class="p">]</span> <span class="n">STRING_LITERAL</span><span class="p">);</span>
</pre></div>
</div>
<p>This pragma is recognized for compatibility with other Ada compilers
but is ignored by GNAT.</p>
</div>
<div class="section" id="pragma-suppress">
<h2><span class="section-number">2.170. </span>Pragma Suppress<a class="headerlink" href="#pragma-suppress" title="Permalink to this headline">¶</a></h2>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pragma</span> <span class="n">Suppress</span> <span class="p">(</span><span class="n">Identifier</span> <span class="p">[,</span> <span class="p">[</span><span class="n">On</span> <span class="o">=&gt;</span><span class="p">]</span> <span class="n">Name</span><span class="p">]);</span>
</pre></div>
</div>
<p>This is a standard pragma, and supports all the check names required in
the RM. It is included here because GNAT recognizes some additional check
names that are implementation defined (as permitted by the RM):</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Alignment_Check</span></code> can be used to suppress alignment checks
on addresses used in address clauses. Such checks can also be suppressed
by suppressing range checks, but the specific use of <code class="docutils literal notranslate"><span class="pre">Alignment_Check</span></code>
allows suppression of alignment checks without suppressing other range checks.
Note that <code class="docutils literal notranslate"><span class="pre">Alignment_Check</span></code> is suppressed by default on machines (such as
the x86) with non-strict alignment.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Atomic_Synchronization</span></code> can be used to suppress the special memory
synchronization instructions that are normally generated for access to
<code class="docutils literal notranslate"><span class="pre">Atomic</span></code> variables to ensure correct synchronization between tasks
that use such variables for synchronization purposes.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Duplicated_Tag_Check</span></code> Can be used to suppress the check that is generated
for a duplicated tag value when a tagged type is declared.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Container_Checks</span></code> Can be used to suppress all checks within Ada.Containers
and instances of its children, including Tampering_Check.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Tampering_Check</span></code> Can be used to suppress tampering check in the containers.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Predicate_Check</span></code> can be used to control whether predicate checks are
active. It is applicable only to predicates for which the policy is
<code class="docutils literal notranslate"><span class="pre">Check</span></code>. Unlike <code class="docutils literal notranslate"><span class="pre">Assertion_Policy</span></code>, which determines if a given
predicate is ignored or checked for the whole program, the use of
<code class="docutils literal notranslate"><span class="pre">Suppress</span></code> and <code class="docutils literal notranslate"><span class="pre">Unsuppress</span></code> with this check name allows a given
predicate to be turned on and off at specific points in the program.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Validity_Check</span></code> can be used specifically to control validity checks.
If <code class="docutils literal notranslate"><span class="pre">Suppress</span></code> is used to suppress validity checks, then no validity
checks are performed, including those specified by the appropriate compiler
switch or the <code class="docutils literal notranslate"><span class="pre">Validity_Checks</span></code> pragma.</p></li>
<li><p>Additional check names previously introduced by use of the <code class="docutils literal notranslate"><span class="pre">Check_Name</span></code>
pragma are also allowed.</p></li>
</ul>
<p>Note that pragma Suppress gives the compiler permission to omit
checks, but does not require the compiler to omit checks. The compiler
will generate checks if they are essentially free, even when they are
suppressed. In particular, if the compiler can prove that a certain
check will necessarily fail, it will generate code to do an
unconditional ‘raise’, even if checks are suppressed. The compiler
warns in this case.</p>
<p>Of course, run-time checks are omitted whenever the compiler can prove
that they will not fail, whether or not checks are suppressed.</p>
</div>
<div class="section" id="pragma-suppress-all">
<h2><span class="section-number">2.171. </span>Pragma Suppress_All<a class="headerlink" href="#pragma-suppress-all" title="Permalink to this headline">¶</a></h2>
<p>Syntax:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma</span><span class="p"> </span><span class="n">Suppress_All</span><span class="p">;</span>
</pre></div>
</div>
<p>This pragma can appear anywhere within a unit.
The effect is to apply <code class="docutils literal notranslate"><span class="pre">Suppress</span> <span class="pre">(All_Checks)</span></code> to the unit
in which it appears.  This pragma is implemented for compatibility with DEC
Ada 83 usage where it appears at the end of a unit, and for compatibility
with Rational Ada, where it appears as a program unit pragma.
The use of the standard Ada pragma <code class="docutils literal notranslate"><span class="pre">Suppress</span> <span class="pre">(All_Checks)</span></code>
as a normal configuration pragma is the preferred usage in GNAT.</p>
</div>
<div class="section" id="pragma-suppress-debug-info">
<span id="id43"></span><h2><span class="section-number">2.172. </span>Pragma Suppress_Debug_Info<a class="headerlink" href="#pragma-suppress-debug-info" title="Permalink to this headline">¶</a></h2>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pragma</span> <span class="n">Suppress_Debug_Info</span> <span class="p">([</span><span class="n">Entity</span> <span class="o">=&gt;</span><span class="p">]</span> <span class="n">LOCAL_NAME</span><span class="p">);</span>
</pre></div>
</div>
<p>This pragma can be used to suppress generation of debug information
for the specified entity. It is intended primarily for use in debugging
the debugger, and navigating around debugger problems.</p>
</div>
<div class="section" id="pragma-suppress-exception-locations">
<h2><span class="section-number">2.173. </span>Pragma Suppress_Exception_Locations<a class="headerlink" href="#pragma-suppress-exception-locations" title="Permalink to this headline">¶</a></h2>
<p>Syntax:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma</span><span class="p"> </span><span class="n">Suppress_Exception_Locations</span><span class="p">;</span>
</pre></div>
</div>
<p>In normal mode, a raise statement for an exception by default generates
an exception message giving the file name and line number for the location
of the raise. This is useful for debugging and logging purposes, but this
entails extra space for the strings for the messages. The configuration
pragma <code class="docutils literal notranslate"><span class="pre">Suppress_Exception_Locations</span></code> can be used to suppress the
generation of these strings, with the result that space is saved, but the
exception message for such raises is null. This configuration pragma may
appear in a global configuration pragma file, or in a specific unit as
usual. It is not required that this pragma be used consistently within
a partition, so it is fine to have some units within a partition compiled
with this pragma and others compiled in normal mode without it.</p>
</div>
<div class="section" id="pragma-suppress-initialization">
<span id="id44"></span><h2><span class="section-number">2.174. </span>Pragma Suppress_Initialization<a class="headerlink" href="#pragma-suppress-initialization" title="Permalink to this headline">¶</a></h2>
<span class="target" id="index-70"></span><p id="index-71">Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pragma</span> <span class="n">Suppress_Initialization</span> <span class="p">([</span><span class="n">Entity</span> <span class="o">=&gt;</span><span class="p">]</span> <span class="n">variable_or_subtype_Name</span><span class="p">);</span>
</pre></div>
</div>
<p>Here variable_or_subtype_Name is the name introduced by a type declaration
or subtype declaration or the name of a variable introduced by an
object declaration.</p>
<p>In the case of a type or subtype
this pragma suppresses any implicit or explicit initialization
for all variables of the given type or subtype,
including initialization resulting from the use of pragmas
Normalize_Scalars or Initialize_Scalars.</p>
<p>This is considered a representation item, so it cannot be given after
the type is frozen. It applies to all subsequent object declarations,
and also any allocator that creates objects of the type.</p>
<p>If the pragma is given for the first subtype, then it is considered
to apply to the base type and all its subtypes. If the pragma is given
for other than a first subtype, then it applies only to the given subtype.
The pragma may not be given after the type is frozen.</p>
<p>Note that this includes eliminating initialization of discriminants
for discriminated types, and tags for tagged types. In these cases,
you will have to use some non-portable mechanism (e.g. address
overlays or unchecked conversion) to achieve required initialization
of these fields before accessing any object of the corresponding type.</p>
<p>For the variable case, implicit initialization for the named variable
is suppressed, just as though its subtype had been given in a pragma
Suppress_Initialization, as described above.</p>
</div>
<div class="section" id="pragma-task-name">
<h2><span class="section-number">2.175. </span>Pragma Task_Name<a class="headerlink" href="#pragma-task-name" title="Permalink to this headline">¶</a></h2>
<p>Syntax</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma</span><span class="p"> </span><span class="n">Task_Name</span> <span class="o">(</span><span class="n">string_EXPRESSION</span><span class="o">)</span><span class="p">;</span>
</pre></div>
</div>
<p>This pragma appears within a task definition (like pragma
<code class="docutils literal notranslate"><span class="pre">Priority</span></code>) and applies to the task in which it appears.  The
argument must be of type String, and provides a name to be used for
the task instance when the task is created.  Note that this expression
is not required to be static, and in particular, it can contain
references to task discriminants.  This facility can be used to
provide different names for different tasks as they are created,
as illustrated in the example below.</p>
<p>The task name is recorded internally in the run-time structures
and is accessible to tools like the debugger.  In addition the
routine <code class="docutils literal notranslate"><span class="pre">Ada.Task_Identification.Image</span></code> will return this
string, with a unique task address appended.</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="c">--  Example of the use of pragma Task_Name</span><span class="p"></span>

<span class="kr">with</span><span class="nn"> Ada.Task_Identification;</span><span class="p"></span>
<span class="kr">use</span><span class="nn"> Ada.Task_Identification;</span><span class="p"></span>
<span class="kr">with</span><span class="nn"> Text_IO;</span> <span class="kr">use</span><span class="p"> </span><span class="n">Text_IO</span><span class="p">;</span>
<span class="k">procedure </span><span class="nf">t3</span> <span class="kr">is</span><span class="p"></span>

   <span class="kr">type</span><span class="p"> </span><span class="n">Astring</span> <span class="kr">is</span><span class="p"> </span><span class="kr">access</span><span class="p"> </span><span class="n">String</span><span class="p">;</span>

   <span class="kr">task</span><span class="p"> </span><span class="kr">type</span><span class="p"> </span><span class="n">Task_Typ</span> <span class="o">(</span><span class="n">Name</span> <span class="o">:</span> <span class="kr">access</span><span class="p"> </span><span class="n">String</span><span class="o">)</span> <span class="kr">is</span><span class="p"></span>
      <span class="kr">pragma</span><span class="p"> </span><span class="n">Task_Name</span> <span class="o">(</span><span class="n">Name.all</span><span class="o">)</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">Task_Typ</span><span class="p">;</span>

   <span class="kr">task</span><span class="p"> </span><span class="kr">body</span><span class="p"> </span><span class="n">Task_Typ</span> <span class="kr">is</span><span class="p"></span>
      <span class="n">Nam</span> <span class="o">:</span> <span class="kr">constant</span><span class="p"> </span><span class="n">String</span> <span class="o">:=</span> <span class="n">Image</span> <span class="o">(</span><span class="n">Current_Task</span><span class="o">)</span><span class="p">;</span>
   <span class="kr">begin</span><span class="p"></span>
      <span class="n">Put_Line</span> <span class="o">(</span><span class="s">&quot;--&gt;&quot;</span> <span class="o">&amp;</span> <span class="n">Nam</span> <span class="o">(</span><span class="mi">1</span> <span class="o">..</span> <span class="mi">14</span><span class="o">)</span> <span class="o">&amp;</span> <span class="s">&quot;&lt;--&quot;</span><span class="o">)</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">Task_Typ</span><span class="p">;</span>

   <span class="kr">type</span><span class="p"> </span><span class="n">Ptr_Task</span> <span class="kr">is</span><span class="p"> </span><span class="kr">access</span><span class="p"> </span><span class="n">Task_Typ</span><span class="p">;</span>
   <span class="n">Task_Var</span> <span class="o">:</span> <span class="n">Ptr_Task</span><span class="p">;</span>

<span class="kr">begin</span><span class="p"></span>
   <span class="n">Task_Var</span> <span class="o">:=</span>
     <span class="kr">new</span><span class="p"> </span><span class="n">Task_Typ</span> <span class="o">(</span><span class="kr">new</span><span class="p"> </span><span class="n">String</span><span class="o">&#39;(</span><span class="s">&quot;This is task 1&quot;</span><span class="o">))</span><span class="p">;</span>
   <span class="n">Task_Var</span> <span class="o">:=</span>
     <span class="kr">new</span><span class="p"> </span><span class="n">Task_Typ</span> <span class="o">(</span><span class="kr">new</span><span class="p"> </span><span class="n">String</span><span class="o">&#39;(</span><span class="s">&quot;This is task 2&quot;</span><span class="o">))</span><span class="p">;</span>
<span class="kr">end</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="pragma-task-storage">
<h2><span class="section-number">2.176. </span>Pragma Task_Storage<a class="headerlink" href="#pragma-task-storage" title="Permalink to this headline">¶</a></h2>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pragma</span> <span class="n">Task_Storage</span> <span class="p">(</span>
  <span class="p">[</span><span class="n">Task_Type</span> <span class="o">=&gt;</span><span class="p">]</span> <span class="n">LOCAL_NAME</span><span class="p">,</span>
  <span class="p">[</span><span class="n">Top_Guard</span> <span class="o">=&gt;</span><span class="p">]</span> <span class="n">static_integer_EXPRESSION</span><span class="p">);</span>
</pre></div>
</div>
<p>This pragma specifies the length of the guard area for tasks.  The guard
area is an additional storage area allocated to a task.  A value of zero
means that either no guard area is created or a minimal guard area is
created, depending on the target.  This pragma can appear anywhere a
<code class="docutils literal notranslate"><span class="pre">Storage_Size</span></code> attribute definition clause is allowed for a task
type.</p>
</div>
<div class="section" id="pragma-test-case">
<span id="id45"></span><h2><span class="section-number">2.177. </span>Pragma Test_Case<a class="headerlink" href="#pragma-test-case" title="Permalink to this headline">¶</a></h2>
<p id="index-72">Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pragma</span> <span class="n">Test_Case</span> <span class="p">(</span>
   <span class="p">[</span><span class="n">Name</span>     <span class="o">=&gt;</span><span class="p">]</span> <span class="n">static_string_Expression</span>
  <span class="p">,[</span><span class="n">Mode</span>     <span class="o">=&gt;</span><span class="p">]</span> <span class="p">(</span><span class="n">Nominal</span> <span class="o">|</span> <span class="n">Robustness</span><span class="p">)</span>
 <span class="p">[,</span> <span class="n">Requires</span> <span class="o">=&gt;</span>  <span class="n">Boolean_Expression</span><span class="p">]</span>
 <span class="p">[,</span> <span class="n">Ensures</span>  <span class="o">=&gt;</span>  <span class="n">Boolean_Expression</span><span class="p">]);</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">Test_Case</span></code> pragma allows defining fine-grain specifications
for use by testing tools.
The compiler checks the validity of the <code class="docutils literal notranslate"><span class="pre">Test_Case</span></code> pragma, but its
presence does not lead to any modification of the code generated by the
compiler.</p>
<p><code class="docutils literal notranslate"><span class="pre">Test_Case</span></code> pragmas may only appear immediately following the
(separate) declaration of a subprogram in a package declaration, inside
a package spec unit. Only other pragmas may intervene (that is appear
between the subprogram declaration and a test case).</p>
<p>The compiler checks that boolean expressions given in <code class="docutils literal notranslate"><span class="pre">Requires</span></code> and
<code class="docutils literal notranslate"><span class="pre">Ensures</span></code> are valid, where the rules for <code class="docutils literal notranslate"><span class="pre">Requires</span></code> are the
same as the rule for an expression in <code class="docutils literal notranslate"><span class="pre">Precondition</span></code> and the rules
for <code class="docutils literal notranslate"><span class="pre">Ensures</span></code> are the same as the rule for an expression in
<code class="docutils literal notranslate"><span class="pre">Postcondition</span></code>. In particular, attributes <code class="docutils literal notranslate"><span class="pre">'Old</span></code> and
<code class="docutils literal notranslate"><span class="pre">'Result</span></code> can only be used within the <code class="docutils literal notranslate"><span class="pre">Ensures</span></code>
expression. The following is an example of use within a package spec:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="k">package </span><span class="nf">Math_Functions</span> <span class="kr">is</span><span class="p"></span>
   <span class="o">...</span>
   <span class="k">function </span><span class="nf">Sqrt</span> <span class="o">(</span><span class="n">Arg</span> <span class="o">:</span> <span class="n">Float</span><span class="o">)</span> <span class="kr">return</span><span class="p"> </span><span class="n">Float</span><span class="p">;</span>
   <span class="kr">pragma</span><span class="p"> </span><span class="n">Test_Case</span> <span class="o">(</span><span class="n">Name</span>     <span class="o">=&gt;</span> <span class="s">&quot;Test 1&quot;</span><span class="p">,</span>
                     <span class="n">Mode</span>     <span class="o">=&gt;</span> <span class="n">Nominal</span><span class="p">,</span>
                     <span class="n">Requires</span> <span class="o">=&gt;</span> <span class="n">Arg</span> <span class="o">&lt;</span> <span class="mi">10000</span><span class="o">.</span><span class="mi">0</span><span class="p">,</span>
                     <span class="n">Ensures</span>  <span class="o">=&gt;</span> <span class="n">Sqrt</span><span class="na">&#39;Result</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="o">.</span><span class="mi">0</span><span class="o">)</span><span class="p">;</span>
   <span class="o">...</span>
<span class="k">end </span><span class="nf">Math_Functions</span><span class="p">;</span>
</pre></div>
</div>
<p>The meaning of a test case is that there is at least one context where
<code class="docutils literal notranslate"><span class="pre">Requires</span></code> holds such that, if the associated subprogram is executed in
that context, then <code class="docutils literal notranslate"><span class="pre">Ensures</span></code> holds when the subprogram returns.
Mode <code class="docutils literal notranslate"><span class="pre">Nominal</span></code> indicates that the input context should also satisfy the
precondition of the subprogram, and the output context should also satisfy its
postcondition. Mode <code class="docutils literal notranslate"><span class="pre">Robustness</span></code> indicates that the precondition and
postcondition of the subprogram should be ignored for this test case.</p>
</div>
<div class="section" id="pragma-thread-local-storage">
<span id="id46"></span><h2><span class="section-number">2.178. </span>Pragma Thread_Local_Storage<a class="headerlink" href="#pragma-thread-local-storage" title="Permalink to this headline">¶</a></h2>
<span class="target" id="index-73"></span><span class="target" id="index-74"></span><p id="index-75">Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pragma</span> <span class="n">Thread_Local_Storage</span> <span class="p">([</span><span class="n">Entity</span> <span class="o">=&gt;</span><span class="p">]</span> <span class="n">LOCAL_NAME</span><span class="p">);</span>
</pre></div>
</div>
<p>This pragma specifies that the specified entity, which must be
a variable declared in a library-level package, is to be marked as
“Thread Local Storage” (<code class="docutils literal notranslate"><span class="pre">TLS</span></code>). On systems supporting this (which
include Windows, Solaris, GNU/Linux, and VxWorks 6), this causes each
thread (and hence each Ada task) to see a distinct copy of the variable.</p>
<p>The variable must not have default initialization, and if there is
an explicit initialization, it must be either <code class="docutils literal notranslate"><span class="pre">null</span></code> for an
access variable, a static expression for a scalar variable, or a fully
static aggregate for a composite type, that is to say, an aggregate all
of whose components are static, and which does not include packed or
discriminated components.</p>
<p>This provides a low-level mechanism similar to that provided by
the <code class="docutils literal notranslate"><span class="pre">Ada.Task_Attributes</span></code> package, but much more efficient
and is also useful in writing interface code that will interact
with foreign threads.</p>
<p>If this pragma is used on a system where <code class="docutils literal notranslate"><span class="pre">TLS</span></code> is not supported,
then an error message will be generated and the program will be rejected.</p>
</div>
<div class="section" id="pragma-time-slice">
<h2><span class="section-number">2.179. </span>Pragma Time_Slice<a class="headerlink" href="#pragma-time-slice" title="Permalink to this headline">¶</a></h2>
<p>Syntax:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma</span><span class="p"> </span><span class="n">Time_Slice</span> <span class="o">(</span><span class="n">static_duration_EXPRESSION</span><span class="o">)</span><span class="p">;</span>
</pre></div>
</div>
<p>For implementations of GNAT on operating systems where it is possible
to supply a time slice value, this pragma may be used for this purpose.
It is ignored if it is used in a system that does not allow this control,
or if it appears in other than the main program unit.</p>
</div>
<div class="section" id="pragma-title">
<h2><span class="section-number">2.180. </span>Pragma Title<a class="headerlink" href="#pragma-title" title="Permalink to this headline">¶</a></h2>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pragma</span> <span class="n">Title</span> <span class="p">(</span><span class="n">TITLING_OPTION</span> <span class="p">[,</span> <span class="n">TITLING</span> <span class="n">OPTION</span><span class="p">]);</span>

<span class="n">TITLING_OPTION</span> <span class="p">:</span><span class="o">:=</span>
  <span class="p">[</span><span class="n">Title</span>    <span class="o">=&gt;</span><span class="p">]</span> <span class="n">STRING_LITERAL</span><span class="p">,</span>
<span class="o">|</span> <span class="p">[</span><span class="n">Subtitle</span> <span class="o">=&gt;</span><span class="p">]</span> <span class="n">STRING_LITERAL</span>
</pre></div>
</div>
<p>Syntax checked but otherwise ignored by GNAT.  This is a listing control
pragma used in DEC Ada 83 implementations to provide a title and/or
subtitle for the program listing.  The program listing generated by GNAT
does not have titles or subtitles.</p>
<p>Unlike other pragmas, the full flexibility of named notation is allowed
for this pragma, i.e., the parameters may be given in any order if named
notation is used, and named and positional notation can be mixed
following the normal rules for procedure calls in Ada.</p>
</div>
<div class="section" id="pragma-type-invariant">
<h2><span class="section-number">2.181. </span>Pragma Type_Invariant<a class="headerlink" href="#pragma-type-invariant" title="Permalink to this headline">¶</a></h2>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pragma</span> <span class="n">Type_Invariant</span>
  <span class="p">([</span><span class="n">Entity</span> <span class="o">=&gt;</span><span class="p">]</span> <span class="n">type_LOCAL_NAME</span><span class="p">,</span>
   <span class="p">[</span><span class="n">Check</span>  <span class="o">=&gt;</span><span class="p">]</span> <span class="n">EXPRESSION</span><span class="p">);</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">Type_Invariant</span></code> pragma is intended to be an exact
replacement for the language-defined <code class="docutils literal notranslate"><span class="pre">Type_Invariant</span></code>
aspect, and shares its restrictions and semantics. It differs
from the language defined <code class="docutils literal notranslate"><span class="pre">Invariant</span></code> pragma in that it
does not permit a string parameter, and it is
controlled by the assertion identifier <code class="docutils literal notranslate"><span class="pre">Type_Invariant</span></code>
rather than <code class="docutils literal notranslate"><span class="pre">Invariant</span></code>.</p>
</div>
<div class="section" id="pragma-type-invariant-class">
<span id="id47"></span><h2><span class="section-number">2.182. </span>Pragma Type_Invariant_Class<a class="headerlink" href="#pragma-type-invariant-class" title="Permalink to this headline">¶</a></h2>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pragma</span> <span class="n">Type_Invariant_Class</span>
  <span class="p">([</span><span class="n">Entity</span> <span class="o">=&gt;</span><span class="p">]</span> <span class="n">type_LOCAL_NAME</span><span class="p">,</span>
   <span class="p">[</span><span class="n">Check</span>  <span class="o">=&gt;</span><span class="p">]</span> <span class="n">EXPRESSION</span><span class="p">);</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">Type_Invariant_Class</span></code> pragma is intended to be an exact
replacement for the language-defined <code class="docutils literal notranslate"><span class="pre">Type_Invariant'Class</span></code>
aspect, and shares its restrictions and semantics.</p>
<p>Note: This pragma is called <code class="docutils literal notranslate"><span class="pre">Type_Invariant_Class</span></code> rather than
<code class="docutils literal notranslate"><span class="pre">Type_Invariant'Class</span></code> because the latter would not be strictly
conforming to the allowed syntax for pragmas. The motivation
for providing pragmas equivalent to the aspects is to allow a program
to be written using the pragmas, and then compiled if necessary
using an Ada compiler that does not recognize the pragmas or
aspects, but is prepared to ignore the pragmas. The assertion
policy that controls this pragma is <code class="docutils literal notranslate"><span class="pre">Type_Invariant'Class</span></code>,
not <code class="docutils literal notranslate"><span class="pre">Type_Invariant_Class</span></code>.</p>
</div>
<div class="section" id="pragma-unchecked-union">
<h2><span class="section-number">2.183. </span>Pragma Unchecked_Union<a class="headerlink" href="#pragma-unchecked-union" title="Permalink to this headline">¶</a></h2>
<p id="index-76">Syntax:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma</span><span class="p"> </span><span class="n">Unchecked_Union</span> <span class="o">(</span><span class="n">first_subtype_LOCAL_NAME</span><span class="o">)</span><span class="p">;</span>
</pre></div>
</div>
<p>This pragma is used to specify a representation of a record type that is
equivalent to a C union. It was introduced as a GNAT implementation defined
pragma in the GNAT Ada 95 mode. Ada 2005 includes an extended version of this
pragma, making it language defined, and GNAT fully implements this extended
version in all language modes (Ada 83, Ada 95, and Ada 2005). For full
details, consult the Ada 2012 Reference Manual, section B.3.3.</p>
</div>
<div class="section" id="pragma-unevaluated-use-of-old">
<h2><span class="section-number">2.184. </span>Pragma Unevaluated_Use_Of_Old<a class="headerlink" href="#pragma-unevaluated-use-of-old" title="Permalink to this headline">¶</a></h2>
<span class="target" id="index-77"></span><span class="target" id="index-78"></span><p id="index-79">Syntax:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma</span><span class="p"> </span><span class="n">Unevaluated_Use_Of_Old</span> <span class="o">(</span><span class="n">Error</span> <span class="o">|</span> <span class="n">Warn</span> <span class="o">|</span> <span class="n">Allow</span><span class="o">)</span><span class="p">;</span>
</pre></div>
</div>
<p>This pragma controls the processing of attributes Old and Loop_Entry.
If either of these attributes is used in a potentially unevaluated
expression  (e.g. the then or else parts of an if expression), then
normally this usage is considered illegal if the prefix of the attribute
is other than an entity name. The language requires this
behavior for Old, and GNAT copies the same rule for Loop_Entry.</p>
<p>The reason for this rule is that otherwise, we can have a situation
where we save the Old value, and this results in an exception, even
though we might not evaluate the attribute. Consider this example:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="k">package </span><span class="nf">UnevalOld</span> <span class="kr">is</span><span class="p"></span>
   <span class="n">K</span> <span class="o">:</span> <span class="n">Character</span><span class="p">;</span>
   <span class="k">procedure </span><span class="nf">U</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">String</span><span class="p">;</span> <span class="n">C</span> <span class="o">:</span> <span class="n">Boolean</span><span class="o">)</span>  <span class="c">-- ERROR</span>
     <span class="kr">with</span><span class="p"> </span><span class="n">Post</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="kr">if</span><span class="p"> </span><span class="n">C</span> <span class="kr">then</span><span class="p"> </span><span class="n">A</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span><span class="na">&#39;Old</span> <span class="o">=</span> <span class="n">K</span> <span class="kr">else</span><span class="p"> </span><span class="kc">True</span><span class="o">)</span><span class="p">;</span>
<span class="kr">end</span><span class="p">;</span>
</pre></div>
</div>
<p>If procedure U is called with a string with a lower bound of 2, and
C false, then an exception would be raised trying to evaluate A(1)
on entry even though the value would not be actually used.</p>
<p>Although the rule guarantees against this possibility, it is sometimes
too restrictive. For example if we know that the string has a lower
bound of 1, then we will never raise an exception.
The pragma <code class="docutils literal notranslate"><span class="pre">Unevaluated_Use_Of_Old</span></code> can be
used to modify this behavior. If the argument is <code class="docutils literal notranslate"><span class="pre">Error</span></code> then an
error is given (this is the default RM behavior). If the argument is
<code class="docutils literal notranslate"><span class="pre">Warn</span></code> then the usage is allowed as legal but with a warning
that an exception might be raised. If the argument is <code class="docutils literal notranslate"><span class="pre">Allow</span></code>
then the usage is allowed as legal without generating a warning.</p>
<p>This pragma may appear as a configuration pragma, or in a declarative
part or package specification. In the latter case it applies to
uses up to the end of the corresponding statement sequence or
sequence of package declarations.</p>
</div>
<div class="section" id="pragma-unimplemented-unit">
<h2><span class="section-number">2.185. </span>Pragma Unimplemented_Unit<a class="headerlink" href="#pragma-unimplemented-unit" title="Permalink to this headline">¶</a></h2>
<p>Syntax:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma</span><span class="p"> </span><span class="n">Unimplemented_Unit</span><span class="p">;</span>
</pre></div>
</div>
<p>If this pragma occurs in a unit that is processed by the compiler, GNAT
aborts with the message <code class="samp docutils literal notranslate"><span class="pre">xxx</span> <span class="pre">not</span> <span class="pre">implemented</span></code>, where
<code class="docutils literal notranslate"><span class="pre">xxx</span></code> is the name of the current compilation unit.  This pragma is
intended to allow the compiler to handle unimplemented library units in
a clean manner.</p>
<p>The abort only happens if code is being generated.  Thus you can use
specs of unimplemented packages in syntax or semantic checking mode.</p>
</div>
<div class="section" id="pragma-universal-aliasing">
<span id="id48"></span><h2><span class="section-number">2.186. </span>Pragma Universal_Aliasing<a class="headerlink" href="#pragma-universal-aliasing" title="Permalink to this headline">¶</a></h2>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pragma</span> <span class="n">Universal_Aliasing</span> <span class="p">[([</span><span class="n">Entity</span> <span class="o">=&gt;</span><span class="p">]</span> <span class="n">type_LOCAL_NAME</span><span class="p">)];</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">type_LOCAL_NAME</span></code> must refer to a type declaration in the current
declarative part.  The effect is to inhibit strict type-based aliasing
optimization for the given type.  In other words, the effect is as though
access types designating this type were subject to pragma No_Strict_Aliasing.
For a detailed description of the strict aliasing optimization, and the
situations in which it must be suppressed, see the section on
<code class="docutils literal notranslate"><span class="pre">Optimization</span> <span class="pre">and</span> <span class="pre">Strict</span> <span class="pre">Aliasing</span></code> in the <cite>GNAT User’s Guide</cite>.</p>
</div>
<div class="section" id="pragma-unmodified">
<span id="id49"></span><h2><span class="section-number">2.187. </span>Pragma Unmodified<a class="headerlink" href="#pragma-unmodified" title="Permalink to this headline">¶</a></h2>
<p id="index-80">Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pragma</span> <span class="n">Unmodified</span> <span class="p">(</span><span class="n">LOCAL_NAME</span> <span class="p">{,</span> <span class="n">LOCAL_NAME</span><span class="p">});</span>
</pre></div>
</div>
<p>This pragma signals that the assignable entities (variables,
<code class="docutils literal notranslate"><span class="pre">out</span></code> parameters, <code class="docutils literal notranslate"><span class="pre">in</span> <span class="pre">out</span></code> parameters) whose names are listed are
deliberately not assigned in the current source unit. This
suppresses warnings about the
entities being referenced but not assigned, and in addition a warning will be
generated if one of these entities is in fact assigned in the
same unit as the pragma (or in the corresponding body, or one
of its subunits).</p>
<p>This is particularly useful for clearly signaling that a particular
parameter is not modified, even though the spec suggests that it might
be.</p>
<p>For the variable case, warnings are never given for unreferenced variables
whose name contains one of the substrings
<code class="docutils literal notranslate"><span class="pre">DISCARD,</span> <span class="pre">DUMMY,</span> <span class="pre">IGNORE,</span> <span class="pre">JUNK,</span> <span class="pre">UNUSED</span></code> in any casing. Such names
are typically to be used in cases where such warnings are expected.
Thus it is never necessary to use <code class="docutils literal notranslate"><span class="pre">pragma</span> <span class="pre">Unmodified</span></code> for such
variables, though it is harmless to do so.</p>
</div>
<div class="section" id="pragma-unreferenced">
<span id="id50"></span><h2><span class="section-number">2.188. </span>Pragma Unreferenced<a class="headerlink" href="#pragma-unreferenced" title="Permalink to this headline">¶</a></h2>
<p id="index-81">Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pragma</span> <span class="n">Unreferenced</span> <span class="p">(</span><span class="n">LOCAL_NAME</span> <span class="p">{,</span> <span class="n">LOCAL_NAME</span><span class="p">});</span>
<span class="n">pragma</span> <span class="n">Unreferenced</span> <span class="p">(</span><span class="n">library_unit_NAME</span> <span class="p">{,</span> <span class="n">library_unit_NAME</span><span class="p">});</span>
</pre></div>
</div>
<p>This pragma signals that the entities whose names are listed are
deliberately not referenced in the current source unit after the
occurrence of the pragma. This
suppresses warnings about the
entities being unreferenced, and in addition a warning will be
generated if one of these entities is in fact subsequently referenced in the
same unit as the pragma (or in the corresponding body, or one
of its subunits).</p>
<p>This is particularly useful for clearly signaling that a particular
parameter is not referenced in some particular subprogram implementation
and that this is deliberate. It can also be useful in the case of
objects declared only for their initialization or finalization side
effects.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">LOCAL_NAME</span></code> identifies more than one matching homonym in the
current scope, then the entity most recently declared is the one to which
the pragma applies. Note that in the case of accept formals, the pragma
Unreferenced may appear immediately after the keyword <code class="docutils literal notranslate"><span class="pre">do</span></code> which
allows the indication of whether or not accept formals are referenced
or not to be given individually for each accept statement.</p>
<p>The left hand side of an assignment does not count as a reference for the
purpose of this pragma. Thus it is fine to assign to an entity for which
pragma Unreferenced is given.</p>
<p>Note that if a warning is desired for all calls to a given subprogram,
regardless of whether they occur in the same unit as the subprogram
declaration, then this pragma should not be used (calls from another
unit would not be flagged); pragma Obsolescent can be used instead
for this purpose, see <a class="reference internal" href="#pragma-obsolescent"><span class="std std-ref">Pragma Obsolescent</span></a>.</p>
<p>The second form of pragma <code class="docutils literal notranslate"><span class="pre">Unreferenced</span></code> is used within a context
clause. In this case the arguments must be unit names of units previously
mentioned in <code class="docutils literal notranslate"><span class="pre">with</span></code> clauses (similar to the usage of pragma
<code class="docutils literal notranslate"><span class="pre">Elaborate_All</span></code>. The effect is to suppress warnings about unreferenced
units and unreferenced entities within these units.</p>
<p>For the variable case, warnings are never given for unreferenced variables
whose name contains one of the substrings
<code class="docutils literal notranslate"><span class="pre">DISCARD,</span> <span class="pre">DUMMY,</span> <span class="pre">IGNORE,</span> <span class="pre">JUNK,</span> <span class="pre">UNUSED</span></code> in any casing. Such names
are typically to be used in cases where such warnings are expected.
Thus it is never necessary to use <code class="docutils literal notranslate"><span class="pre">pragma</span> <span class="pre">Unreferenced</span></code> for such
variables, though it is harmless to do so.</p>
</div>
<div class="section" id="pragma-unreferenced-objects">
<span id="id51"></span><h2><span class="section-number">2.189. </span>Pragma Unreferenced_Objects<a class="headerlink" href="#pragma-unreferenced-objects" title="Permalink to this headline">¶</a></h2>
<p id="index-82">Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pragma</span> <span class="n">Unreferenced_Objects</span> <span class="p">(</span><span class="n">local_subtype_NAME</span> <span class="p">{,</span> <span class="n">local_subtype_NAME</span><span class="p">});</span>
</pre></div>
</div>
<p>This pragma signals that for the types or subtypes whose names are
listed, objects which are declared with one of these types or subtypes may
not be referenced, and if no references appear, no warnings are given.</p>
<p>This is particularly useful for objects which are declared solely for their
initialization and finalization effect. Such variables are sometimes referred
to as RAII variables (Resource Acquisition Is Initialization). Using this
pragma on the relevant type (most typically a limited controlled type), the
compiler will automatically suppress unwanted warnings about these variables
not being referenced.</p>
</div>
<div class="section" id="pragma-unreserve-all-interrupts">
<h2><span class="section-number">2.190. </span>Pragma Unreserve_All_Interrupts<a class="headerlink" href="#pragma-unreserve-all-interrupts" title="Permalink to this headline">¶</a></h2>
<p>Syntax:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma</span><span class="p"> </span><span class="n">Unreserve_All_Interrupts</span><span class="p">;</span>
</pre></div>
</div>
<p>Normally certain interrupts are reserved to the implementation.  Any attempt
to attach an interrupt causes Program_Error to be raised, as described in
RM C.3.2(22).  A typical example is the <code class="docutils literal notranslate"><span class="pre">SIGINT</span></code> interrupt used in
many systems for a <kbd class="kbd docutils literal notranslate"><kbd class="kbd docutils literal notranslate">Ctrl</kbd>-<kbd class="kbd docutils literal notranslate">C</kbd></kbd> interrupt.  Normally this interrupt is
reserved to the implementation, so that <kbd class="kbd docutils literal notranslate"><kbd class="kbd docutils literal notranslate">Ctrl</kbd>-<kbd class="kbd docutils literal notranslate">C</kbd></kbd> can be used to
interrupt execution.</p>
<p>If the pragma <code class="docutils literal notranslate"><span class="pre">Unreserve_All_Interrupts</span></code> appears anywhere in any unit in
a program, then all such interrupts are unreserved.  This allows the
program to handle these interrupts, but disables their standard
functions.  For example, if this pragma is used, then pressing
<kbd class="kbd docutils literal notranslate"><kbd class="kbd docutils literal notranslate">Ctrl</kbd>-<kbd class="kbd docutils literal notranslate">C</kbd></kbd> will not automatically interrupt execution.  However,
a program can then handle the <code class="docutils literal notranslate"><span class="pre">SIGINT</span></code> interrupt as it chooses.</p>
<p>For a full list of the interrupts handled in a specific implementation,
see the source code for the spec of <code class="docutils literal notranslate"><span class="pre">Ada.Interrupts.Names</span></code> in
file <code class="file docutils literal notranslate"><span class="pre">a-intnam.ads</span></code>.  This is a target dependent file that contains the
list of interrupts recognized for a given target.  The documentation in
this file also specifies what interrupts are affected by the use of
the <code class="docutils literal notranslate"><span class="pre">Unreserve_All_Interrupts</span></code> pragma.</p>
<p>For a more general facility for controlling what interrupts can be
handled, see pragma <code class="docutils literal notranslate"><span class="pre">Interrupt_State</span></code>, which subsumes the functionality
of the <code class="docutils literal notranslate"><span class="pre">Unreserve_All_Interrupts</span></code> pragma.</p>
</div>
<div class="section" id="pragma-unsuppress">
<h2><span class="section-number">2.191. </span>Pragma Unsuppress<a class="headerlink" href="#pragma-unsuppress" title="Permalink to this headline">¶</a></h2>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pragma</span> <span class="n">Unsuppress</span> <span class="p">(</span><span class="n">IDENTIFIER</span> <span class="p">[,</span> <span class="p">[</span><span class="n">On</span> <span class="o">=&gt;</span><span class="p">]</span> <span class="n">NAME</span><span class="p">]);</span>
</pre></div>
</div>
<p>This pragma undoes the effect of a previous pragma <code class="docutils literal notranslate"><span class="pre">Suppress</span></code>.  If
there is no corresponding pragma <code class="docutils literal notranslate"><span class="pre">Suppress</span></code> in effect, it has no
effect.  The range of the effect is the same as for pragma
<code class="docutils literal notranslate"><span class="pre">Suppress</span></code>.  The meaning of the arguments is identical to that used
in pragma <code class="docutils literal notranslate"><span class="pre">Suppress</span></code>.</p>
<p>One important application is to ensure that checks are on in cases where
code depends on the checks for its correct functioning, so that the code
will compile correctly even if the compiler switches are set to suppress
checks. For example, in a program that depends on external names of tagged
types and wants to ensure that the duplicated tag check occurs even if all
run-time checks are suppressed by a compiler switch, the following
configuration pragma will ensure this test is not suppressed:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma</span><span class="p"> </span><span class="n">Unsuppress</span> <span class="o">(</span><span class="n">Duplicated_Tag_Check</span><span class="o">)</span><span class="p">;</span>
</pre></div>
</div>
<p>This pragma is standard in Ada 2005. It is available in all earlier versions
of Ada as an implementation-defined pragma.</p>
<p>Note that in addition to the checks defined in the Ada RM, GNAT recogizes a
number of implementation-defined check names. See the description of pragma
<code class="docutils literal notranslate"><span class="pre">Suppress</span></code> for full details.</p>
</div>
<div class="section" id="pragma-use-vads-size">
<h2><span class="section-number">2.192. </span>Pragma Use_VADS_Size<a class="headerlink" href="#pragma-use-vads-size" title="Permalink to this headline">¶</a></h2>
<span class="target" id="index-83"></span><p id="index-84">Syntax:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma</span><span class="p"> </span><span class="n">Use_VADS_Size</span><span class="p">;</span>
</pre></div>
</div>
<p>This is a configuration pragma.  In a unit to which it applies, any use
of the ‘Size attribute is automatically interpreted as a use of the
‘VADS_Size attribute.  Note that this may result in incorrect semantic
processing of valid Ada 95 or Ada 2005 programs.  This is intended to aid in
the handling of existing code which depends on the interpretation of Size
as implemented in the VADS compiler.  See description of the VADS_Size
attribute for further details.</p>
</div>
<div class="section" id="pragma-unused">
<span id="id52"></span><h2><span class="section-number">2.193. </span>Pragma Unused<a class="headerlink" href="#pragma-unused" title="Permalink to this headline">¶</a></h2>
<p id="index-85">Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pragma</span> <span class="n">Unused</span> <span class="p">(</span><span class="n">LOCAL_NAME</span> <span class="p">{,</span> <span class="n">LOCAL_NAME</span><span class="p">});</span>
</pre></div>
</div>
<p>This pragma signals that the assignable entities (variables,
<code class="docutils literal notranslate"><span class="pre">out</span></code> parameters, and <code class="docutils literal notranslate"><span class="pre">in</span> <span class="pre">out</span></code> parameters) whose names are listed
deliberately do not get assigned or referenced in the current source unit
after the occurrence of the pragma in the current source unit. This
suppresses warnings about the entities that are unreferenced and/or not
assigned, and, in addition, a warning will be generated if one of these
entities gets assigned or subsequently referenced in the same unit as the
pragma (in the corresponding body or one of its subunits).</p>
<p>This is particularly useful for clearly signaling that a particular
parameter is not modified or referenced, even though the spec suggests
that it might be.</p>
<p>For the variable case, warnings are never given for unreferenced
variables whose name contains one of the substrings
<code class="docutils literal notranslate"><span class="pre">DISCARD,</span> <span class="pre">DUMMY,</span> <span class="pre">IGNORE,</span> <span class="pre">JUNK,</span> <span class="pre">UNUSED</span></code> in any casing. Such names
are typically to be used in cases where such warnings are expected.
Thus it is never necessary to use <code class="docutils literal notranslate"><span class="pre">pragma</span> <span class="pre">Unmodified</span></code> for such
variables, though it is harmless to do so.</p>
</div>
<div class="section" id="pragma-validity-checks">
<h2><span class="section-number">2.194. </span>Pragma Validity_Checks<a class="headerlink" href="#pragma-validity-checks" title="Permalink to this headline">¶</a></h2>
<p>Syntax:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma</span><span class="p"> </span><span class="n">Validity_Checks</span> <span class="o">(</span><span class="n">string_LITERAL</span> <span class="o">|</span> <span class="n">ALL_CHECKS</span> <span class="o">|</span> <span class="n">On</span> <span class="o">|</span> <span class="n">Off</span><span class="o">)</span><span class="p">;</span>
</pre></div>
</div>
<p>This pragma is used in conjunction with compiler switches to control the
built-in validity checking provided by GNAT.  The compiler switches, if set
provide an initial setting for the switches, and this pragma may be used
to modify these settings, or the settings may be provided entirely by
the use of the pragma.  This pragma can be used anywhere that a pragma
is legal, including use as a configuration pragma (including use in
the <code class="file docutils literal notranslate"><span class="pre">gnat.adc</span></code> file).</p>
<p>The form with a string literal specifies which validity options are to be
activated.  The validity checks are first set to include only the default
reference manual settings, and then a string of letters in the string
specifies the exact set of options required.  The form of this string
is exactly as described for the <em>-gnatVx</em> compiler switch (see the
GNAT User’s Guide for details).  For example the following two
methods can be used to enable validity checking for mode <code class="docutils literal notranslate"><span class="pre">in</span></code> and
<code class="docutils literal notranslate"><span class="pre">in</span> <span class="pre">out</span></code> subprogram parameters:</p>
<ul>
<li><div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma</span><span class="p"> </span><span class="n">Validity_Checks</span> <span class="o">(</span><span class="s">&quot;im&quot;</span><span class="o">)</span><span class="p">;</span>
</pre></div>
</div>
</li>
<li><div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>$ gcc -c -gnatVim ...
</pre></div>
</div>
</li>
</ul>
<p>The form ALL_CHECKS activates all standard checks (its use is equivalent
to the use of the <code class="switch docutils literal notranslate"><span class="pre">gnatVa</span></code> switch).</p>
<p>The forms with <code class="docutils literal notranslate"><span class="pre">Off</span></code> and <code class="docutils literal notranslate"><span class="pre">On</span></code> can be used to temporarily disable
validity checks as shown in the following example:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma</span><span class="p"> </span><span class="n">Validity_Checks</span> <span class="o">(</span><span class="s">&quot;c&quot;</span><span class="o">)</span><span class="p">;</span> <span class="c">-- validity checks for copies</span>
<span class="kr">pragma</span><span class="p"> </span><span class="n">Validity_Checks</span> <span class="o">(</span><span class="n">Off</span><span class="o">)</span><span class="p">;</span> <span class="c">-- turn off validity checks</span>
<span class="n">A</span> <span class="o">:=</span> <span class="n">B</span><span class="p">;</span>                       <span class="c">-- B will not be validity checked</span>
<span class="kr">pragma</span><span class="p"> </span><span class="n">Validity_Checks</span> <span class="o">(</span><span class="n">On</span><span class="o">)</span><span class="p">;</span>  <span class="c">-- turn validity checks back on</span>
<span class="n">A</span> <span class="o">:=</span> <span class="n">C</span><span class="p">;</span>                       <span class="c">-- C will be validity checked</span>
</pre></div>
</div>
</div>
<div class="section" id="pragma-volatile">
<span id="id53"></span><h2><span class="section-number">2.195. </span>Pragma Volatile<a class="headerlink" href="#pragma-volatile" title="Permalink to this headline">¶</a></h2>
<p>Syntax:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma</span><span class="p"> </span><span class="n">Volatile</span> <span class="o">(</span><span class="n">LOCAL_NAME</span><span class="o">)</span><span class="p">;</span>
</pre></div>
</div>
<p>This pragma is defined by the Ada Reference Manual, and the GNAT
implementation is fully conformant with this definition.  The reason it
is mentioned in this section is that a pragma of the same name was supplied
in some Ada 83 compilers, including DEC Ada 83.  The Ada 95 / Ada 2005
implementation of pragma Volatile is upwards compatible with the
implementation in DEC Ada 83.</p>
</div>
<div class="section" id="pragma-volatile-full-access">
<span id="id54"></span><h2><span class="section-number">2.196. </span>Pragma Volatile_Full_Access<a class="headerlink" href="#pragma-volatile-full-access" title="Permalink to this headline">¶</a></h2>
<p>Syntax:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma</span><span class="p"> </span><span class="n">Volatile_Full_Access</span> <span class="o">(</span><span class="n">LOCAL_NAME</span><span class="o">)</span><span class="p">;</span>
</pre></div>
</div>
<p>This is similar in effect to pragma Volatile, except that any reference to the
object is guaranteed to be done only with instructions that read or write all
the bits of the object. Furthermore, if the object is of a composite type,
then any reference to a subcomponent of the object is guaranteed to read
and/or write all the bits of the object.</p>
<p>The intention is that this be suitable for use with memory-mapped I/O devices
on some machines. Note that there are two important respects in which this is
different from <code class="docutils literal notranslate"><span class="pre">pragma</span> <span class="pre">Atomic</span></code>. First a reference to a <code class="docutils literal notranslate"><span class="pre">Volatile_Full_Access</span></code>
object is not a sequential action in the RM 9.10 sense and, therefore, does
not create a synchronization point. Second, in the case of <code class="docutils literal notranslate"><span class="pre">pragma</span> <span class="pre">Atomic</span></code>,
there is no guarantee that all the bits will be accessed if the reference
is not to the whole object; the compiler is allowed (and generally will)
access only part of the object in this case.</p>
</div>
<div class="section" id="pragma-volatile-function">
<span id="id55"></span><h2><span class="section-number">2.197. </span>Pragma Volatile_Function<a class="headerlink" href="#pragma-volatile-function" title="Permalink to this headline">¶</a></h2>
<p>Syntax:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma</span><span class="p"> </span><span class="n">Volatile_Function</span> [ <span class="o">(</span><span class="n">boolean_EXPRESSION</span><span class="o">)</span> ]<span class="p">;</span>
</pre></div>
</div>
<p>For the semantics of this pragma, see the entry for aspect <code class="docutils literal notranslate"><span class="pre">Volatile_Function</span></code>
in the SPARK 2014 Reference Manual, section 7.1.2.</p>
</div>
<div class="section" id="pragma-warning-as-error">
<h2><span class="section-number">2.198. </span>Pragma Warning_As_Error<a class="headerlink" href="#pragma-warning-as-error" title="Permalink to this headline">¶</a></h2>
<p>Syntax:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma</span><span class="p"> </span><span class="n">Warning_As_Error</span> <span class="o">(</span><span class="n">static_string_EXPRESSION</span><span class="o">)</span><span class="p">;</span>
</pre></div>
</div>
<p>This configuration pragma allows the programmer to specify a set
of warnings that will be treated as errors. Any warning that
matches the pattern given by the pragma argument will be treated
as an error. This gives more precise control than -gnatwe,
which treats warnings as errors.</p>
<p>This pragma can apply to regular warnings (messages enabled by -gnatw)
and to style warnings (messages that start with “(style)”,
enabled by -gnaty).</p>
<p>The pattern may contain asterisks, which match zero or more characters
in the message. For example, you can use <code class="docutils literal notranslate"><span class="pre">pragma</span> <span class="pre">Warning_As_Error</span>
<span class="pre">(&quot;bits</span> <span class="pre">of*unused&quot;)</span></code> to treat the warning message <code class="docutils literal notranslate"><span class="pre">warning:</span> <span class="pre">960</span> <span class="pre">bits</span> <span class="pre">of</span>
<span class="pre">&quot;a&quot;</span> <span class="pre">unused</span></code> as an error. All characters other than asterisk are treated
as literal characters in the match. The match is case insensitive; for
example XYZ matches xyz.</p>
<p>Note that the pattern matches if it occurs anywhere within the warning
message string (it is not necessary to put an asterisk at the start and
the end of the message, since this is implied).</p>
<p>Another possibility for the static_string_EXPRESSION which works whether
or not error tags are enabled (<em>-gnatw.d</em>) is to use a single
<em>-gnatw</em> tag string, enclosed in brackets,
as shown in the example below, to treat one category of warnings as errors.
Note that if you want to treat multiple categories of warnings as errors,
you can use multiple pragma Warning_As_Error.</p>
<p>The above use of patterns to match the message applies only to warning
messages generated by the front end. This pragma can also be applied to
warnings provided by the back end and mentioned in <a class="reference internal" href="#pragma-warnings"><span class="std std-ref">Pragma Warnings</span></a>.
By using a single full <em>-Wxxx</em> switch in the pragma, such warnings
can also be treated as errors.</p>
<p>The pragma can appear either in a global configuration pragma file
(e.g. <code class="file docutils literal notranslate"><span class="pre">gnat.adc</span></code>), or at the start of a file. Given a global
configuration pragma file containing:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma</span><span class="p"> </span><span class="n">Warning_As_Error</span> <span class="o">(</span><span class="s">&quot;[-gnatwj]&quot;</span><span class="o">)</span><span class="p">;</span>
</pre></div>
</div>
<p>which will treat all obsolescent feature warnings as errors, the
following program compiles as shown (compile options here are
<em>-gnatwa.d -gnatl -gnatj55</em>).</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>    <span class="mf">1.</span> <span class="n">pragma</span> <span class="n">Warning_As_Error</span> <span class="p">(</span><span class="s2">&quot;*never assigned*&quot;</span><span class="p">);</span>
    <span class="mf">2.</span> <span class="n">function</span> <span class="n">Warnerr</span> <span class="k">return</span> <span class="n">String</span> <span class="ow">is</span>
    <span class="mf">3.</span>    <span class="n">X</span> <span class="p">:</span> <span class="n">Integer</span><span class="p">;</span>
          <span class="o">|</span>
       <span class="o">&gt;&gt;&gt;</span> <span class="n">error</span><span class="p">:</span> <span class="n">variable</span> <span class="s2">&quot;X&quot;</span> <span class="ow">is</span> <span class="n">never</span> <span class="n">read</span> <span class="ow">and</span>
           <span class="n">never</span> <span class="n">assigned</span> <span class="p">[</span><span class="o">-</span><span class="n">gnatwv</span><span class="p">]</span> <span class="p">[</span><span class="n">warning</span><span class="o">-</span><span class="k">as</span><span class="o">-</span><span class="n">error</span><span class="p">]</span>

    <span class="mf">4.</span>    <span class="n">Y</span> <span class="p">:</span> <span class="n">Integer</span><span class="p">;</span>
          <span class="o">|</span>
       <span class="o">&gt;&gt;&gt;</span> <span class="n">warning</span><span class="p">:</span> <span class="n">variable</span> <span class="s2">&quot;Y&quot;</span> <span class="ow">is</span> <span class="n">assigned</span> <span class="n">but</span>
           <span class="n">never</span> <span class="n">read</span> <span class="p">[</span><span class="o">-</span><span class="n">gnatwu</span><span class="p">]</span>

    <span class="mf">5.</span> <span class="n">begin</span>
    <span class="mf">6.</span>    <span class="n">Y</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="mf">7.</span>    <span class="k">return</span> <span class="o">%</span><span class="n">ABC</span><span class="o">%</span><span class="p">;</span>
                 <span class="o">|</span>
       <span class="o">&gt;&gt;&gt;</span> <span class="n">error</span><span class="p">:</span> <span class="n">use</span> <span class="n">of</span> <span class="s2">&quot;%&quot;</span> <span class="ow">is</span> <span class="n">an</span> <span class="n">obsolescent</span>
           <span class="n">feature</span> <span class="p">(</span><span class="n">RM</span> <span class="n">J</span><span class="o">.</span><span class="mi">2</span><span class="p">(</span><span class="mi">4</span><span class="p">)),</span> <span class="n">use</span> <span class="s2">&quot;&quot;&quot; instead</span>
<span class="s2">           [-gnatwj] [warning-as-error]</span>

<span class="s2">    8. end;</span>

<span class="s2">8 lines: No errors, 3 warnings (2 treated as errors)</span>
</pre></div>
</div>
<p>Note that this pragma does not affect the set of warnings issued in
any way, it merely changes the effect of a matching warning if one
is produced as a result of other warnings options. As shown in this
example, if the pragma results in a warning being treated as an error,
the tag is changed from “warning:” to “error:” and the string
“[warning-as-error]” is appended to the end of the message.</p>
</div>
<div class="section" id="pragma-warnings">
<span id="id56"></span><h2><span class="section-number">2.199. </span>Pragma Warnings<a class="headerlink" href="#pragma-warnings" title="Permalink to this headline">¶</a></h2>
<p>Syntax:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma</span><span class="p"> </span><span class="n">Warnings</span> <span class="o">(</span>[<span class="n">TOOL_NAME</span><span class="p">,</span>] <span class="n">DETAILS</span> [<span class="p">,</span> <span class="n">REASON</span>]<span class="o">)</span><span class="p">;</span>

<span class="n">DETAILS</span> <span class="o">::=</span> <span class="n">On</span> <span class="o">|</span> <span class="n">Off</span>
<span class="n">DETAILS</span> <span class="o">::=</span> <span class="n">On</span> <span class="o">|</span> <span class="n">Off</span><span class="p">,</span> <span class="n">local_NAME</span>
<span class="n">DETAILS</span> <span class="o">::=</span> <span class="n">static_string_EXPRESSION</span>
<span class="n">DETAILS</span> <span class="o">::=</span> <span class="n">On</span> <span class="o">|</span> <span class="n">Off</span><span class="p">,</span> <span class="n">static_string_EXPRESSION</span>

<span class="n">TOOL_NAME</span> <span class="o">::=</span> <span class="n">GNAT</span> <span class="o">|</span> <span class="n">GNATprove</span>

<span class="n">REASON</span> <span class="o">::=</span> <span class="n">Reason</span> <span class="o">=&gt;</span> <span class="n">STRING_LITERAL</span> {<span class="o">&amp;</span> <span class="n">STRING_LITERAL</span>}
</pre></div>
</div>
<p>Note: in Ada 83 mode, a string literal may be used in place of a static string
expression (which does not exist in Ada 83).</p>
<p>Note if the second argument of <code class="docutils literal notranslate"><span class="pre">DETAILS</span></code> is a <code class="docutils literal notranslate"><span class="pre">local_NAME</span></code> then the
second form is always understood. If the intention is to use
the fourth form, then you can write <code class="docutils literal notranslate"><span class="pre">NAME</span> <span class="pre">&amp;</span> <span class="pre">&quot;&quot;</span></code> to force the
intepretation as a <em>static_string_EXPRESSION</em>.</p>
<p>Note: if the first argument is a valid <code class="docutils literal notranslate"><span class="pre">TOOL_NAME</span></code>, it will be interpreted
that way. The use of the <code class="docutils literal notranslate"><span class="pre">TOOL_NAME</span></code> argument is relevant only to users
of SPARK and GNATprove, see last part of this section for details.</p>
<p>Normally warnings are enabled, with the output being controlled by
the command line switch.  Warnings (<code class="docutils literal notranslate"><span class="pre">Off</span></code>) turns off generation of
warnings until a Warnings (<code class="docutils literal notranslate"><span class="pre">On</span></code>) is encountered or the end of the
current unit.  If generation of warnings is turned off using this
pragma, then some or all of the warning messages are suppressed,
regardless of the setting of the command line switches.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">Reason</span></code> parameter may optionally appear as the last argument
in any of the forms of this pragma. It is intended purely for the
purposes of documenting the reason for the <code class="docutils literal notranslate"><span class="pre">Warnings</span></code> pragma.
The compiler will check that the argument is a static string but
otherwise ignore this argument. Other tools may provide specialized
processing for this string.</p>
<p>The form with a single argument (or two arguments if Reason present),
where the first argument is <code class="docutils literal notranslate"><span class="pre">ON</span></code> or <code class="docutils literal notranslate"><span class="pre">OFF</span></code>
may be used as a configuration pragma.</p>
<p>If the <code class="docutils literal notranslate"><span class="pre">LOCAL_NAME</span></code> parameter is present, warnings are suppressed for
the specified entity.  This suppression is effective from the point where
it occurs till the end of the extended scope of the variable (similar to
the scope of <code class="docutils literal notranslate"><span class="pre">Suppress</span></code>). This form cannot be used as a configuration
pragma.</p>
<p>In the case where the first argument is other than <code class="docutils literal notranslate"><span class="pre">ON</span></code> or
<code class="docutils literal notranslate"><span class="pre">OFF</span></code>,
the third form with a single static_string_EXPRESSION argument (and possible
reason) provides more precise
control over which warnings are active. The string is a list of letters
specifying which warnings are to be activated and which deactivated. The
code for these letters is the same as the string used in the command
line switch controlling warnings. For a brief summary, use the gnatmake
command with no arguments, which will generate usage information containing
the list of warnings switches supported. For
full details see the section on <code class="docutils literal notranslate"><span class="pre">Warning</span> <span class="pre">Message</span> <span class="pre">Control</span></code> in the
<cite>GNAT User’s Guide</cite>.
This form can also be used as a configuration pragma.</p>
<p>The warnings controlled by the <code class="switch docutils literal notranslate"><span class="pre">-gnatw</span></code> switch are generated by the
front end of the compiler. The GCC back end can provide additional warnings
and they are controlled by the <code class="switch docutils literal notranslate"><span class="pre">-W</span></code> switch. Such warnings can be
identified by the appearance of a string of the form <code class="docutils literal notranslate"><span class="pre">[-W{xxx}]</span></code> in the
message which designates the <code class="switch docutils literal notranslate"><span class="pre">-W</span><em><span class="pre">xxx</span></em></code> switch that controls the message.
The form with a single <em>static_string_EXPRESSION</em> argument also works for these
warnings, but the string must be a single full <code class="switch docutils literal notranslate"><span class="pre">-W</span><em><span class="pre">xxx</span></em></code> switch in this
case. The above reference lists a few examples of these additional warnings.</p>
<p>The specified warnings will be in effect until the end of the program
or another pragma <code class="docutils literal notranslate"><span class="pre">Warnings</span></code> is encountered. The effect of the pragma is
cumulative. Initially the set of warnings is the standard default set
as possibly modified by compiler switches. Then each pragma Warning
modifies this set of warnings as specified. This form of the pragma may
also be used as a configuration pragma.</p>
<p>The fourth form, with an <code class="docutils literal notranslate"><span class="pre">On|Off</span></code> parameter and a string, is used to
control individual messages, based on their text. The string argument
is a pattern that is used to match against the text of individual
warning messages (not including the initial “warning: ” tag).</p>
<p>The pattern may contain asterisks, which match zero or more characters in
the message. For example, you can use
<code class="docutils literal notranslate"><span class="pre">pragma</span> <span class="pre">Warnings</span> <span class="pre">(Off,</span> <span class="pre">&quot;bits</span> <span class="pre">of*unused&quot;)</span></code> to suppress the warning
message <code class="docutils literal notranslate"><span class="pre">warning:</span> <span class="pre">960</span> <span class="pre">bits</span> <span class="pre">of</span> <span class="pre">&quot;a&quot;</span> <span class="pre">unused</span></code>. No other regular
expression notations are permitted. All characters other than asterisk in
these three specific cases are treated as literal characters in the match.
The match is case insensitive, for example XYZ matches xyz.</p>
<p>Note that the pattern matches if it occurs anywhere within the warning
message string (it is not necessary to put an asterisk at the start and
the end of the message, since this is implied).</p>
<p>The above use of patterns to match the message applies only to warning
messages generated by the front end. This form of the pragma with a string
argument can also be used to control warnings provided by the back end and
mentioned above. By using a single full <code class="switch docutils literal notranslate"><span class="pre">-W</span><em><span class="pre">xxx</span></em></code> switch in the pragma,
such warnings can be turned on and off.</p>
<p>There are two ways to use the pragma in this form. The OFF form can be used
as a configuration pragma. The effect is to suppress all warnings (if any)
that match the pattern string throughout the compilation (or match the
-W switch in the back end case).</p>
<p>The second usage is to suppress a warning locally, and in this case, two
pragmas must appear in sequence:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma</span><span class="p"> </span><span class="n">Warnings</span> <span class="o">(</span><span class="n">Off</span><span class="p">,</span> <span class="n">Pattern</span><span class="o">)</span><span class="p">;</span>
<span class="o">...</span> <span class="n">code</span> <span class="n">where</span> <span class="n">given</span> <span class="n">warning</span> <span class="kr">is</span><span class="p"> </span><span class="n">to</span> <span class="n">be</span> <span class="n">suppressed</span>
<span class="kr">pragma</span><span class="p"> </span><span class="n">Warnings</span> <span class="o">(</span><span class="n">On</span><span class="p">,</span> <span class="n">Pattern</span><span class="o">)</span><span class="p">;</span>
</pre></div>
</div>
<p>In this usage, the pattern string must match in the Off and On
pragmas, and (if <em>-gnatw.w</em> is given) at least one matching
warning must be suppressed.</p>
<p>Note: if the ON form is not found, then the effect of the OFF form extends
until the end of the file (pragma Warnings is purely textual, so its effect
does not stop at the end of the enclosing scope).</p>
<p>Note: to write a string that will match any warning, use the string
<code class="docutils literal notranslate"><span class="pre">&quot;***&quot;</span></code>. It will not work to use a single asterisk or two
asterisks since this looks like an operator name. This form with three
asterisks is similar in effect to specifying <code class="docutils literal notranslate"><span class="pre">pragma</span> <span class="pre">Warnings</span> <span class="pre">(Off)</span></code> except (if <code class="switch docutils literal notranslate"><span class="pre">-gnatw.w</span></code> is given) that a matching
<code class="docutils literal notranslate"><span class="pre">pragma</span> <span class="pre">Warnings</span> <span class="pre">(On,</span> <span class="pre">&quot;***&quot;)</span></code> will be required. This can be
helpful in avoiding forgetting to turn warnings back on.</p>
<p>Note: the debug flag <code class="switch docutils literal notranslate"><span class="pre">-gnatd.i</span></code> can be
used to cause the compiler to entirely ignore all WARNINGS pragmas. This can
be useful in checking whether obsolete pragmas in existing programs are hiding
real problems.</p>
<p>Note: pragma Warnings does not affect the processing of style messages. See
separate entry for pragma Style_Checks for control of style messages.</p>
<p>Users of the formal verification tool GNATprove for the SPARK subset of Ada may
use the version of the pragma with a <code class="docutils literal notranslate"><span class="pre">TOOL_NAME</span></code> parameter.</p>
<p>If present, <code class="docutils literal notranslate"><span class="pre">TOOL_NAME</span></code> is the name of a tool, currently either <code class="docutils literal notranslate"><span class="pre">GNAT</span></code> for the
compiler or <code class="docutils literal notranslate"><span class="pre">GNATprove</span></code> for the formal verification tool. A given tool only
takes into account pragma Warnings that do not specify a tool name, or that
specify the matching tool name. This makes it possible to disable warnings
selectively for each tool, and as a consequence to detect useless pragma
Warnings with switch <code class="switch docutils literal notranslate"><span class="pre">-gnatw.w</span></code>.</p>
</div>
<div class="section" id="pragma-weak-external">
<h2><span class="section-number">2.200. </span>Pragma Weak_External<a class="headerlink" href="#pragma-weak-external" title="Permalink to this headline">¶</a></h2>
<p>Syntax:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma</span><span class="p"> </span><span class="n">Weak_External</span> <span class="o">(</span>[<span class="n">Entity</span> <span class="o">=&gt;</span>] <span class="n">LOCAL_NAME</span><span class="o">)</span><span class="p">;</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">LOCAL_NAME</span></code> must refer to an object that is declared at the library
level. This pragma specifies that the given entity should be marked as a
weak symbol for the linker. It is equivalent to <code class="docutils literal notranslate"><span class="pre">__attribute__((weak))</span></code>
in GNU C and causes <code class="docutils literal notranslate"><span class="pre">LOCAL_NAME</span></code> to be emitted as a weak symbol instead
of a regular symbol, that is to say a symbol that does not have to be
resolved by the linker if used in conjunction with a pragma Import.</p>
<p>When a weak symbol is not resolved by the linker, its address is set to
zero. This is useful in writing interfaces to external modules that may
or may not be linked in the final executable, for example depending on
configuration settings.</p>
<p>If a program references at run time an entity to which this pragma has been
applied, and the corresponding symbol was not resolved at link time, then
the execution of the program is erroneous. It is not erroneous to take the
Address of such an entity, for example to guard potential references,
as shown in the example below.</p>
<p>Some file formats do not support weak symbols so not all target machines
support this pragma.</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="c">--  Example of the use of pragma Weak_External</span>

<span class="k">package </span><span class="nf">External_Module</span> <span class="kr">is</span><span class="p"></span>
  <span class="n">key</span> <span class="o">:</span> <span class="n">Integer</span><span class="p">;</span>
  <span class="kr">pragma</span><span class="p"> </span><span class="n">Import</span> <span class="o">(</span><span class="n">C</span><span class="p">,</span> <span class="n">key</span><span class="o">)</span><span class="p">;</span>
  <span class="kr">pragma</span><span class="p"> </span><span class="n">Weak_External</span> <span class="o">(</span><span class="n">key</span><span class="o">)</span><span class="p">;</span>
  <span class="k">function </span><span class="nf">Present</span> <span class="kr">return</span><span class="p"> </span><span class="n">boolean</span><span class="p">;</span>
<span class="k">end </span><span class="nf">External_Module</span><span class="p">;</span>

<span class="kr">with</span><span class="nn"> System;</span> <span class="kr">use</span><span class="p"> </span><span class="n">System</span><span class="p">;</span>
<span class="k">package body </span><span class="nf">External_Module</span> <span class="kr">is</span><span class="p"></span>
  <span class="k">function </span><span class="nf">Present</span> <span class="kr">return</span><span class="p"> </span><span class="n">boolean</span> <span class="kr">is</span><span class="p"></span>
  <span class="kr">begin</span><span class="p"></span>
    <span class="kr">return</span><span class="p"> </span><span class="n">key</span><span class="na">&#39;Address</span> <span class="o">/=</span> <span class="n">System.Null_Address</span><span class="p">;</span>
  <span class="k">end </span><span class="nf">Present</span><span class="p">;</span>
<span class="k">end </span><span class="nf">External_Module</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="pragma-wide-character-encoding">
<h2><span class="section-number">2.201. </span>Pragma Wide_Character_Encoding<a class="headerlink" href="#pragma-wide-character-encoding" title="Permalink to this headline">¶</a></h2>
<p>Syntax:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma</span><span class="p"> </span><span class="n">Wide_Character_Encoding</span> <span class="o">(</span><span class="n">IDENTIFIER</span> <span class="o">|</span> <span class="n">CHARACTER_LITERAL</span><span class="o">)</span><span class="p">;</span>
</pre></div>
</div>
<p>This pragma specifies the wide character encoding to be used in program
source text appearing subsequently. It is a configuration pragma, but may
also be used at any point that a pragma is allowed, and it is permissible
to have more than one such pragma in a file, allowing multiple encodings
to appear within the same file.</p>
<p>However, note that the pragma cannot immediately precede the relevant
wide character, because then the previous encoding will still be in
effect, causing “illegal character” errors.</p>
<p>The argument can be an identifier or a character literal. In the identifier
case, it is one of <code class="docutils literal notranslate"><span class="pre">HEX</span></code>, <code class="docutils literal notranslate"><span class="pre">UPPER</span></code>, <code class="docutils literal notranslate"><span class="pre">SHIFT_JIS</span></code>,
<code class="docutils literal notranslate"><span class="pre">EUC</span></code>, <code class="docutils literal notranslate"><span class="pre">UTF8</span></code>, or <code class="docutils literal notranslate"><span class="pre">BRACKETS</span></code>. In the character literal
case it is correspondingly one of the characters <kbd class="kbd docutils literal notranslate">h</kbd>, <kbd class="kbd docutils literal notranslate">u</kbd>,
<kbd class="kbd docutils literal notranslate">s</kbd>, <kbd class="kbd docutils literal notranslate">e</kbd>, <kbd class="kbd docutils literal notranslate">8</kbd>, or <kbd class="kbd docutils literal notranslate">b</kbd>.</p>
<p>Note that when the pragma is used within a file, it affects only the
encoding within that file, and does not affect withed units, specs,
or subunits.</p>
</div>
</div>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../gnat_rm.html">
              <img class="logo" src="../_static/adacore_transparent.png" alt="Logo"/>
            </a></p>
  <h3><a href="../gnat_rm.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">2. Implementation Defined Pragmas</a><ul>
<li><a class="reference internal" href="#pragma-abort-defer">2.1. Pragma Abort_Defer</a></li>
<li><a class="reference internal" href="#pragma-abstract-state">2.2. Pragma Abstract_State</a></li>
<li><a class="reference internal" href="#pragma-ada-83">2.3. Pragma Ada_83</a></li>
<li><a class="reference internal" href="#pragma-ada-95">2.4. Pragma Ada_95</a></li>
<li><a class="reference internal" href="#pragma-ada-05">2.5. Pragma Ada_05</a></li>
<li><a class="reference internal" href="#pragma-ada-2005">2.6. Pragma Ada_2005</a></li>
<li><a class="reference internal" href="#pragma-ada-12">2.7. Pragma Ada_12</a></li>
<li><a class="reference internal" href="#pragma-ada-2012">2.8. Pragma Ada_2012</a></li>
<li><a class="reference internal" href="#pragma-aggregate-individually-assign">2.9. Pragma Aggregate_Individually_Assign</a></li>
<li><a class="reference internal" href="#pragma-allow-integer-address">2.10. Pragma Allow_Integer_Address</a></li>
<li><a class="reference internal" href="#pragma-annotate">2.11. Pragma Annotate</a></li>
<li><a class="reference internal" href="#pragma-assert">2.12. Pragma Assert</a></li>
<li><a class="reference internal" href="#pragma-assert-and-cut">2.13. Pragma Assert_And_Cut</a></li>
<li><a class="reference internal" href="#pragma-assertion-policy">2.14. Pragma Assertion_Policy</a></li>
<li><a class="reference internal" href="#pragma-assume">2.15. Pragma Assume</a></li>
<li><a class="reference internal" href="#pragma-assume-no-invalid-values">2.16. Pragma Assume_No_Invalid_Values</a></li>
<li><a class="reference internal" href="#pragma-async-readers">2.17. Pragma Async_Readers</a></li>
<li><a class="reference internal" href="#pragma-async-writers">2.18. Pragma Async_Writers</a></li>
<li><a class="reference internal" href="#pragma-attribute-definition">2.19. Pragma Attribute_Definition</a></li>
<li><a class="reference internal" href="#pragma-c-pass-by-copy">2.20. Pragma C_Pass_By_Copy</a></li>
<li><a class="reference internal" href="#pragma-check">2.21. Pragma Check</a></li>
<li><a class="reference internal" href="#pragma-check-float-overflow">2.22. Pragma Check_Float_Overflow</a></li>
<li><a class="reference internal" href="#pragma-check-name">2.23. Pragma Check_Name</a></li>
<li><a class="reference internal" href="#pragma-check-policy">2.24. Pragma Check_Policy</a></li>
<li><a class="reference internal" href="#pragma-comment">2.25. Pragma Comment</a></li>
<li><a class="reference internal" href="#pragma-common-object">2.26. Pragma Common_Object</a></li>
<li><a class="reference internal" href="#pragma-compile-time-error">2.27. Pragma Compile_Time_Error</a></li>
<li><a class="reference internal" href="#pragma-compile-time-warning">2.28. Pragma Compile_Time_Warning</a></li>
<li><a class="reference internal" href="#pragma-compiler-unit">2.29. Pragma Compiler_Unit</a></li>
<li><a class="reference internal" href="#pragma-compiler-unit-warning">2.30. Pragma Compiler_Unit_Warning</a></li>
<li><a class="reference internal" href="#pragma-complete-representation">2.31. Pragma Complete_Representation</a></li>
<li><a class="reference internal" href="#pragma-complex-representation">2.32. Pragma Complex_Representation</a></li>
<li><a class="reference internal" href="#pragma-component-alignment">2.33. Pragma Component_Alignment</a></li>
<li><a class="reference internal" href="#pragma-constant-after-elaboration">2.34. Pragma Constant_After_Elaboration</a></li>
<li><a class="reference internal" href="#pragma-contract-cases">2.35. Pragma Contract_Cases</a></li>
<li><a class="reference internal" href="#pragma-convention-identifier">2.36. Pragma Convention_Identifier</a></li>
<li><a class="reference internal" href="#pragma-cpp-class">2.37. Pragma CPP_Class</a></li>
<li><a class="reference internal" href="#pragma-cpp-constructor">2.38. Pragma CPP_Constructor</a></li>
<li><a class="reference internal" href="#pragma-cpp-virtual">2.39. Pragma CPP_Virtual</a></li>
<li><a class="reference internal" href="#pragma-cpp-vtable">2.40. Pragma CPP_Vtable</a></li>
<li><a class="reference internal" href="#pragma-cpu">2.41. Pragma CPU</a></li>
<li><a class="reference internal" href="#pragma-deadline-floor">2.42. Pragma Deadline_Floor</a></li>
<li><a class="reference internal" href="#pragma-default-initial-condition">2.43. Pragma Default_Initial_Condition</a></li>
<li><a class="reference internal" href="#pragma-debug">2.44. Pragma Debug</a></li>
<li><a class="reference internal" href="#pragma-debug-policy">2.45. Pragma Debug_Policy</a></li>
<li><a class="reference internal" href="#pragma-default-scalar-storage-order">2.46. Pragma Default_Scalar_Storage_Order</a></li>
<li><a class="reference internal" href="#pragma-default-storage-pool">2.47. Pragma Default_Storage_Pool</a></li>
<li><a class="reference internal" href="#pragma-depends">2.48. Pragma Depends</a></li>
<li><a class="reference internal" href="#pragma-detect-blocking">2.49. Pragma Detect_Blocking</a></li>
<li><a class="reference internal" href="#pragma-disable-atomic-synchronization">2.50. Pragma Disable_Atomic_Synchronization</a></li>
<li><a class="reference internal" href="#pragma-dispatching-domain">2.51. Pragma Dispatching_Domain</a></li>
<li><a class="reference internal" href="#pragma-effective-reads">2.52. Pragma Effective_Reads</a></li>
<li><a class="reference internal" href="#pragma-effective-writes">2.53. Pragma Effective_Writes</a></li>
<li><a class="reference internal" href="#pragma-elaboration-checks">2.54. Pragma Elaboration_Checks</a></li>
<li><a class="reference internal" href="#pragma-eliminate">2.55. Pragma Eliminate</a></li>
<li><a class="reference internal" href="#pragma-enable-atomic-synchronization">2.56. Pragma Enable_Atomic_Synchronization</a></li>
<li><a class="reference internal" href="#pragma-export-function">2.57. Pragma Export_Function</a></li>
<li><a class="reference internal" href="#pragma-export-object">2.58. Pragma Export_Object</a></li>
<li><a class="reference internal" href="#pragma-export-procedure">2.59. Pragma Export_Procedure</a></li>
<li><a class="reference internal" href="#pragma-export-valued-procedure">2.60. Pragma Export_Valued_Procedure</a></li>
<li><a class="reference internal" href="#pragma-extend-system">2.61. Pragma Extend_System</a></li>
<li><a class="reference internal" href="#pragma-extensions-allowed">2.62. Pragma Extensions_Allowed</a></li>
<li><a class="reference internal" href="#pragma-extensions-visible">2.63. Pragma Extensions_Visible</a></li>
<li><a class="reference internal" href="#pragma-external">2.64. Pragma External</a></li>
<li><a class="reference internal" href="#pragma-external-name-casing">2.65. Pragma External_Name_Casing</a></li>
<li><a class="reference internal" href="#pragma-fast-math">2.66. Pragma Fast_Math</a></li>
<li><a class="reference internal" href="#pragma-favor-top-level">2.67. Pragma Favor_Top_Level</a></li>
<li><a class="reference internal" href="#pragma-finalize-storage-only">2.68. Pragma Finalize_Storage_Only</a></li>
<li><a class="reference internal" href="#pragma-float-representation">2.69. Pragma Float_Representation</a></li>
<li><a class="reference internal" href="#pragma-ghost">2.70. Pragma Ghost</a></li>
<li><a class="reference internal" href="#pragma-global">2.71. Pragma Global</a></li>
<li><a class="reference internal" href="#pragma-ident">2.72. Pragma Ident</a></li>
<li><a class="reference internal" href="#pragma-ignore-pragma">2.73. Pragma Ignore_Pragma</a></li>
<li><a class="reference internal" href="#pragma-implementation-defined">2.74. Pragma Implementation_Defined</a></li>
<li><a class="reference internal" href="#pragma-implemented">2.75. Pragma Implemented</a></li>
<li><a class="reference internal" href="#pragma-implicit-packing">2.76. Pragma Implicit_Packing</a></li>
<li><a class="reference internal" href="#pragma-import-function">2.77. Pragma Import_Function</a></li>
<li><a class="reference internal" href="#pragma-import-object">2.78. Pragma Import_Object</a></li>
<li><a class="reference internal" href="#pragma-import-procedure">2.79. Pragma Import_Procedure</a></li>
<li><a class="reference internal" href="#pragma-import-valued-procedure">2.80. Pragma Import_Valued_Procedure</a></li>
<li><a class="reference internal" href="#pragma-independent">2.81. Pragma Independent</a></li>
<li><a class="reference internal" href="#pragma-independent-components">2.82. Pragma Independent_Components</a></li>
<li><a class="reference internal" href="#pragma-initial-condition">2.83. Pragma Initial_Condition</a></li>
<li><a class="reference internal" href="#pragma-initialize-scalars">2.84. Pragma Initialize_Scalars</a></li>
<li><a class="reference internal" href="#pragma-initializes">2.85. Pragma Initializes</a></li>
<li><a class="reference internal" href="#pragma-inline-always">2.86. Pragma Inline_Always</a></li>
<li><a class="reference internal" href="#pragma-inline-generic">2.87. Pragma Inline_Generic</a></li>
<li><a class="reference internal" href="#pragma-interface">2.88. Pragma Interface</a></li>
<li><a class="reference internal" href="#pragma-interface-name">2.89. Pragma Interface_Name</a></li>
<li><a class="reference internal" href="#pragma-interrupt-handler">2.90. Pragma Interrupt_Handler</a></li>
<li><a class="reference internal" href="#pragma-interrupt-state">2.91. Pragma Interrupt_State</a></li>
<li><a class="reference internal" href="#pragma-invariant">2.92. Pragma Invariant</a></li>
<li><a class="reference internal" href="#pragma-keep-names">2.93. Pragma Keep_Names</a></li>
<li><a class="reference internal" href="#pragma-license">2.94. Pragma License</a></li>
<li><a class="reference internal" href="#pragma-link-with">2.95. Pragma Link_With</a></li>
<li><a class="reference internal" href="#pragma-linker-alias">2.96. Pragma Linker_Alias</a></li>
<li><a class="reference internal" href="#pragma-linker-constructor">2.97. Pragma Linker_Constructor</a></li>
<li><a class="reference internal" href="#pragma-linker-destructor">2.98. Pragma Linker_Destructor</a></li>
<li><a class="reference internal" href="#pragma-linker-section">2.99. Pragma Linker_Section</a></li>
<li><a class="reference internal" href="#pragma-lock-free">2.100. Pragma Lock_Free</a></li>
<li><a class="reference internal" href="#pragma-loop-invariant">2.101. Pragma Loop_Invariant</a></li>
<li><a class="reference internal" href="#pragma-loop-optimize">2.102. Pragma Loop_Optimize</a></li>
<li><a class="reference internal" href="#pragma-loop-variant">2.103. Pragma Loop_Variant</a></li>
<li><a class="reference internal" href="#pragma-machine-attribute">2.104. Pragma Machine_Attribute</a></li>
<li><a class="reference internal" href="#pragma-main">2.105. Pragma Main</a></li>
<li><a class="reference internal" href="#pragma-main-storage">2.106. Pragma Main_Storage</a></li>
<li><a class="reference internal" href="#pragma-max-queue-length">2.107. Pragma Max_Queue_Length</a></li>
<li><a class="reference internal" href="#pragma-no-body">2.108. Pragma No_Body</a></li>
<li><a class="reference internal" href="#pragma-no-caching">2.109. Pragma No_Caching</a></li>
<li><a class="reference internal" href="#pragma-no-component-reordering">2.110. Pragma No_Component_Reordering</a></li>
<li><a class="reference internal" href="#pragma-no-elaboration-code-all">2.111. Pragma No_Elaboration_Code_All</a></li>
<li><a class="reference internal" href="#pragma-no-heap-finalization">2.112. Pragma No_Heap_Finalization</a></li>
<li><a class="reference internal" href="#pragma-no-inline">2.113. Pragma No_Inline</a></li>
<li><a class="reference internal" href="#pragma-no-return">2.114. Pragma No_Return</a></li>
<li><a class="reference internal" href="#pragma-no-strict-aliasing">2.115. Pragma No_Strict_Aliasing</a></li>
<li><a class="reference internal" href="#pragma-no-tagged-streams">2.116. Pragma No_Tagged_Streams</a></li>
<li><a class="reference internal" href="#pragma-normalize-scalars">2.117. Pragma Normalize_Scalars</a></li>
<li><a class="reference internal" href="#pragma-obsolescent">2.118. Pragma Obsolescent</a></li>
<li><a class="reference internal" href="#pragma-optimize-alignment">2.119. Pragma Optimize_Alignment</a></li>
<li><a class="reference internal" href="#pragma-ordered">2.120. Pragma Ordered</a></li>
<li><a class="reference internal" href="#pragma-overflow-mode">2.121. Pragma Overflow_Mode</a></li>
<li><a class="reference internal" href="#pragma-overriding-renamings">2.122. Pragma Overriding_Renamings</a></li>
<li><a class="reference internal" href="#pragma-partition-elaboration-policy">2.123. Pragma Partition_Elaboration_Policy</a></li>
<li><a class="reference internal" href="#pragma-part-of">2.124. Pragma Part_Of</a></li>
<li><a class="reference internal" href="#pragma-passive">2.125. Pragma Passive</a></li>
<li><a class="reference internal" href="#pragma-persistent-bss">2.126. Pragma Persistent_BSS</a></li>
<li><a class="reference internal" href="#pragma-post">2.127. Pragma Post</a></li>
<li><a class="reference internal" href="#pragma-postcondition">2.128. Pragma Postcondition</a></li>
<li><a class="reference internal" href="#pragma-post-class">2.129. Pragma Post_Class</a></li>
<li><a class="reference internal" href="#pragma-rename-pragma">2.130. Pragma Rename_Pragma</a></li>
<li><a class="reference internal" href="#pragma-pre">2.131. Pragma Pre</a></li>
<li><a class="reference internal" href="#pragma-precondition">2.132. Pragma Precondition</a></li>
<li><a class="reference internal" href="#pragma-predicate">2.133. Pragma Predicate</a></li>
<li><a class="reference internal" href="#pragma-predicate-failure">2.134. Pragma Predicate_Failure</a></li>
<li><a class="reference internal" href="#pragma-preelaborable-initialization">2.135. Pragma Preelaborable_Initialization</a></li>
<li><a class="reference internal" href="#pragma-prefix-exception-messages">2.136. Pragma Prefix_Exception_Messages</a></li>
<li><a class="reference internal" href="#pragma-pre-class">2.137. Pragma Pre_Class</a></li>
<li><a class="reference internal" href="#pragma-priority-specific-dispatching">2.138. Pragma Priority_Specific_Dispatching</a></li>
<li><a class="reference internal" href="#pragma-profile">2.139. Pragma Profile</a></li>
<li><a class="reference internal" href="#pragma-profile-warnings">2.140. Pragma Profile_Warnings</a></li>
<li><a class="reference internal" href="#pragma-propagate-exceptions">2.141. Pragma Propagate_Exceptions</a></li>
<li><a class="reference internal" href="#pragma-provide-shift-operators">2.142. Pragma Provide_Shift_Operators</a></li>
<li><a class="reference internal" href="#pragma-psect-object">2.143. Pragma Psect_Object</a></li>
<li><a class="reference internal" href="#pragma-pure-function">2.144. Pragma Pure_Function</a></li>
<li><a class="reference internal" href="#pragma-rational">2.145. Pragma Rational</a></li>
<li><a class="reference internal" href="#pragma-ravenscar">2.146. Pragma Ravenscar</a></li>
<li><a class="reference internal" href="#pragma-refined-depends">2.147. Pragma Refined_Depends</a></li>
<li><a class="reference internal" href="#pragma-refined-global">2.148. Pragma Refined_Global</a></li>
<li><a class="reference internal" href="#pragma-refined-post">2.149. Pragma Refined_Post</a></li>
<li><a class="reference internal" href="#pragma-refined-state">2.150. Pragma Refined_State</a></li>
<li><a class="reference internal" href="#pragma-relative-deadline">2.151. Pragma Relative_Deadline</a></li>
<li><a class="reference internal" href="#pragma-remote-access-type">2.152. Pragma Remote_Access_Type</a></li>
<li><a class="reference internal" href="#pragma-restricted-run-time">2.153. Pragma Restricted_Run_Time</a></li>
<li><a class="reference internal" href="#pragma-restriction-warnings">2.154. Pragma Restriction_Warnings</a></li>
<li><a class="reference internal" href="#pragma-reviewable">2.155. Pragma Reviewable</a></li>
<li><a class="reference internal" href="#pragma-secondary-stack-size">2.156. Pragma Secondary_Stack_Size</a></li>
<li><a class="reference internal" href="#pragma-share-generic">2.157. Pragma Share_Generic</a></li>
<li><a class="reference internal" href="#pragma-shared">2.158. Pragma Shared</a></li>
<li><a class="reference internal" href="#pragma-short-circuit-and-or">2.159. Pragma Short_Circuit_And_Or</a></li>
<li><a class="reference internal" href="#pragma-short-descriptors">2.160. Pragma Short_Descriptors</a></li>
<li><a class="reference internal" href="#pragma-simple-storage-pool-type">2.161. Pragma Simple_Storage_Pool_Type</a></li>
<li><a class="reference internal" href="#pragma-source-file-name">2.162. Pragma Source_File_Name</a></li>
<li><a class="reference internal" href="#pragma-source-file-name-project">2.163. Pragma Source_File_Name_Project</a></li>
<li><a class="reference internal" href="#pragma-source-reference">2.164. Pragma Source_Reference</a></li>
<li><a class="reference internal" href="#pragma-spark-mode">2.165. Pragma SPARK_Mode</a></li>
<li><a class="reference internal" href="#pragma-static-elaboration-desired">2.166. Pragma Static_Elaboration_Desired</a></li>
<li><a class="reference internal" href="#pragma-stream-convert">2.167. Pragma Stream_Convert</a></li>
<li><a class="reference internal" href="#pragma-style-checks">2.168. Pragma Style_Checks</a></li>
<li><a class="reference internal" href="#pragma-subtitle">2.169. Pragma Subtitle</a></li>
<li><a class="reference internal" href="#pragma-suppress">2.170. Pragma Suppress</a></li>
<li><a class="reference internal" href="#pragma-suppress-all">2.171. Pragma Suppress_All</a></li>
<li><a class="reference internal" href="#pragma-suppress-debug-info">2.172. Pragma Suppress_Debug_Info</a></li>
<li><a class="reference internal" href="#pragma-suppress-exception-locations">2.173. Pragma Suppress_Exception_Locations</a></li>
<li><a class="reference internal" href="#pragma-suppress-initialization">2.174. Pragma Suppress_Initialization</a></li>
<li><a class="reference internal" href="#pragma-task-name">2.175. Pragma Task_Name</a></li>
<li><a class="reference internal" href="#pragma-task-storage">2.176. Pragma Task_Storage</a></li>
<li><a class="reference internal" href="#pragma-test-case">2.177. Pragma Test_Case</a></li>
<li><a class="reference internal" href="#pragma-thread-local-storage">2.178. Pragma Thread_Local_Storage</a></li>
<li><a class="reference internal" href="#pragma-time-slice">2.179. Pragma Time_Slice</a></li>
<li><a class="reference internal" href="#pragma-title">2.180. Pragma Title</a></li>
<li><a class="reference internal" href="#pragma-type-invariant">2.181. Pragma Type_Invariant</a></li>
<li><a class="reference internal" href="#pragma-type-invariant-class">2.182. Pragma Type_Invariant_Class</a></li>
<li><a class="reference internal" href="#pragma-unchecked-union">2.183. Pragma Unchecked_Union</a></li>
<li><a class="reference internal" href="#pragma-unevaluated-use-of-old">2.184. Pragma Unevaluated_Use_Of_Old</a></li>
<li><a class="reference internal" href="#pragma-unimplemented-unit">2.185. Pragma Unimplemented_Unit</a></li>
<li><a class="reference internal" href="#pragma-universal-aliasing">2.186. Pragma Universal_Aliasing</a></li>
<li><a class="reference internal" href="#pragma-unmodified">2.187. Pragma Unmodified</a></li>
<li><a class="reference internal" href="#pragma-unreferenced">2.188. Pragma Unreferenced</a></li>
<li><a class="reference internal" href="#pragma-unreferenced-objects">2.189. Pragma Unreferenced_Objects</a></li>
<li><a class="reference internal" href="#pragma-unreserve-all-interrupts">2.190. Pragma Unreserve_All_Interrupts</a></li>
<li><a class="reference internal" href="#pragma-unsuppress">2.191. Pragma Unsuppress</a></li>
<li><a class="reference internal" href="#pragma-use-vads-size">2.192. Pragma Use_VADS_Size</a></li>
<li><a class="reference internal" href="#pragma-unused">2.193. Pragma Unused</a></li>
<li><a class="reference internal" href="#pragma-validity-checks">2.194. Pragma Validity_Checks</a></li>
<li><a class="reference internal" href="#pragma-volatile">2.195. Pragma Volatile</a></li>
<li><a class="reference internal" href="#pragma-volatile-full-access">2.196. Pragma Volatile_Full_Access</a></li>
<li><a class="reference internal" href="#pragma-volatile-function">2.197. Pragma Volatile_Function</a></li>
<li><a class="reference internal" href="#pragma-warning-as-error">2.198. Pragma Warning_As_Error</a></li>
<li><a class="reference internal" href="#pragma-warnings">2.199. Pragma Warnings</a></li>
<li><a class="reference internal" href="#pragma-weak-external">2.200. Pragma Weak_External</a></li>
<li><a class="reference internal" href="#pragma-wide-character-encoding">2.201. Pragma Wide_Character_Encoding</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="about_this_guide.html"
                        title="previous chapter"><span class="section-number">1. </span>About This Guide</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="implementation_defined_aspects.html"
                        title="next chapter"><span class="section-number">3. </span>Implementation Defined Aspects</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/gnat_rm/implementation_defined_pragmas.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="implementation_defined_aspects.html" title="3. Implementation Defined Aspects"
             >next</a> |</li>
        <li class="right" >
          <a href="about_this_guide.html" title="1. About This Guide"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../gnat_rm.html">GNAT Reference Manual 2021 documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><span class="section-number">2. </span>Implementation Defined Pragmas</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2008-2021, Free Software Foundation.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 3.2.1.
    </div>
  </body>
</html>