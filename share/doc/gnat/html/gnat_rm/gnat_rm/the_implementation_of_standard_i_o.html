
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>11. The Implementation of Standard I/O &#8212; GNAT Reference Manual 2021 documentation</title>
    <link rel="stylesheet" href="../_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="12. The GNAT Library" href="the_gnat_library.html" />
    <link rel="prev" title="10. Standard Library Routines" href="standard_library_routines.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="the_gnat_library.html" title="12. The GNAT Library"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="standard_library_routines.html" title="10. Standard Library Routines"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../gnat_rm.html">GNAT Reference Manual 2021 documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><span class="section-number">11. </span>The Implementation of Standard I/O</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="the-implementation-of-standard-i-o">
<span id="id1"></span><h1><span class="section-number">11. </span>The Implementation of Standard I/O<a class="headerlink" href="#the-implementation-of-standard-i-o" title="Permalink to this headline">¶</a></h1>
<p>GNAT implements all the required input-output facilities described in
A.6 through A.14.  These sections of the Ada Reference Manual describe the
required behavior of these packages from the Ada point of view, and if
you are writing a portable Ada program that does not need to know the
exact manner in which Ada maps to the outside world when it comes to
reading or writing external files, then you do not need to read this
chapter.  As long as your files are all regular files (not pipes or
devices), and as long as you write and read the files only from Ada, the
description in the Ada Reference Manual is sufficient.</p>
<p>However, if you want to do input-output to pipes or other devices, such
as the keyboard or screen, or if the files you are dealing with are
either generated by some other language, or to be read by some other
language, then you need to know more about the details of how the GNAT
implementation of these input-output facilities behaves.</p>
<p>In this chapter we give a detailed description of exactly how GNAT
interfaces to the file system.  As always, the sources of the system are
available to you for answering questions at an even more detailed level,
but for most purposes the information in this chapter will suffice.</p>
<p>Another reason that you may need to know more about how input-output is
implemented arises when you have a program written in mixed languages
where, for example, files are shared between the C and Ada sections of
the same program.  GNAT provides some additional facilities, in the form
of additional child library packages, that facilitate this sharing, and
these additional facilities are also described in this chapter.</p>
<div class="section" id="standard-i-o-packages">
<span id="id2"></span><h2><span class="section-number">11.1. </span>Standard I/O Packages<a class="headerlink" href="#standard-i-o-packages" title="Permalink to this headline">¶</a></h2>
<p>The Standard I/O packages described in Annex A for</p>
<ul class="simple">
<li><p>Ada.Text_IO</p></li>
<li><p>Ada.Text_IO.Complex_IO</p></li>
<li><p>Ada.Text_IO.Text_Streams</p></li>
<li><p>Ada.Wide_Text_IO</p></li>
<li><p>Ada.Wide_Text_IO.Complex_IO</p></li>
<li><p>Ada.Wide_Text_IO.Text_Streams</p></li>
<li><p>Ada.Wide_Wide_Text_IO</p></li>
<li><p>Ada.Wide_Wide_Text_IO.Complex_IO</p></li>
<li><p>Ada.Wide_Wide_Text_IO.Text_Streams</p></li>
<li><p>Ada.Stream_IO</p></li>
<li><p>Ada.Sequential_IO</p></li>
<li><p>Ada.Direct_IO</p></li>
</ul>
<p>are implemented using the C
library streams facility; where</p>
<ul class="simple">
<li><p>All files are opened using <code class="docutils literal notranslate"><span class="pre">fopen</span></code>.</p></li>
<li><p>All input/output operations use <code class="docutils literal notranslate"><span class="pre">fread</span></code>/<cite>fwrite</cite>.</p></li>
</ul>
<p>There is no internal buffering of any kind at the Ada library level. The only
buffering is that provided at the system level in the implementation of the
library routines that support streams. This facilitates shared use of these
streams by mixed language programs. Note though that system level buffering is
explicitly enabled at elaboration of the standard I/O packages and that can
have an impact on mixed language programs, in particular those using I/O before
calling the Ada elaboration routine (e.g., adainit). It is recommended to call
the Ada elaboration routine before performing any I/O or when impractical,
flush the common I/O streams and in particular Standard_Output before
elaborating the Ada code.</p>
</div>
<div class="section" id="form-strings">
<span id="id3"></span><h2><span class="section-number">11.2. </span>FORM Strings<a class="headerlink" href="#form-strings" title="Permalink to this headline">¶</a></h2>
<p>The format of a FORM string in GNAT is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="s2">&quot;keyword=value,keyword=value,...,keyword=value&quot;</span>
</pre></div>
</div>
<p>where letters may be in upper or lower case, and there are no spaces
between values.  The order of the entries is not important.  Currently
the following keywords defined.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">TEXT_TRANSLATION</span><span class="o">=</span><span class="p">[</span><span class="n">YES</span><span class="o">|</span><span class="n">NO</span><span class="o">|</span><span class="n">TEXT</span><span class="o">|</span><span class="n">BINARY</span><span class="o">|</span><span class="n">U8TEXT</span><span class="o">|</span><span class="n">WTEXT</span><span class="o">|</span><span class="n">U16TEXT</span><span class="p">]</span>
<span class="n">SHARED</span><span class="o">=</span><span class="p">[</span><span class="n">YES</span><span class="o">|</span><span class="n">NO</span><span class="p">]</span>
<span class="n">WCEM</span><span class="o">=</span><span class="p">[</span><span class="n">n</span><span class="o">|</span><span class="n">h</span><span class="o">|</span><span class="n">u</span><span class="o">|</span><span class="n">s</span><span class="o">|</span><span class="n">e</span><span class="o">|</span><span class="mi">8</span><span class="o">|</span><span class="n">b</span><span class="p">]</span>
<span class="n">ENCODING</span><span class="o">=</span><span class="p">[</span><span class="n">UTF8</span><span class="o">|</span><span class="mi">8</span><span class="n">BITS</span><span class="p">]</span>
</pre></div>
</div>
<p>The use of these parameters is described later in this section. If an
unrecognized keyword appears in a form string, it is silently ignored
and not considered invalid.</p>
</div>
<div class="section" id="direct-io">
<span id="id4"></span><h2><span class="section-number">11.3. </span>Direct_IO<a class="headerlink" href="#direct-io" title="Permalink to this headline">¶</a></h2>
<p>Direct_IO can only be instantiated for definite types.  This is a
restriction of the Ada language, which means that the records are fixed
length (the length being determined by <code class="docutils literal notranslate"><span class="pre">type'Size</span></code>, rounded
up to the next storage unit boundary if necessary).</p>
<p>The records of a Direct_IO file are simply written to the file in index
sequence, with the first record starting at offset zero, and subsequent
records following.  There is no control information of any kind.  For
example, if 32-bit integers are being written, each record takes
4-bytes, so the record at index <code class="docutils literal notranslate"><span class="pre">K</span></code> starts at offset
(<code class="docutils literal notranslate"><span class="pre">K</span></code>-1)*4.</p>
<p>There is no limit on the size of Direct_IO files, they are expanded as
necessary to accommodate whatever records are written to the file.</p>
</div>
<div class="section" id="sequential-io">
<span id="id5"></span><h2><span class="section-number">11.4. </span>Sequential_IO<a class="headerlink" href="#sequential-io" title="Permalink to this headline">¶</a></h2>
<p>Sequential_IO may be instantiated with either a definite (constrained)
or indefinite (unconstrained) type.</p>
<p>For the definite type case, the elements written to the file are simply
the memory images of the data values with no control information of any
kind.  The resulting file should be read using the same type, no validity
checking is performed on input.</p>
<p>For the indefinite type case, the elements written consist of two
parts.  First is the size of the data item, written as the memory image
of a <code class="docutils literal notranslate"><span class="pre">Interfaces.C.size_t</span></code> value, followed by the memory image of
the data value.  The resulting file can only be read using the same
(unconstrained) type.  Normal assignment checks are performed on these
read operations, and if these checks fail, <code class="docutils literal notranslate"><span class="pre">Data_Error</span></code> is
raised.  In particular, in the array case, the lengths must match, and in
the variant record case, if the variable for a particular read operation
is constrained, the discriminants must match.</p>
<p>Note that it is not possible to use Sequential_IO to write variable
length array items, and then read the data back into different length
arrays.  For example, the following will raise <code class="docutils literal notranslate"><span class="pre">Data_Error</span></code>:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="k">package </span><span class="nf">IO</span> <span class="kr">is</span><span class="p"> </span><span class="kr">new</span><span class="p"> </span><span class="n">Sequential_IO</span> <span class="o">(</span><span class="n">String</span><span class="o">)</span><span class="p">;</span>
<span class="n">F</span> <span class="o">:</span> <span class="n">IO.File_Type</span><span class="p">;</span>
<span class="n">S</span> <span class="o">:</span> <span class="n">String</span> <span class="o">(</span><span class="mi">1</span><span class="o">..</span><span class="mi">4</span><span class="o">)</span><span class="p">;</span>
<span class="o">...</span>
<span class="n">IO.Create</span> <span class="o">(</span><span class="n">F</span><span class="o">)</span>
<span class="n">IO.Write</span> <span class="o">(</span><span class="n">F</span><span class="p">,</span> <span class="s">&quot;hello!&quot;</span><span class="o">)</span>
<span class="n">IO.Reset</span> <span class="o">(</span><span class="n">F</span><span class="p">,</span> <span class="n">Mode</span><span class="o">=&gt;</span><span class="n">In_File</span><span class="o">)</span><span class="p">;</span>
<span class="n">IO.Read</span> <span class="o">(</span><span class="n">F</span><span class="p">,</span> <span class="n">S</span><span class="o">)</span><span class="p">;</span>
<span class="n">Put_Line</span> <span class="o">(</span><span class="n">S</span><span class="o">)</span><span class="p">;</span>
</pre></div>
</div>
<p>On some Ada implementations, this will print <code class="docutils literal notranslate"><span class="pre">hell</span></code>, but the program is
clearly incorrect, since there is only one element in the file, and that
element is the string <code class="docutils literal notranslate"><span class="pre">hello!</span></code>.</p>
<p>In Ada 95 and Ada 2005, this kind of behavior can be legitimately achieved
using Stream_IO, and this is the preferred mechanism.  In particular, the
above program fragment rewritten to use Stream_IO will work correctly.</p>
</div>
<div class="section" id="text-io">
<span id="id6"></span><h2><span class="section-number">11.5. </span>Text_IO<a class="headerlink" href="#text-io" title="Permalink to this headline">¶</a></h2>
<p>Text_IO files consist of a stream of characters containing the following
special control characters:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">LF</span> <span class="p">(</span><span class="n">line</span> <span class="n">feed</span><span class="p">,</span> <span class="mi">16</span><span class="c1">#0A#) Line Mark</span>
<span class="n">FF</span> <span class="p">(</span><span class="n">form</span> <span class="n">feed</span><span class="p">,</span> <span class="mi">16</span><span class="c1">#0C#) Page Mark</span>
</pre></div>
</div>
<p>A canonical Text_IO file is defined as one in which the following
conditions are met:</p>
<ul class="simple">
<li><p>The character <code class="docutils literal notranslate"><span class="pre">LF</span></code> is used only as a line mark, i.e., to mark the end
of the line.</p></li>
<li><p>The character <code class="docutils literal notranslate"><span class="pre">FF</span></code> is used only as a page mark, i.e., to mark the
end of a page and consequently can appear only immediately following a
<code class="docutils literal notranslate"><span class="pre">LF</span></code> (line mark) character.</p></li>
<li><p>The file ends with either <code class="docutils literal notranslate"><span class="pre">LF</span></code> (line mark) or <code class="docutils literal notranslate"><span class="pre">LF</span></code>-<cite>FF</cite>
(line mark, page mark).  In the former case, the page mark is implicitly
assumed to be present.</p></li>
</ul>
<p>A file written using Text_IO will be in canonical form provided that no
explicit <code class="docutils literal notranslate"><span class="pre">LF</span></code> or <code class="docutils literal notranslate"><span class="pre">FF</span></code> characters are written using <code class="docutils literal notranslate"><span class="pre">Put</span></code>
or <code class="docutils literal notranslate"><span class="pre">Put_Line</span></code>.  There will be no <code class="docutils literal notranslate"><span class="pre">FF</span></code> character at the end of
the file unless an explicit <code class="docutils literal notranslate"><span class="pre">New_Page</span></code> operation was performed
before closing the file.</p>
<p>A canonical Text_IO file that is a regular file (i.e., not a device or a
pipe) can be read using any of the routines in Text_IO.  The
semantics in this case will be exactly as defined in the Ada Reference
Manual, and all the routines in Text_IO are fully implemented.</p>
<p>A text file that does not meet the requirements for a canonical Text_IO
file has one of the following:</p>
<ul class="simple">
<li><p>The file contains <code class="docutils literal notranslate"><span class="pre">FF</span></code> characters not immediately following a
<code class="docutils literal notranslate"><span class="pre">LF</span></code> character.</p></li>
<li><p>The file contains <code class="docutils literal notranslate"><span class="pre">LF</span></code> or <code class="docutils literal notranslate"><span class="pre">FF</span></code> characters written by
<code class="docutils literal notranslate"><span class="pre">Put</span></code> or <code class="docutils literal notranslate"><span class="pre">Put_Line</span></code>, which are not logically considered to be
line marks or page marks.</p></li>
<li><p>The file ends in a character other than <code class="docutils literal notranslate"><span class="pre">LF</span></code> or <code class="docutils literal notranslate"><span class="pre">FF</span></code>,
i.e., there is no explicit line mark or page mark at the end of the file.</p></li>
</ul>
<p>Text_IO can be used to read such non-standard text files but subprograms
to do with line or page numbers do not have defined meanings.  In
particular, a <code class="docutils literal notranslate"><span class="pre">FF</span></code> character that does not follow a <code class="docutils literal notranslate"><span class="pre">LF</span></code>
character may or may not be treated as a page mark from the point of
view of page and line numbering.  Every <code class="docutils literal notranslate"><span class="pre">LF</span></code> character is considered
to end a line, and there is an implied <code class="docutils literal notranslate"><span class="pre">LF</span></code> character at the end of
the file.</p>
<div class="section" id="stream-pointer-positioning">
<span id="id7"></span><h3><span class="section-number">11.5.1. </span>Stream Pointer Positioning<a class="headerlink" href="#stream-pointer-positioning" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">Ada.Text_IO</span></code> has a definition of current position for a file that
is being read.  No internal buffering occurs in Text_IO, and usually the
physical position in the stream used to implement the file corresponds
to this logical position defined by Text_IO.  There are two exceptions:</p>
<ul class="simple">
<li><p>After a call to <code class="docutils literal notranslate"><span class="pre">End_Of_Page</span></code> that returns <code class="docutils literal notranslate"><span class="pre">True</span></code>, the stream
is positioned past the <code class="docutils literal notranslate"><span class="pre">LF</span></code> (line mark) that precedes the page
mark.  Text_IO maintains an internal flag so that subsequent read
operations properly handle the logical position which is unchanged by
the <code class="docutils literal notranslate"><span class="pre">End_Of_Page</span></code> call.</p></li>
<li><p>After a call to <code class="docutils literal notranslate"><span class="pre">End_Of_File</span></code> that returns <code class="docutils literal notranslate"><span class="pre">True</span></code>, if the
Text_IO file was positioned before the line mark at the end of file
before the call, then the logical position is unchanged, but the stream
is physically positioned right at the end of file (past the line mark,
and past a possible page mark following the line mark.  Again Text_IO
maintains internal flags so that subsequent read operations properly
handle the logical position.</p></li>
</ul>
<p>These discrepancies have no effect on the observable behavior of
Text_IO, but if a single Ada stream is shared between a C program and
Ada program, or shared (using <code class="docutils literal notranslate"><span class="pre">shared=yes</span></code> in the form string)
between two Ada files, then the difference may be observable in some
situations.</p>
</div>
<div class="section" id="reading-and-writing-non-regular-files">
<span id="id8"></span><h3><span class="section-number">11.5.2. </span>Reading and Writing Non-Regular Files<a class="headerlink" href="#reading-and-writing-non-regular-files" title="Permalink to this headline">¶</a></h3>
<p>A non-regular file is a device (such as a keyboard), or a pipe.  Text_IO
can be used for reading and writing.  Writing is not affected and the
sequence of characters output is identical to the normal file case, but
for reading, the behavior of Text_IO is modified to avoid undesirable
look-ahead as follows:</p>
<p>An input file that is not a regular file is considered to have no page
marks.  Any <code class="docutils literal notranslate"><span class="pre">Ascii.FF</span></code> characters (the character normally used for a
page mark) appearing in the file are considered to be data
characters.  In particular:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Get_Line</span></code> and <code class="docutils literal notranslate"><span class="pre">Skip_Line</span></code> do not test for a page mark
following a line mark.  If a page mark appears, it will be treated as a
data character.</p></li>
<li><p>This avoids the need to wait for an extra character to be typed or
entered from the pipe to complete one of these operations.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">End_Of_Page</span></code> always returns <code class="docutils literal notranslate"><span class="pre">False</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">End_Of_File</span></code> will return <code class="docutils literal notranslate"><span class="pre">False</span></code> if there is a page mark at
the end of the file.</p></li>
</ul>
<p>Output to non-regular files is the same as for regular files.  Page marks
may be written to non-regular files using <code class="docutils literal notranslate"><span class="pre">New_Page</span></code>, but as noted
above they will not be treated as page marks on input if the output is
piped to another Ada program.</p>
<p>Another important discrepancy when reading non-regular files is that the end
of file indication is not ‘sticky’.  If an end of file is entered, e.g., by
pressing the <kbd class="kbd docutils literal notranslate">EOT</kbd> key,
then end of file
is signaled once (i.e., the test <code class="docutils literal notranslate"><span class="pre">End_Of_File</span></code>
will yield <code class="docutils literal notranslate"><span class="pre">True</span></code>, or a read will
raise <code class="docutils literal notranslate"><span class="pre">End_Error</span></code>), but then reading can resume
to read data past that end of
file indication, until another end of file indication is entered.</p>
</div>
<div class="section" id="get-immediate">
<span id="id9"></span><h3><span class="section-number">11.5.3. </span>Get_Immediate<a class="headerlink" href="#get-immediate" title="Permalink to this headline">¶</a></h3>
<p id="index-0">Get_Immediate returns the next character (including control characters)
from the input file.  In particular, Get_Immediate will return LF or FF
characters used as line marks or page marks.  Such operations leave the
file positioned past the control character, and it is thus not treated
as having its normal function.  This means that page, line and column
counts after this kind of Get_Immediate call are set as though the mark
did not occur.  In the case where a Get_Immediate leaves the file
positioned between the line mark and page mark (which is not normally
possible), it is undefined whether the FF character will be treated as a
page mark.</p>
</div>
<div class="section" id="treating-text-io-files-as-streams">
<span id="id10"></span><h3><span class="section-number">11.5.4. </span>Treating Text_IO Files as Streams<a class="headerlink" href="#treating-text-io-files-as-streams" title="Permalink to this headline">¶</a></h3>
<p id="index-1">The package <code class="docutils literal notranslate"><span class="pre">Text_IO.Streams</span></code> allows a <code class="docutils literal notranslate"><span class="pre">Text_IO</span></code> file to be treated
as a stream.  Data written to a <code class="docutils literal notranslate"><span class="pre">Text_IO</span></code> file in this stream mode is
binary data.  If this binary data contains bytes 16#0A# (<code class="docutils literal notranslate"><span class="pre">LF</span></code>) or
16#0C# (<code class="docutils literal notranslate"><span class="pre">FF</span></code>), the resulting file may have non-standard
format.  Similarly if read operations are used to read from a Text_IO
file treated as a stream, then <code class="docutils literal notranslate"><span class="pre">LF</span></code> and <code class="docutils literal notranslate"><span class="pre">FF</span></code> characters may be
skipped and the effect is similar to that described above for
<code class="docutils literal notranslate"><span class="pre">Get_Immediate</span></code>.</p>
</div>
<div class="section" id="text-io-extensions">
<span id="id11"></span><h3><span class="section-number">11.5.5. </span>Text_IO Extensions<a class="headerlink" href="#text-io-extensions" title="Permalink to this headline">¶</a></h3>
<p id="index-2">A package GNAT.IO_Aux in the GNAT library provides some useful extensions
to the standard <code class="docutils literal notranslate"><span class="pre">Text_IO</span></code> package:</p>
<ul class="simple">
<li><p>function File_Exists (Name : String) return Boolean;
Determines if a file of the given name exists.</p></li>
<li><p>function Get_Line return String;
Reads a string from the standard input file.  The value returned is exactly
the length of the line that was read.</p></li>
<li><p>function Get_Line (File : Ada.Text_IO.File_Type) return String;
Similar, except that the parameter File specifies the file from which
the string is to be read.</p></li>
</ul>
</div>
<div class="section" id="text-io-facilities-for-unbounded-strings">
<span id="id12"></span><h3><span class="section-number">11.5.6. </span>Text_IO Facilities for Unbounded Strings<a class="headerlink" href="#text-io-facilities-for-unbounded-strings" title="Permalink to this headline">¶</a></h3>
<span class="target" id="index-3"></span><p id="index-4">The package <code class="docutils literal notranslate"><span class="pre">Ada.Strings.Unbounded.Text_IO</span></code>
in library files <code class="file docutils literal notranslate"><span class="pre">a-suteio.ads/adb</span></code> contains some GNAT-specific
subprograms useful for Text_IO operations on unbounded strings:</p>
<ul class="simple">
<li><p>function Get_Line (File : File_Type) return Unbounded_String;
Reads a line from the specified file
and returns the result as an unbounded string.</p></li>
<li><p>procedure Put (File : File_Type; U : Unbounded_String);
Writes the value of the given unbounded string to the specified file
Similar to the effect of
<code class="docutils literal notranslate"><span class="pre">Put</span> <span class="pre">(To_String</span> <span class="pre">(U))</span></code> except that an extra copy is avoided.</p></li>
<li><p>procedure Put_Line (File : File_Type; U : Unbounded_String);
Writes the value of the given unbounded string to the specified file,
followed by a <code class="docutils literal notranslate"><span class="pre">New_Line</span></code>.
Similar to the effect of <code class="docutils literal notranslate"><span class="pre">Put_Line</span> <span class="pre">(To_String</span> <span class="pre">(U))</span></code> except
that an extra copy is avoided.</p></li>
</ul>
<p>In the above procedures, <code class="docutils literal notranslate"><span class="pre">File</span></code> is of type <code class="docutils literal notranslate"><span class="pre">Ada.Text_IO.File_Type</span></code>
and is optional.  If the parameter is omitted, then the standard input or
output file is referenced as appropriate.</p>
<p>The package <code class="docutils literal notranslate"><span class="pre">Ada.Strings.Wide_Unbounded.Wide_Text_IO</span></code> in library
files <code class="file docutils literal notranslate"><span class="pre">a-swuwti.ads</span></code> and <code class="file docutils literal notranslate"><span class="pre">a-swuwti.adb</span></code> provides similar extended
<code class="docutils literal notranslate"><span class="pre">Wide_Text_IO</span></code> functionality for unbounded wide strings.</p>
<p>The package <code class="docutils literal notranslate"><span class="pre">Ada.Strings.Wide_Wide_Unbounded.Wide_Wide_Text_IO</span></code> in library
files <code class="file docutils literal notranslate"><span class="pre">a-szuzti.ads</span></code> and <code class="file docutils literal notranslate"><span class="pre">a-szuzti.adb</span></code> provides similar extended
<code class="docutils literal notranslate"><span class="pre">Wide_Wide_Text_IO</span></code> functionality for unbounded wide wide strings.</p>
</div>
</div>
<div class="section" id="wide-text-io">
<span id="id13"></span><h2><span class="section-number">11.6. </span>Wide_Text_IO<a class="headerlink" href="#wide-text-io" title="Permalink to this headline">¶</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">Wide_Text_IO</span></code> is similar in most respects to Text_IO, except that
both input and output files may contain special sequences that represent
wide character values.  The encoding scheme for a given file may be
specified using a FORM parameter:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>WCEM=`x`
</pre></div>
</div>
<p>as part of the FORM string (WCEM = wide character encoding method),
where <code class="docutils literal notranslate"><span class="pre">x</span></code> is one of the following characters</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 33%" />
<col style="width: 67%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Character</p></th>
<th class="head"><p>Encoding</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><em>h</em></p></td>
<td><p>Hex ESC encoding</p></td>
</tr>
<tr class="row-odd"><td><p><em>u</em></p></td>
<td><p>Upper half encoding</p></td>
</tr>
<tr class="row-even"><td><p><em>s</em></p></td>
<td><p>Shift-JIS encoding</p></td>
</tr>
<tr class="row-odd"><td><p><em>e</em></p></td>
<td><p>EUC Encoding</p></td>
</tr>
<tr class="row-even"><td><p><em>8</em></p></td>
<td><p>UTF-8 encoding</p></td>
</tr>
<tr class="row-odd"><td><p><em>b</em></p></td>
<td><p>Brackets encoding</p></td>
</tr>
</tbody>
</table>
<p>The encoding methods match those that
can be used in a source
program, but there is no requirement that the encoding method used for
the source program be the same as the encoding method used for files,
and different files may use different encoding methods.</p>
<p>The default encoding method for the standard files, and for opened files
for which no WCEM parameter is given in the FORM string matches the
wide character encoding specified for the main program (the default
being brackets encoding if no coding method was specified with -gnatW).</p>
<dl class="simple">
<dt><em>Hex Coding</em></dt><dd><p>In this encoding, a wide character is represented by a five character
sequence:</p>
</dd>
</dl>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ESC</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="n">d</span>
</pre></div>
</div>
<blockquote>
<div><p>where <code class="docutils literal notranslate"><span class="pre">a</span></code>, <code class="docutils literal notranslate"><span class="pre">b</span></code>, <code class="docutils literal notranslate"><span class="pre">c</span></code>, <code class="docutils literal notranslate"><span class="pre">d</span></code> are the four hexadecimal
characters (using upper case letters) of the wide character code.  For
example, ESC A345 is used to represent the wide character with code
16#A345#.  This scheme is compatible with use of the full
<code class="docutils literal notranslate"><span class="pre">Wide_Character</span></code> set.</p>
</div></blockquote>
<dl class="simple">
<dt><em>Upper Half Coding</em></dt><dd><p>The wide character with encoding 16#abcd#, where the upper bit is on
(i.e., a is in the range 8-F) is represented as two bytes 16#ab# and
16#cd#.  The second byte may never be a format control character, but is
not required to be in the upper half.  This method can be also used for
shift-JIS or EUC where the internal coding matches the external coding.</p>
</dd>
<dt><em>Shift JIS Coding</em></dt><dd><p>A wide character is represented by a two character sequence 16#ab# and
16#cd#, with the restrictions described for upper half encoding as
described above.  The internal character code is the corresponding JIS
character according to the standard algorithm for Shift-JIS
conversion.  Only characters defined in the JIS code set table can be
used with this encoding method.</p>
</dd>
<dt><em>EUC Coding</em></dt><dd><p>A wide character is represented by a two character sequence 16#ab# and
16#cd#, with both characters being in the upper half.  The internal
character code is the corresponding JIS character according to the EUC
encoding algorithm.  Only characters defined in the JIS code set table
can be used with this encoding method.</p>
</dd>
<dt><em>UTF-8 Coding</em></dt><dd><p>A wide character is represented using
UCS Transformation Format 8 (UTF-8) as defined in Annex R of ISO
10646-1/Am.2.  Depending on the character value, the representation
is a one, two, or three byte sequence:</p>
</dd>
</dl>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">16</span><span class="c1">#0000#-16#007f#: 2#0xxxxxxx#</span>
<span class="mi">16</span><span class="c1">#0080#-16#07ff#: 2#110xxxxx# 2#10xxxxxx#</span>
<span class="mi">16</span><span class="c1">#0800#-16#ffff#: 2#1110xxxx# 2#10xxxxxx# 2#10xxxxxx#</span>
</pre></div>
</div>
<blockquote>
<div><p>where the <code class="docutils literal notranslate"><span class="pre">xxx</span></code> bits correspond to the left-padded bits of the
16-bit character value.  Note that all lower half ASCII characters
are represented as ASCII bytes and all upper half characters and
other wide characters are represented as sequences of upper-half
(The full UTF-8 scheme allows for encoding 31-bit characters as
6-byte sequences, but in this implementation, all UTF-8 sequences
of four or more bytes length will raise a Constraint_Error, as
will all invalid UTF-8 sequences.)</p>
</div></blockquote>
<dl class="simple">
<dt><em>Brackets Coding</em></dt><dd><p>In this encoding, a wide character is represented by the following eight
character sequence:</p>
</dd>
</dl>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span> <span class="s2">&quot; a b c d &quot;</span> <span class="p">]</span>
</pre></div>
</div>
<blockquote>
<div><p>where <code class="docutils literal notranslate"><span class="pre">a</span></code>, <code class="docutils literal notranslate"><span class="pre">b</span></code>, <code class="docutils literal notranslate"><span class="pre">c</span></code>, <code class="docutils literal notranslate"><span class="pre">d</span></code> are the four hexadecimal
characters (using uppercase letters) of the wide character code.  For
example, <code class="docutils literal notranslate"><span class="pre">[&quot;A345&quot;]</span></code> is used to represent the wide character with code
<code class="docutils literal notranslate"><span class="pre">16#A345#</span></code>.
This scheme is compatible with use of the full Wide_Character set.
On input, brackets coding can also be used for upper half characters,
e.g., <code class="docutils literal notranslate"><span class="pre">[&quot;C1&quot;]</span></code> for lower case a.  However, on output, brackets notation
is only used for wide characters with a code greater than <code class="docutils literal notranslate"><span class="pre">16#FF#</span></code>.</p>
<p>Note that brackets coding is not normally used in the context of
Wide_Text_IO or Wide_Wide_Text_IO, since it is really just designed as
a portable way of encoding source files. In the context of Wide_Text_IO
or Wide_Wide_Text_IO, it can only be used if the file does not contain
any instance of the left bracket character other than to encode wide
character values using the brackets encoding method. In practice it is
expected that some standard wide character encoding method such
as UTF-8 will be used for text input output.</p>
<p>If brackets notation is used, then any occurrence of a left bracket
in the input file which is not the start of a valid wide character
sequence will cause Constraint_Error to be raised. It is possible to
encode a left bracket as [“5B”] and Wide_Text_IO and Wide_Wide_Text_IO
input will interpret this as a left bracket.</p>
<p>However, when a left bracket is output, it will be output as a left bracket
and not as [“5B”]. We make this decision because for normal use of
Wide_Text_IO for outputting messages, it is unpleasant to clobber left
brackets. For example, if we write:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="n">Put_Line</span> <span class="o">(</span><span class="s">&quot;Start of output [first run]&quot;</span><span class="o">)</span><span class="p">;</span>
</pre></div>
</div>
<p>we really do not want to have the left bracket in this message clobbered so
that the output reads:</p>
</div></blockquote>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Start</span> <span class="n">of</span> <span class="n">output</span> <span class="p">[</span><span class="s2">&quot;5B&quot;</span><span class="p">]</span><span class="n">first</span> <span class="n">run</span><span class="p">]</span>
</pre></div>
</div>
<blockquote>
<div><p>In practice brackets encoding is reasonably useful for normal Put_Line use
since we won’t get confused between left brackets and wide character
sequences in the output. But for input, or when files are written out
and read back in, it really makes better sense to use one of the standard
encoding methods such as UTF-8.</p>
</div></blockquote>
<p>For the coding schemes other than UTF-8, Hex, or Brackets encoding,
not all wide character
values can be represented.  An attempt to output a character that cannot
be represented using the encoding scheme for the file causes
Constraint_Error to be raised.  An invalid wide character sequence on
input also causes Constraint_Error to be raised.</p>
<div class="section" id="stream-pointer-positioning-1">
<span id="id14"></span><h3><span class="section-number">11.6.1. </span>Stream Pointer Positioning<a class="headerlink" href="#stream-pointer-positioning-1" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">Ada.Wide_Text_IO</span></code> is similar to <code class="docutils literal notranslate"><span class="pre">Ada.Text_IO</span></code> in its handling
of stream pointer positioning (<a class="reference internal" href="#text-io"><span class="std std-ref">Text_IO</span></a>).  There is one additional
case:</p>
<p>If <code class="docutils literal notranslate"><span class="pre">Ada.Wide_Text_IO.Look_Ahead</span></code> reads a character outside the
normal lower ASCII set (i.e., a character in the range:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="n">Wide_Character</span><span class="na">&#39;Val</span> <span class="o">(</span><span class="mi">16#0080#</span><span class="o">)</span> <span class="o">..</span> <span class="n">Wide_Character</span><span class="na">&#39;Val</span> <span class="o">(</span><span class="mi">16#FFFF#</span><span class="o">)</span>
</pre></div>
</div>
<p>then although the logical position of the file pointer is unchanged by
the <code class="docutils literal notranslate"><span class="pre">Look_Ahead</span></code> call, the stream is physically positioned past the
wide character sequence.  Again this is to avoid the need for buffering
or backup, and all <code class="docutils literal notranslate"><span class="pre">Wide_Text_IO</span></code> routines check the internal
indication that this situation has occurred so that this is not visible
to a normal program using <code class="docutils literal notranslate"><span class="pre">Wide_Text_IO</span></code>.  However, this discrepancy
can be observed if the wide text file shares a stream with another file.</p>
</div>
<div class="section" id="reading-and-writing-non-regular-files-1">
<span id="id15"></span><h3><span class="section-number">11.6.2. </span>Reading and Writing Non-Regular Files<a class="headerlink" href="#reading-and-writing-non-regular-files-1" title="Permalink to this headline">¶</a></h3>
<p>As in the case of Text_IO, when a non-regular file is read, it is
assumed that the file contains no page marks (any form characters are
treated as data characters), and <code class="docutils literal notranslate"><span class="pre">End_Of_Page</span></code> always returns
<code class="docutils literal notranslate"><span class="pre">False</span></code>.  Similarly, the end of file indication is not sticky, so
it is possible to read beyond an end of file.</p>
</div>
</div>
<div class="section" id="wide-wide-text-io">
<span id="id16"></span><h2><span class="section-number">11.7. </span>Wide_Wide_Text_IO<a class="headerlink" href="#wide-wide-text-io" title="Permalink to this headline">¶</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">Wide_Wide_Text_IO</span></code> is similar in most respects to Text_IO, except that
both input and output files may contain special sequences that represent
wide wide character values.  The encoding scheme for a given file may be
specified using a FORM parameter:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>WCEM=`x`
</pre></div>
</div>
<p>as part of the FORM string (WCEM = wide character encoding method),
where <code class="docutils literal notranslate"><span class="pre">x</span></code> is one of the following characters</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 33%" />
<col style="width: 67%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Character</p></th>
<th class="head"><p>Encoding</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><em>h</em></p></td>
<td><p>Hex ESC encoding</p></td>
</tr>
<tr class="row-odd"><td><p><em>u</em></p></td>
<td><p>Upper half encoding</p></td>
</tr>
<tr class="row-even"><td><p><em>s</em></p></td>
<td><p>Shift-JIS encoding</p></td>
</tr>
<tr class="row-odd"><td><p><em>e</em></p></td>
<td><p>EUC Encoding</p></td>
</tr>
<tr class="row-even"><td><p><em>8</em></p></td>
<td><p>UTF-8 encoding</p></td>
</tr>
<tr class="row-odd"><td><p><em>b</em></p></td>
<td><p>Brackets encoding</p></td>
</tr>
</tbody>
</table>
<p>The encoding methods match those that
can be used in a source
program, but there is no requirement that the encoding method used for
the source program be the same as the encoding method used for files,
and different files may use different encoding methods.</p>
<p>The default encoding method for the standard files, and for opened files
for which no WCEM parameter is given in the FORM string matches the
wide character encoding specified for the main program (the default
being brackets encoding if no coding method was specified with -gnatW).</p>
<dl class="simple">
<dt><em>UTF-8 Coding</em></dt><dd><p>A wide character is represented using
UCS Transformation Format 8 (UTF-8) as defined in Annex R of ISO
10646-1/Am.2.  Depending on the character value, the representation
is a one, two, three, or four byte sequence:</p>
</dd>
</dl>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">16</span><span class="c1">#000000#-16#00007f#: 2#0xxxxxxx#</span>
<span class="mi">16</span><span class="c1">#000080#-16#0007ff#: 2#110xxxxx# 2#10xxxxxx#</span>
<span class="mi">16</span><span class="c1">#000800#-16#00ffff#: 2#1110xxxx# 2#10xxxxxx# 2#10xxxxxx#</span>
<span class="mi">16</span><span class="c1">#010000#-16#10ffff#: 2#11110xxx# 2#10xxxxxx# 2#10xxxxxx# 2#10xxxxxx#</span>
</pre></div>
</div>
<blockquote>
<div><p>where the <code class="docutils literal notranslate"><span class="pre">xxx</span></code> bits correspond to the left-padded bits of the
21-bit character value.  Note that all lower half ASCII characters
are represented as ASCII bytes and all upper half characters and
other wide characters are represented as sequences of upper-half
characters.</p>
</div></blockquote>
<dl class="simple">
<dt><em>Brackets Coding</em></dt><dd><p>In this encoding, a wide wide character is represented by the following eight
character sequence if is in wide character range</p>
</dd>
</dl>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span> <span class="s2">&quot; a b c d &quot;</span> <span class="p">]</span>
</pre></div>
</div>
<blockquote>
<div><p>and by the following ten character sequence if not</p>
</div></blockquote>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span> <span class="s2">&quot; a b c d e f &quot;</span> <span class="p">]</span>
</pre></div>
</div>
<blockquote>
<div><p>where <code class="docutils literal notranslate"><span class="pre">a</span></code>, <code class="docutils literal notranslate"><span class="pre">b</span></code>, <code class="docutils literal notranslate"><span class="pre">c</span></code>, <code class="docutils literal notranslate"><span class="pre">d</span></code>, <code class="docutils literal notranslate"><span class="pre">e</span></code>, and <code class="docutils literal notranslate"><span class="pre">f</span></code>
are the four or six hexadecimal
characters (using uppercase letters) of the wide wide character code.  For
example, <code class="docutils literal notranslate"><span class="pre">[&quot;01A345&quot;]</span></code> is used to represent the wide wide character
with code <code class="docutils literal notranslate"><span class="pre">16#01A345#</span></code>.</p>
<p>This scheme is compatible with use of the full Wide_Wide_Character set.
On input, brackets coding can also be used for upper half characters,
e.g., <code class="docutils literal notranslate"><span class="pre">[&quot;C1&quot;]</span></code> for lower case a.  However, on output, brackets notation
is only used for wide characters with a code greater than <code class="docutils literal notranslate"><span class="pre">16#FF#</span></code>.</p>
</div></blockquote>
<p>If is also possible to use the other Wide_Character encoding methods,
such as Shift-JIS, but the other schemes cannot support the full range
of wide wide characters.
An attempt to output a character that cannot
be represented using the encoding scheme for the file causes
Constraint_Error to be raised.  An invalid wide character sequence on
input also causes Constraint_Error to be raised.</p>
<div class="section" id="stream-pointer-positioning-2">
<span id="id17"></span><h3><span class="section-number">11.7.1. </span>Stream Pointer Positioning<a class="headerlink" href="#stream-pointer-positioning-2" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">Ada.Wide_Wide_Text_IO</span></code> is similar to <code class="docutils literal notranslate"><span class="pre">Ada.Text_IO</span></code> in its handling
of stream pointer positioning (<a class="reference internal" href="#text-io"><span class="std std-ref">Text_IO</span></a>).  There is one additional
case:</p>
<p>If <code class="docutils literal notranslate"><span class="pre">Ada.Wide_Wide_Text_IO.Look_Ahead</span></code> reads a character outside the
normal lower ASCII set (i.e., a character in the range:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="n">Wide_Wide_Character</span><span class="na">&#39;Val</span> <span class="o">(</span><span class="mi">16#0080#</span><span class="o">)</span> <span class="o">..</span> <span class="n">Wide_Wide_Character</span><span class="na">&#39;Val</span> <span class="o">(</span><span class="mi">16#10FFFF#</span><span class="o">)</span>
</pre></div>
</div>
<p>then although the logical position of the file pointer is unchanged by
the <code class="docutils literal notranslate"><span class="pre">Look_Ahead</span></code> call, the stream is physically positioned past the
wide character sequence.  Again this is to avoid the need for buffering
or backup, and all <code class="docutils literal notranslate"><span class="pre">Wide_Wide_Text_IO</span></code> routines check the internal
indication that this situation has occurred so that this is not visible
to a normal program using <code class="docutils literal notranslate"><span class="pre">Wide_Wide_Text_IO</span></code>.  However, this discrepancy
can be observed if the wide text file shares a stream with another file.</p>
</div>
<div class="section" id="reading-and-writing-non-regular-files-2">
<span id="id18"></span><h3><span class="section-number">11.7.2. </span>Reading and Writing Non-Regular Files<a class="headerlink" href="#reading-and-writing-non-regular-files-2" title="Permalink to this headline">¶</a></h3>
<p>As in the case of Text_IO, when a non-regular file is read, it is
assumed that the file contains no page marks (any form characters are
treated as data characters), and <code class="docutils literal notranslate"><span class="pre">End_Of_Page</span></code> always returns
<code class="docutils literal notranslate"><span class="pre">False</span></code>.  Similarly, the end of file indication is not sticky, so
it is possible to read beyond an end of file.</p>
</div>
</div>
<div class="section" id="stream-io">
<span id="id19"></span><h2><span class="section-number">11.8. </span>Stream_IO<a class="headerlink" href="#stream-io" title="Permalink to this headline">¶</a></h2>
<p>A stream file is a sequence of bytes, where individual elements are
written to the file as described in the Ada Reference Manual.  The type
<code class="docutils literal notranslate"><span class="pre">Stream_Element</span></code> is simply a byte.  There are two ways to read or
write a stream file.</p>
<ul class="simple">
<li><p>The operations <code class="docutils literal notranslate"><span class="pre">Read</span></code> and <code class="docutils literal notranslate"><span class="pre">Write</span></code> directly read or write a
sequence of stream elements with no control information.</p></li>
<li><p>The stream attributes applied to a stream file transfer data in the
manner described for stream attributes.</p></li>
</ul>
</div>
<div class="section" id="text-translation">
<span id="id20"></span><h2><span class="section-number">11.9. </span>Text Translation<a class="headerlink" href="#text-translation" title="Permalink to this headline">¶</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">Text_Translation=xxx</span></code> may be used as the Form parameter
passed to Text_IO.Create and Text_IO.Open. <code class="docutils literal notranslate"><span class="pre">Text_Translation=xxx</span></code>
has no effect on Unix systems. Possible values are:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">Yes</span></code> or <code class="docutils literal notranslate"><span class="pre">Text</span></code> is the default, which means to
translate LF to/from CR/LF on Windows systems.</p>
<p><code class="docutils literal notranslate"><span class="pre">No</span></code> disables this translation; i.e. it
uses binary mode. For output files, <code class="docutils literal notranslate"><span class="pre">Text_Translation=No</span></code>
may be used to create Unix-style files on
Windows.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">wtext</span></code> translation enabled in Unicode mode.
(corresponds to _O_WTEXT).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">u8text</span></code> translation enabled in Unicode UTF-8 mode.
(corresponds to O_U8TEXT).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">u16text</span></code> translation enabled in Unicode UTF-16
mode. (corresponds to_O_U16TEXT).</p></li>
</ul>
</div>
<div class="section" id="shared-files">
<span id="id21"></span><h2><span class="section-number">11.10. </span>Shared Files<a class="headerlink" href="#shared-files" title="Permalink to this headline">¶</a></h2>
<p>Section A.14 of the Ada Reference Manual allows implementations to
provide a wide variety of behavior if an attempt is made to access the
same external file with two or more internal files.</p>
<p>To provide a full range of functionality, while at the same time
minimizing the problems of portability caused by this implementation
dependence, GNAT handles file sharing as follows:</p>
<ul class="simple">
<li><p>In the absence of a <code class="docutils literal notranslate"><span class="pre">shared=xxx</span></code> form parameter, an attempt
to open two or more files with the same full name is considered an error
and is not supported.  The exception <code class="docutils literal notranslate"><span class="pre">Use_Error</span></code> will be
raised.  Note that a file that is not explicitly closed by the program
remains open until the program terminates.</p></li>
<li><p>If the form parameter <code class="docutils literal notranslate"><span class="pre">shared=no</span></code> appears in the form string, the
file can be opened or created with its own separate stream identifier,
regardless of whether other files sharing the same external file are
opened.  The exact effect depends on how the C stream routines handle
multiple accesses to the same external files using separate streams.</p></li>
<li><p>If the form parameter <code class="docutils literal notranslate"><span class="pre">shared=yes</span></code> appears in the form string for
each of two or more files opened using the same full name, the same
stream is shared between these files, and the semantics are as described
in Ada Reference Manual, Section A.14.</p></li>
</ul>
<p>When a program that opens multiple files with the same name is ported
from another Ada compiler to GNAT, the effect will be that
<code class="docutils literal notranslate"><span class="pre">Use_Error</span></code> is raised.</p>
<p>The documentation of the original compiler and the documentation of the
program should then be examined to determine if file sharing was
expected, and <code class="docutils literal notranslate"><span class="pre">shared=xxx</span></code> parameters added to <code class="docutils literal notranslate"><span class="pre">Open</span></code>
and <code class="docutils literal notranslate"><span class="pre">Create</span></code> calls as required.</p>
<p>When a program is ported from GNAT to some other Ada compiler, no
special attention is required unless the <code class="docutils literal notranslate"><span class="pre">shared=xxx</span></code> form
parameter is used in the program.  In this case, you must examine the
documentation of the new compiler to see if it supports the required
file sharing semantics, and form strings modified appropriately.  Of
course it may be the case that the program cannot be ported if the
target compiler does not support the required functionality.  The best
approach in writing portable code is to avoid file sharing (and hence
the use of the <code class="docutils literal notranslate"><span class="pre">shared=xxx</span></code> parameter in the form string)
completely.</p>
<p>One common use of file sharing in Ada 83 is the use of instantiations of
Sequential_IO on the same file with different types, to achieve
heterogeneous input-output.  Although this approach will work in GNAT if
<code class="docutils literal notranslate"><span class="pre">shared=yes</span></code> is specified, it is preferable in Ada to use Stream_IO
for this purpose (using the stream attributes)</p>
</div>
<div class="section" id="filenames-encoding">
<span id="id22"></span><h2><span class="section-number">11.11. </span>Filenames encoding<a class="headerlink" href="#filenames-encoding" title="Permalink to this headline">¶</a></h2>
<p>An encoding form parameter can be used to specify the filename
encoding <code class="docutils literal notranslate"><span class="pre">encoding=xxx</span></code>.</p>
<ul class="simple">
<li><p>If the form parameter <code class="docutils literal notranslate"><span class="pre">encoding=utf8</span></code> appears in the form string, the
filename must be encoded in UTF-8.</p></li>
<li><p>If the form parameter <code class="docutils literal notranslate"><span class="pre">encoding=8bits</span></code> appears in the form
string, the filename must be a standard 8bits string.</p></li>
</ul>
<p>In the absence of a <code class="docutils literal notranslate"><span class="pre">encoding=xxx</span></code> form parameter, the
encoding is controlled by the <code class="docutils literal notranslate"><span class="pre">GNAT_CODE_PAGE</span></code> environment
variable. And if not set <code class="docutils literal notranslate"><span class="pre">utf8</span></code> is assumed.</p>
<dl class="simple">
<dt><em>CP_ACP</em></dt><dd><p>The current system Windows ANSI code page.</p>
</dd>
<dt><em>CP_UTF8</em></dt><dd><p>UTF-8 encoding</p>
</dd>
</dl>
<p>This encoding form parameter is only supported on the Windows
platform. On the other Operating Systems the run-time is supporting
UTF-8 natively.</p>
</div>
<div class="section" id="file-content-encoding">
<span id="id23"></span><h2><span class="section-number">11.12. </span>File content encoding<a class="headerlink" href="#file-content-encoding" title="Permalink to this headline">¶</a></h2>
<p>For text files it is possible to specify the encoding to use. This is
controlled by the by the <code class="docutils literal notranslate"><span class="pre">GNAT_CCS_ENCODING</span></code> environment
variable. And if not set <code class="docutils literal notranslate"><span class="pre">TEXT</span></code> is assumed.</p>
<p>The possible values are those supported on Windows:</p>
<dl class="simple">
<dt><em>TEXT</em></dt><dd><p>Translated text mode</p>
</dd>
<dt><em>WTEXT</em></dt><dd><p>Translated unicode encoding</p>
</dd>
<dt><em>U16TEXT</em></dt><dd><p>Unicode 16-bit encoding</p>
</dd>
<dt><em>U8TEXT</em></dt><dd><p>Unicode 8-bit encoding</p>
</dd>
</dl>
<p>This encoding is only supported on the Windows platform.</p>
</div>
<div class="section" id="open-modes">
<span id="id24"></span><h2><span class="section-number">11.13. </span>Open Modes<a class="headerlink" href="#open-modes" title="Permalink to this headline">¶</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">Open</span></code> and <code class="docutils literal notranslate"><span class="pre">Create</span></code> calls result in a call to <code class="docutils literal notranslate"><span class="pre">fopen</span></code>
using the mode shown in the following table:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 46%" />
<col style="width: 25%" />
<col style="width: 30%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head" colspan="3"><p><code class="docutils literal notranslate"><span class="pre">Open</span></code> and <code class="docutils literal notranslate"><span class="pre">Create</span></code> Call Modes</p></th>
</tr>
<tr class="row-even"><th class="head"></th>
<th class="head"><p><strong>OPEN</strong></p></th>
<th class="head"><p><strong>CREATE</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-odd"><td><p>Append_File</p></td>
<td><p>“r+”</p></td>
<td><p>“w+”</p></td>
</tr>
<tr class="row-even"><td><p>In_File</p></td>
<td><p>“r”</p></td>
<td><p>“w+”</p></td>
</tr>
<tr class="row-odd"><td><p>Out_File (Direct_IO)</p></td>
<td><p>“r+”</p></td>
<td><p>“w”</p></td>
</tr>
<tr class="row-even"><td><p>Out_File (all other cases)</p></td>
<td><p>“w”</p></td>
<td><p>“w”</p></td>
</tr>
<tr class="row-odd"><td><p>Inout_File</p></td>
<td><p>“r+”</p></td>
<td><p>“w+”</p></td>
</tr>
</tbody>
</table>
<p>If text file translation is required, then either <code class="docutils literal notranslate"><span class="pre">b</span></code> or <code class="docutils literal notranslate"><span class="pre">t</span></code>
is added to the mode, depending on the setting of Text.  Text file
translation refers to the mapping of CR/LF sequences in an external file
to LF characters internally.  This mapping only occurs in DOS and
DOS-like systems, and is not relevant to other systems.</p>
<p>A special case occurs with Stream_IO.  As shown in the above table, the
file is initially opened in <code class="docutils literal notranslate"><span class="pre">r</span></code> or <code class="docutils literal notranslate"><span class="pre">w</span></code> mode for the
<code class="docutils literal notranslate"><span class="pre">In_File</span></code> and <code class="docutils literal notranslate"><span class="pre">Out_File</span></code> cases.  If a <code class="docutils literal notranslate"><span class="pre">Set_Mode</span></code> operation
subsequently requires switching from reading to writing or vice-versa,
then the file is reopened in <code class="docutils literal notranslate"><span class="pre">r+</span></code> mode to permit the required operation.</p>
</div>
<div class="section" id="operations-on-c-streams">
<span id="id25"></span><h2><span class="section-number">11.14. </span>Operations on C Streams<a class="headerlink" href="#operations-on-c-streams" title="Permalink to this headline">¶</a></h2>
<p>The package <code class="docutils literal notranslate"><span class="pre">Interfaces.C_Streams</span></code> provides an Ada program with direct
access to the C library functions for operations on C streams:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="k">package </span><span class="nf">Interfaces.C_Streams</span> <span class="kr">is</span><span class="p"></span>
  <span class="c">-- Note: the reason we do not use the types that are in</span>
  <span class="c">-- Interfaces.C is that we want to avoid dragging in the</span>
  <span class="c">-- code in this unit if possible.</span>
  <span class="kr">subtype</span><span class="p"> </span><span class="n">chars</span> <span class="kr">is</span><span class="p"> </span><span class="n">System.Address</span><span class="p">;</span>
  <span class="c">-- Pointer to null-terminated array of characters</span>
  <span class="kr">subtype</span><span class="p"> </span><span class="n">FILEs</span> <span class="kr">is</span><span class="p"> </span><span class="n">System.Address</span><span class="p">;</span>
  <span class="c">-- Corresponds to the C type FILE*</span>
  <span class="kr">subtype</span><span class="p"> </span><span class="n">voids</span> <span class="kr">is</span><span class="p"> </span><span class="n">System.Address</span><span class="p">;</span>
  <span class="c">-- Corresponds to the C type void*</span>
  <span class="kr">subtype</span><span class="p"> </span><span class="n">int</span> <span class="kr">is</span><span class="p"> </span><span class="n">Integer</span><span class="p">;</span>
  <span class="kr">subtype</span><span class="p"> </span><span class="n">long</span> <span class="kr">is</span><span class="p"> </span><span class="n">Long_Integer</span><span class="p">;</span>
  <span class="c">-- Note: the above types are subtypes deliberately, and it</span>
  <span class="c">-- is part of this spec that the above correspondences are</span>
  <span class="c">-- guaranteed.  This means that it is legitimate to, for</span>
  <span class="c">-- example, use Integer instead of int.  We provide these</span>
  <span class="c">-- synonyms for clarity, but in some cases it may be</span>
  <span class="c">-- convenient to use the underlying types (for example to</span>
  <span class="c">-- avoid an unnecessary dependency of a spec on the spec</span>
  <span class="c">-- of this unit).</span>
  <span class="kr">type</span><span class="p"> </span><span class="n">size_t</span> <span class="kr">is</span><span class="p"> </span><span class="kr">mod</span><span class="p"> </span><span class="mi">2</span> <span class="o">**</span> <span class="n">Standard</span><span class="na">&#39;Address_Size</span><span class="p">;</span>
  <span class="n">NULL_Stream</span> <span class="o">:</span> <span class="kr">constant</span><span class="p"> </span><span class="n">FILEs</span><span class="p">;</span>
  <span class="c">-- Value returned (NULL in C) to indicate an</span>
  <span class="c">-- fdopen/fopen/tmpfile error</span>
  <span class="c">----------------------------------</span>
  <span class="c">-- Constants Defined in stdio.h --</span>
  <span class="c">----------------------------------</span>
  <span class="n">EOF</span> <span class="o">:</span> <span class="kr">constant</span><span class="p"> </span><span class="n">int</span><span class="p">;</span>
  <span class="c">-- Used by a number of routines to indicate error or</span>
  <span class="c">-- end of file</span>
  <span class="n">IOFBF</span> <span class="o">:</span> <span class="kr">constant</span><span class="p"> </span><span class="n">int</span><span class="p">;</span>
  <span class="n">IOLBF</span> <span class="o">:</span> <span class="kr">constant</span><span class="p"> </span><span class="n">int</span><span class="p">;</span>
  <span class="n">IONBF</span> <span class="o">:</span> <span class="kr">constant</span><span class="p"> </span><span class="n">int</span><span class="p">;</span>
  <span class="c">-- Used to indicate buffering mode for setvbuf call</span>
  <span class="n">SEEK_CUR</span> <span class="o">:</span> <span class="kr">constant</span><span class="p"> </span><span class="n">int</span><span class="p">;</span>
  <span class="n">SEEK_END</span> <span class="o">:</span> <span class="kr">constant</span><span class="p"> </span><span class="n">int</span><span class="p">;</span>
  <span class="n">SEEK_SET</span> <span class="o">:</span> <span class="kr">constant</span><span class="p"> </span><span class="n">int</span><span class="p">;</span>
  <span class="c">-- Used to indicate origin for fseek call</span>
  <span class="k">function </span><span class="nf">stdin</span> <span class="kr">return</span><span class="p"> </span><span class="n">FILEs</span><span class="p">;</span>
  <span class="k">function </span><span class="nf">stdout</span> <span class="kr">return</span><span class="p"> </span><span class="n">FILEs</span><span class="p">;</span>
  <span class="k">function </span><span class="nf">stderr</span> <span class="kr">return</span><span class="p"> </span><span class="n">FILEs</span><span class="p">;</span>
  <span class="c">-- Streams associated with standard files</span>
  <span class="c">--------------------------</span>
  <span class="c">-- Standard C functions --</span>
  <span class="c">--------------------------</span>
  <span class="c">-- The functions selected below are ones that are</span>
  <span class="c">-- available in UNIX (but not necessarily in ANSI C).</span>
  <span class="c">-- These are very thin interfaces</span>
  <span class="c">-- which copy exactly the C headers.  For more</span>
  <span class="c">-- documentation on these functions, see the Microsoft C</span>
  <span class="c">-- &quot;Run-Time Library Reference&quot; (Microsoft Press, 1990,</span>
  <span class="c">-- ISBN 1-55615-225-6), which includes useful information</span>
  <span class="c">-- on system compatibility.</span>
  <span class="k">procedure </span><span class="nf">clearerr</span> <span class="o">(</span><span class="n">stream</span> <span class="o">:</span> <span class="n">FILEs</span><span class="o">)</span><span class="p">;</span>
  <span class="k">function </span><span class="nf">fclose</span> <span class="o">(</span><span class="n">stream</span> <span class="o">:</span> <span class="n">FILEs</span><span class="o">)</span> <span class="kr">return</span><span class="p"> </span><span class="n">int</span><span class="p">;</span>
  <span class="k">function </span><span class="nf">fdopen</span> <span class="o">(</span><span class="n">handle</span> <span class="o">:</span> <span class="n">int</span><span class="p">;</span> <span class="n">mode</span> <span class="o">:</span> <span class="n">chars</span><span class="o">)</span> <span class="kr">return</span><span class="p"> </span><span class="n">FILEs</span><span class="p">;</span>
  <span class="k">function </span><span class="nf">feof</span> <span class="o">(</span><span class="n">stream</span> <span class="o">:</span> <span class="n">FILEs</span><span class="o">)</span> <span class="kr">return</span><span class="p"> </span><span class="n">int</span><span class="p">;</span>
  <span class="k">function </span><span class="nf">ferror</span> <span class="o">(</span><span class="n">stream</span> <span class="o">:</span> <span class="n">FILEs</span><span class="o">)</span> <span class="kr">return</span><span class="p"> </span><span class="n">int</span><span class="p">;</span>
  <span class="k">function </span><span class="nf">fflush</span> <span class="o">(</span><span class="n">stream</span> <span class="o">:</span> <span class="n">FILEs</span><span class="o">)</span> <span class="kr">return</span><span class="p"> </span><span class="n">int</span><span class="p">;</span>
  <span class="k">function </span><span class="nf">fgetc</span> <span class="o">(</span><span class="n">stream</span> <span class="o">:</span> <span class="n">FILEs</span><span class="o">)</span> <span class="kr">return</span><span class="p"> </span><span class="n">int</span><span class="p">;</span>
  <span class="k">function </span><span class="nf">fgets</span> <span class="o">(</span><span class="n">strng</span> <span class="o">:</span> <span class="n">chars</span><span class="p">;</span> <span class="n">n</span> <span class="o">:</span> <span class="n">int</span><span class="p">;</span> <span class="n">stream</span> <span class="o">:</span> <span class="n">FILEs</span><span class="o">)</span>
      <span class="kr">return</span><span class="p"> </span><span class="n">chars</span><span class="p">;</span>
  <span class="k">function </span><span class="nf">fileno</span> <span class="o">(</span><span class="n">stream</span> <span class="o">:</span> <span class="n">FILEs</span><span class="o">)</span> <span class="kr">return</span><span class="p"> </span><span class="n">int</span><span class="p">;</span>
  <span class="k">function </span><span class="nf">fopen</span> <span class="o">(</span><span class="n">filename</span> <span class="o">:</span> <span class="n">chars</span><span class="p">;</span> <span class="n">Mode</span> <span class="o">:</span> <span class="n">chars</span><span class="o">)</span>
      <span class="kr">return</span><span class="p"> </span><span class="n">FILEs</span><span class="p">;</span>
  <span class="c">-- Note: to maintain target independence, use</span>
  <span class="c">-- text_translation_required, a boolean variable defined in</span>
  <span class="c">-- a-sysdep.c to deal with the target dependent text</span>
  <span class="c">-- translation requirement.  If this variable is set,</span>
  <span class="c">-- then  b/t should be appended to the standard mode</span>
  <span class="c">-- argument to set the text translation mode off or on</span>
  <span class="c">-- as required.</span>
  <span class="k">function </span><span class="nf">fputc</span> <span class="o">(</span><span class="n">C</span> <span class="o">:</span> <span class="n">int</span><span class="p">;</span> <span class="n">stream</span> <span class="o">:</span> <span class="n">FILEs</span><span class="o">)</span> <span class="kr">return</span><span class="p"> </span><span class="n">int</span><span class="p">;</span>
  <span class="k">function </span><span class="nf">fputs</span> <span class="o">(</span><span class="n">Strng</span> <span class="o">:</span> <span class="n">chars</span><span class="p">;</span> <span class="n">Stream</span> <span class="o">:</span> <span class="n">FILEs</span><span class="o">)</span> <span class="kr">return</span><span class="p"> </span><span class="n">int</span><span class="p">;</span>
  <span class="k">function </span><span class="nf">fread</span>
     <span class="o">(</span><span class="n">buffer</span> <span class="o">:</span> <span class="n">voids</span><span class="p">;</span>
      <span class="n">size</span> <span class="o">:</span> <span class="n">size_t</span><span class="p">;</span>
      <span class="n">count</span> <span class="o">:</span> <span class="n">size_t</span><span class="p">;</span>
      <span class="n">stream</span> <span class="o">:</span> <span class="n">FILEs</span><span class="o">)</span>
      <span class="kr">return</span><span class="p"> </span><span class="n">size_t</span><span class="p">;</span>
  <span class="k">function </span><span class="nf">freopen</span>
     <span class="o">(</span><span class="n">filename</span> <span class="o">:</span> <span class="n">chars</span><span class="p">;</span>
      <span class="n">mode</span> <span class="o">:</span> <span class="n">chars</span><span class="p">;</span>
      <span class="n">stream</span> <span class="o">:</span> <span class="n">FILEs</span><span class="o">)</span>
      <span class="kr">return</span><span class="p"> </span><span class="n">FILEs</span><span class="p">;</span>
  <span class="k">function </span><span class="nf">fseek</span>
     <span class="o">(</span><span class="n">stream</span> <span class="o">:</span> <span class="n">FILEs</span><span class="p">;</span>
      <span class="n">offset</span> <span class="o">:</span> <span class="n">long</span><span class="p">;</span>
      <span class="n">origin</span> <span class="o">:</span> <span class="n">int</span><span class="o">)</span>
      <span class="kr">return</span><span class="p"> </span><span class="n">int</span><span class="p">;</span>
  <span class="k">function </span><span class="nf">ftell</span> <span class="o">(</span><span class="n">stream</span> <span class="o">:</span> <span class="n">FILEs</span><span class="o">)</span> <span class="kr">return</span><span class="p"> </span><span class="n">long</span><span class="p">;</span>
  <span class="k">function </span><span class="nf">fwrite</span>
     <span class="o">(</span><span class="n">buffer</span> <span class="o">:</span> <span class="n">voids</span><span class="p">;</span>
      <span class="n">size</span> <span class="o">:</span> <span class="n">size_t</span><span class="p">;</span>
      <span class="n">count</span> <span class="o">:</span> <span class="n">size_t</span><span class="p">;</span>
      <span class="n">stream</span> <span class="o">:</span> <span class="n">FILEs</span><span class="o">)</span>
      <span class="kr">return</span><span class="p"> </span><span class="n">size_t</span><span class="p">;</span>
  <span class="k">function </span><span class="nf">isatty</span> <span class="o">(</span><span class="n">handle</span> <span class="o">:</span> <span class="n">int</span><span class="o">)</span> <span class="kr">return</span><span class="p"> </span><span class="n">int</span><span class="p">;</span>
  <span class="k">procedure </span><span class="nf">mktemp</span> <span class="o">(</span><span class="n">template</span> <span class="o">:</span> <span class="n">chars</span><span class="o">)</span><span class="p">;</span>
  <span class="c">-- The return value (which is just a pointer to template)</span>
  <span class="c">-- is discarded</span>
  <span class="k">procedure </span><span class="nf">rewind</span> <span class="o">(</span><span class="n">stream</span> <span class="o">:</span> <span class="n">FILEs</span><span class="o">)</span><span class="p">;</span>
  <span class="k">function </span><span class="nf">rmtmp</span> <span class="kr">return</span><span class="p"> </span><span class="n">int</span><span class="p">;</span>
  <span class="k">function </span><span class="nf">setvbuf</span>
     <span class="o">(</span><span class="n">stream</span> <span class="o">:</span> <span class="n">FILEs</span><span class="p">;</span>
      <span class="n">buffer</span> <span class="o">:</span> <span class="n">chars</span><span class="p">;</span>
      <span class="n">mode</span> <span class="o">:</span> <span class="n">int</span><span class="p">;</span>
      <span class="n">size</span> <span class="o">:</span> <span class="n">size_t</span><span class="o">)</span>
      <span class="kr">return</span><span class="p"> </span><span class="n">int</span><span class="p">;</span>

  <span class="k">function </span><span class="nf">tmpfile</span> <span class="kr">return</span><span class="p"> </span><span class="n">FILEs</span><span class="p">;</span>
  <span class="k">function </span><span class="nf">ungetc</span> <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">int</span><span class="p">;</span> <span class="n">stream</span> <span class="o">:</span> <span class="n">FILEs</span><span class="o">)</span> <span class="kr">return</span><span class="p"> </span><span class="n">int</span><span class="p">;</span>
  <span class="k">function </span><span class="nf">unlink</span> <span class="o">(</span><span class="n">filename</span> <span class="o">:</span> <span class="n">chars</span><span class="o">)</span> <span class="kr">return</span><span class="p"> </span><span class="n">int</span><span class="p">;</span>
  <span class="c">---------------------</span>
  <span class="c">-- Extra functions --</span>
  <span class="c">---------------------</span>
  <span class="c">-- These functions supply slightly thicker bindings than</span>
  <span class="c">-- those above.  They are derived from functions in the</span>
  <span class="c">-- C Run-Time Library, but may do a bit more work than</span>
  <span class="c">-- just directly calling one of the Library functions.</span>
  <span class="k">function </span><span class="nf">is_regular_file</span> <span class="o">(</span><span class="n">handle</span> <span class="o">:</span> <span class="n">int</span><span class="o">)</span> <span class="kr">return</span><span class="p"> </span><span class="n">int</span><span class="p">;</span>
  <span class="c">-- Tests if given handle is for a regular file (result 1)</span>
  <span class="c">-- or for a non-regular file (pipe or device, result 0).</span>
  <span class="c">---------------------------------</span>
  <span class="c">-- Control of Text/Binary Mode --</span>
  <span class="c">---------------------------------</span>
  <span class="c">-- If text_translation_required is true, then the following</span>
  <span class="c">-- functions may be used to dynamically switch a file from</span>
  <span class="c">-- binary to text mode or vice versa.  These functions have</span>
  <span class="c">-- no effect if text_translation_required is false (i.e., in</span>
  <span class="c">-- normal UNIX mode).  Use fileno to get a stream handle.</span>
  <span class="k">procedure </span><span class="nf">set_binary_mode</span> <span class="o">(</span><span class="n">handle</span> <span class="o">:</span> <span class="n">int</span><span class="o">)</span><span class="p">;</span>
  <span class="k">procedure </span><span class="nf">set_text_mode</span> <span class="o">(</span><span class="n">handle</span> <span class="o">:</span> <span class="n">int</span><span class="o">)</span><span class="p">;</span>
  <span class="c">----------------------------</span>
  <span class="c">-- Full Path Name support --</span>
  <span class="c">----------------------------</span>
  <span class="k">procedure </span><span class="nf">full_name</span> <span class="o">(</span><span class="n">nam</span> <span class="o">:</span> <span class="n">chars</span><span class="p">;</span> <span class="n">buffer</span> <span class="o">:</span> <span class="n">chars</span><span class="o">)</span><span class="p">;</span>
  <span class="c">-- Given a NUL terminated string representing a file</span>
  <span class="c">-- name, returns in buffer a NUL terminated string</span>
  <span class="c">-- representing the full path name for the file name.</span>
  <span class="c">-- On systems where it is relevant the   drive is also</span>
  <span class="c">-- part of the full path name.  It is the responsibility</span>
  <span class="c">-- of the caller to pass an actual parameter for buffer</span>
  <span class="c">-- that is big enough for any full path name.  Use</span>
  <span class="c">-- max_path_len given below as the size of buffer.</span>
  <span class="n">max_path_len</span> <span class="o">:</span> <span class="n">integer</span><span class="p">;</span>
  <span class="c">-- Maximum length of an allowable full path name on the</span>
  <span class="c">-- system, including a terminating NUL character.</span>
<span class="k">end </span><span class="nf">Interfaces.C_Streams</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="interfacing-to-c-streams">
<span id="id26"></span><h2><span class="section-number">11.15. </span>Interfacing to C Streams<a class="headerlink" href="#interfacing-to-c-streams" title="Permalink to this headline">¶</a></h2>
<p>The packages in this section permit interfacing Ada files to C Stream
operations.</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">with</span><span class="p"> </span><span class="n">Interfaces.C_Streams</span><span class="p">;</span>
<span class="k">package </span><span class="nf">Ada.Sequential_IO.C_Streams</span> <span class="kr">is</span><span class="p"></span>
   <span class="k">function </span><span class="nf">C_Stream</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">File_Type</span><span class="o">)</span>
      <span class="kr">return</span><span class="p"> </span><span class="n">Interfaces.C_Streams.FILEs</span><span class="p">;</span>
   <span class="k">procedure </span><span class="nf">Open</span>
     <span class="o">(</span><span class="n">File</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="kr">out</span><span class="p"> </span><span class="n">File_Type</span><span class="p">;</span>
      <span class="n">Mode</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="n">File_Mode</span><span class="p">;</span>
      <span class="n">C_Stream</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="n">Interfaces.C_Streams.FILEs</span><span class="p">;</span>
      <span class="n">Form</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="n">String</span> <span class="o">:=</span> <span class="s">&quot;&quot;</span><span class="o">)</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Ada.Sequential_IO.C_Streams</span><span class="p">;</span>

<span class="p"> </span><span class="kr">with</span><span class="nn"> Interfaces.C_Streams;</span>
 <span class="k">package </span><span class="nf">Ada.Direct_IO.C_Streams</span> <span class="kr">is</span><span class="p"></span>
    <span class="k">function </span><span class="nf">C_Stream</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">File_Type</span><span class="o">)</span>
       <span class="kr">return</span><span class="p"> </span><span class="n">Interfaces.C_Streams.FILEs</span><span class="p">;</span>
    <span class="k">procedure </span><span class="nf">Open</span>
      <span class="o">(</span><span class="n">File</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="kr">out</span><span class="p"> </span><span class="n">File_Type</span><span class="p">;</span>
       <span class="n">Mode</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="n">File_Mode</span><span class="p">;</span>
       <span class="n">C_Stream</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="n">Interfaces.C_Streams.FILEs</span><span class="p">;</span>
       <span class="n">Form</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="n">String</span> <span class="o">:=</span> <span class="s">&quot;&quot;</span><span class="o">)</span><span class="p">;</span>
 <span class="k">end </span><span class="nf">Ada.Direct_IO.C_Streams</span><span class="p">;</span>

<span class="p"> </span><span class="kr">with</span><span class="nn"> Interfaces.C_Streams;</span>
 <span class="k">package </span><span class="nf">Ada.Text_IO.C_Streams</span> <span class="kr">is</span><span class="p"></span>
    <span class="k">function </span><span class="nf">C_Stream</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">File_Type</span><span class="o">)</span>
       <span class="kr">return</span><span class="p"> </span><span class="n">Interfaces.C_Streams.FILEs</span><span class="p">;</span>
    <span class="k">procedure </span><span class="nf">Open</span>
      <span class="o">(</span><span class="n">File</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="kr">out</span><span class="p"> </span><span class="n">File_Type</span><span class="p">;</span>
       <span class="n">Mode</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="n">File_Mode</span><span class="p">;</span>
       <span class="n">C_Stream</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="n">Interfaces.C_Streams.FILEs</span><span class="p">;</span>
       <span class="n">Form</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="n">String</span> <span class="o">:=</span> <span class="s">&quot;&quot;</span><span class="o">)</span><span class="p">;</span>
 <span class="k">end </span><span class="nf">Ada.Text_IO.C_Streams</span><span class="p">;</span>

<span class="p"> </span><span class="kr">with</span><span class="nn"> Interfaces.C_Streams;</span>
 <span class="k">package </span><span class="nf">Ada.Wide_Text_IO.C_Streams</span> <span class="kr">is</span><span class="p"></span>
    <span class="k">function </span><span class="nf">C_Stream</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">File_Type</span><span class="o">)</span>
       <span class="kr">return</span><span class="p"> </span><span class="n">Interfaces.C_Streams.FILEs</span><span class="p">;</span>
    <span class="k">procedure </span><span class="nf">Open</span>
      <span class="o">(</span><span class="n">File</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="kr">out</span><span class="p"> </span><span class="n">File_Type</span><span class="p">;</span>
       <span class="n">Mode</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="n">File_Mode</span><span class="p">;</span>
       <span class="n">C_Stream</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="n">Interfaces.C_Streams.FILEs</span><span class="p">;</span>
       <span class="n">Form</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="n">String</span> <span class="o">:=</span> <span class="s">&quot;&quot;</span><span class="o">)</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Ada.Wide_Text_IO.C_Streams</span><span class="p">;</span>

<span class="p"> </span><span class="kr">with</span><span class="nn"> Interfaces.C_Streams;</span>
 <span class="k">package </span><span class="nf">Ada.Wide_Wide_Text_IO.C_Streams</span> <span class="kr">is</span><span class="p"></span>
    <span class="k">function </span><span class="nf">C_Stream</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">File_Type</span><span class="o">)</span>
       <span class="kr">return</span><span class="p"> </span><span class="n">Interfaces.C_Streams.FILEs</span><span class="p">;</span>
    <span class="k">procedure </span><span class="nf">Open</span>
      <span class="o">(</span><span class="n">File</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="kr">out</span><span class="p"> </span><span class="n">File_Type</span><span class="p">;</span>
       <span class="n">Mode</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="n">File_Mode</span><span class="p">;</span>
       <span class="n">C_Stream</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="n">Interfaces.C_Streams.FILEs</span><span class="p">;</span>
       <span class="n">Form</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="n">String</span> <span class="o">:=</span> <span class="s">&quot;&quot;</span><span class="o">)</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Ada.Wide_Wide_Text_IO.C_Streams</span><span class="p">;</span>

<span class="kr">with</span><span class="nn"> Interfaces.C_Streams;</span>
<span class="k">package </span><span class="nf">Ada.Stream_IO.C_Streams</span> <span class="kr">is</span><span class="p"></span>
   <span class="k">function </span><span class="nf">C_Stream</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">File_Type</span><span class="o">)</span>
      <span class="kr">return</span><span class="p"> </span><span class="n">Interfaces.C_Streams.FILEs</span><span class="p">;</span>
   <span class="k">procedure </span><span class="nf">Open</span>
     <span class="o">(</span><span class="n">File</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="kr">out</span><span class="p"> </span><span class="n">File_Type</span><span class="p">;</span>
      <span class="n">Mode</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="n">File_Mode</span><span class="p">;</span>
      <span class="n">C_Stream</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="n">Interfaces.C_Streams.FILEs</span><span class="p">;</span>
      <span class="n">Form</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="n">String</span> <span class="o">:=</span> <span class="s">&quot;&quot;</span><span class="o">)</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Ada.Stream_IO.C_Streams</span><span class="p">;</span>
</pre></div>
</div>
<p>In each of these six packages, the <code class="docutils literal notranslate"><span class="pre">C_Stream</span></code> function obtains the
<code class="docutils literal notranslate"><span class="pre">FILE</span></code> pointer from a currently opened Ada file.  It is then
possible to use the <code class="docutils literal notranslate"><span class="pre">Interfaces.C_Streams</span></code> package to operate on
this stream, or the stream can be passed to a C program which can
operate on it directly.  Of course the program is responsible for
ensuring that only appropriate sequences of operations are executed.</p>
<p>One particular use of relevance to an Ada program is that the
<code class="docutils literal notranslate"><span class="pre">setvbuf</span></code> function can be used to control the buffering of the
stream used by an Ada file.  In the absence of such a call the standard
default buffering is used.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">Open</span></code> procedures in these packages open a file giving an
existing C Stream instead of a file name.  Typically this stream is
imported from a C program, allowing an Ada file to operate on an
existing C file.</p>
</div>
</div>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../gnat_rm.html">
              <img class="logo" src="../_static/adacore_transparent.png" alt="Logo"/>
            </a></p>
  <h3><a href="../gnat_rm.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">11. The Implementation of Standard I/O</a><ul>
<li><a class="reference internal" href="#standard-i-o-packages">11.1. Standard I/O Packages</a></li>
<li><a class="reference internal" href="#form-strings">11.2. FORM Strings</a></li>
<li><a class="reference internal" href="#direct-io">11.3. Direct_IO</a></li>
<li><a class="reference internal" href="#sequential-io">11.4. Sequential_IO</a></li>
<li><a class="reference internal" href="#text-io">11.5. Text_IO</a><ul>
<li><a class="reference internal" href="#stream-pointer-positioning">11.5.1. Stream Pointer Positioning</a></li>
<li><a class="reference internal" href="#reading-and-writing-non-regular-files">11.5.2. Reading and Writing Non-Regular Files</a></li>
<li><a class="reference internal" href="#get-immediate">11.5.3. Get_Immediate</a></li>
<li><a class="reference internal" href="#treating-text-io-files-as-streams">11.5.4. Treating Text_IO Files as Streams</a></li>
<li><a class="reference internal" href="#text-io-extensions">11.5.5. Text_IO Extensions</a></li>
<li><a class="reference internal" href="#text-io-facilities-for-unbounded-strings">11.5.6. Text_IO Facilities for Unbounded Strings</a></li>
</ul>
</li>
<li><a class="reference internal" href="#wide-text-io">11.6. Wide_Text_IO</a><ul>
<li><a class="reference internal" href="#stream-pointer-positioning-1">11.6.1. Stream Pointer Positioning</a></li>
<li><a class="reference internal" href="#reading-and-writing-non-regular-files-1">11.6.2. Reading and Writing Non-Regular Files</a></li>
</ul>
</li>
<li><a class="reference internal" href="#wide-wide-text-io">11.7. Wide_Wide_Text_IO</a><ul>
<li><a class="reference internal" href="#stream-pointer-positioning-2">11.7.1. Stream Pointer Positioning</a></li>
<li><a class="reference internal" href="#reading-and-writing-non-regular-files-2">11.7.2. Reading and Writing Non-Regular Files</a></li>
</ul>
</li>
<li><a class="reference internal" href="#stream-io">11.8. Stream_IO</a></li>
<li><a class="reference internal" href="#text-translation">11.9. Text Translation</a></li>
<li><a class="reference internal" href="#shared-files">11.10. Shared Files</a></li>
<li><a class="reference internal" href="#filenames-encoding">11.11. Filenames encoding</a></li>
<li><a class="reference internal" href="#file-content-encoding">11.12. File content encoding</a></li>
<li><a class="reference internal" href="#open-modes">11.13. Open Modes</a></li>
<li><a class="reference internal" href="#operations-on-c-streams">11.14. Operations on C Streams</a></li>
<li><a class="reference internal" href="#interfacing-to-c-streams">11.15. Interfacing to C Streams</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="standard_library_routines.html"
                        title="previous chapter"><span class="section-number">10. </span>Standard Library Routines</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="the_gnat_library.html"
                        title="next chapter"><span class="section-number">12. </span>The GNAT Library</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/gnat_rm/the_implementation_of_standard_i_o.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="the_gnat_library.html" title="12. The GNAT Library"
             >next</a> |</li>
        <li class="right" >
          <a href="standard_library_routines.html" title="10. Standard Library Routines"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../gnat_rm.html">GNAT Reference Manual 2021 documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><span class="section-number">11. </span>The Implementation of Standard I/O</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2008-2021, Free Software Foundation.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 3.2.1.
    </div>
  </body>
</html>