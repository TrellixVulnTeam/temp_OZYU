
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>3. The GNAT Compilation Model &#8212; GNAT User&#39;s Guide for Native Platforms 2021 documentation</title>
    <link rel="stylesheet" href="../_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="4. Building Executable Programs with GNAT" href="building_executable_programs_with_gnat.html" />
    <link rel="prev" title="2. Getting Started with GNAT" href="getting_started_with_gnat.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="building_executable_programs_with_gnat.html" title="4. Building Executable Programs with GNAT"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="getting_started_with_gnat.html" title="2. Getting Started with GNAT"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../gnat_ugn.html">GNAT User&#39;s Guide for Native Platforms 2021 documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><span class="section-number">3. </span>The GNAT Compilation Model</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="the-gnat-compilation-model">
<span id="id1"></span><h1><span class="section-number">3. </span>The GNAT Compilation Model<a class="headerlink" href="#the-gnat-compilation-model" title="Permalink to this headline">¶</a></h1>
<span class="target" id="index-0"></span><p id="index-1">This chapter describes the compilation model used by GNAT. Although
similar to that used by other languages such as C and C++, this model
is substantially different from the traditional Ada compilation models,
which are based on a centralized program library. The chapter covers
the following material:</p>
<ul class="simple">
<li><p>Topics related to source file makeup and naming</p>
<ul>
<li><p><a class="reference internal" href="#source-representation"><span class="std std-ref">Source Representation</span></a></p></li>
<li><p><a class="reference internal" href="#foreign-language-representation"><span class="std std-ref">Foreign Language Representation</span></a></p></li>
<li><p><a class="reference internal" href="#file-naming-topics-and-utilities"><span class="std std-ref">File Naming Topics and Utilities</span></a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#configuration-pragmas"><span class="std std-ref">Configuration Pragmas</span></a></p></li>
<li><p><a class="reference internal" href="#generating-object-files"><span class="std std-ref">Generating Object Files</span></a></p></li>
<li><p><a class="reference internal" href="#source-dependencies"><span class="std std-ref">Source Dependencies</span></a></p></li>
<li><p><a class="reference internal" href="#the-ada-library-information-files"><span class="std std-ref">The Ada Library Information Files</span></a></p></li>
<li><p><a class="reference internal" href="#binding-an-ada-program"><span class="std std-ref">Binding an Ada Program</span></a></p></li>
<li><p><a class="reference internal" href="#gnat-and-libraries"><span class="std std-ref">GNAT and Libraries</span></a></p></li>
<li><p><a class="reference internal" href="#conditional-compilation"><span class="std std-ref">Conditional Compilation</span></a></p></li>
<li><p><a class="reference internal" href="#mixed-language-programming"><span class="std std-ref">Mixed Language Programming</span></a></p></li>
<li><p><a class="reference internal" href="#gnat-and-other-compilation-models"><span class="std std-ref">GNAT and Other Compilation Models</span></a></p></li>
<li><p><a class="reference internal" href="#using-gnat-files-with-external-tools"><span class="std std-ref">Using GNAT Files with External Tools</span></a></p></li>
</ul>
<div class="section" id="source-representation">
<span id="id2"></span><h2><span class="section-number">3.1. </span>Source Representation<a class="headerlink" href="#source-representation" title="Permalink to this headline">¶</a></h2>
<span class="target" id="index-2"></span><p id="index-3">Ada source programs are represented in standard text files, using
Latin-1 coding. Latin-1 is an 8-bit code that includes the familiar
7-bit ASCII set, plus additional characters used for
representing foreign languages (see <a class="reference internal" href="#foreign-language-representation"><span class="std std-ref">Foreign Language Representation</span></a>
for support of non-USA character sets). The format effector characters
are represented using their standard ASCII encodings, as follows:</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 24%" />
<col style="width: 51%" />
<col style="width: 24%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>Character</p></td>
<td><p>Effect</p></td>
<td><p>Code</p></td>
</tr>
<tr class="row-even"><td><p><kbd class="kbd docutils literal notranslate">VT</kbd></p></td>
<td><p>Vertical tab</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">16#0B#</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><kbd class="kbd docutils literal notranslate">HT</kbd></p></td>
<td><p>Horizontal tab</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">16#09#</span></code></p></td>
</tr>
<tr class="row-even"><td><p><kbd class="kbd docutils literal notranslate">CR</kbd></p></td>
<td><p>Carriage return</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">16#0D#</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><kbd class="kbd docutils literal notranslate">LF</kbd></p></td>
<td><p>Line feed</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">16#0A#</span></code></p></td>
</tr>
<tr class="row-even"><td><p><kbd class="kbd docutils literal notranslate">FF</kbd></p></td>
<td><p>Form feed</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">16#0C#</span></code></p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>Source files are in standard text file format. In addition, GNAT will
recognize a wide variety of stream formats, in which the end of
physical lines is marked by any of the following sequences:
<code class="docutils literal notranslate"><span class="pre">LF</span></code>, <code class="docutils literal notranslate"><span class="pre">CR</span></code>, <code class="docutils literal notranslate"><span class="pre">CR-LF</span></code>, or <code class="docutils literal notranslate"><span class="pre">LF-CR</span></code>. This is useful
in accommodating files that are imported from other operating systems.</p>
<span class="target" id="index-4"></span><p id="index-5">The end of a source file is normally represented by the physical end of
file. However, the control character <code class="docutils literal notranslate"><span class="pre">16#1A#</span></code> (<kbd class="kbd docutils literal notranslate">SUB</kbd>) is also
recognized as signalling the end of the source file. Again, this is
provided for compatibility with other operating systems where this
code is used to represent the end of file.</p>
<p id="index-6">Each file contains a single Ada compilation unit, including any pragmas
associated with the unit. For example, this means you must place a
package declaration (a package <em>spec</em>) and the corresponding body in
separate files. An Ada <em>compilation</em> (which is a sequence of
compilation units) is represented using a sequence of files. Similarly,
you will place each subunit or child unit in a separate file.</p>
</div>
<div class="section" id="foreign-language-representation">
<span id="id3"></span><h2><span class="section-number">3.2. </span>Foreign Language Representation<a class="headerlink" href="#foreign-language-representation" title="Permalink to this headline">¶</a></h2>
<p>GNAT supports the standard character sets defined in Ada as well as
several other non-standard character sets for use in localized versions
of the compiler (<a class="reference internal" href="building_executable_programs_with_gnat.html#character-set-control"><span class="std std-ref">Character Set Control</span></a>).</p>
<div class="section" id="latin-1">
<span id="id4"></span><h3><span class="section-number">3.2.1. </span>Latin-1<a class="headerlink" href="#latin-1" title="Permalink to this headline">¶</a></h3>
<p id="index-7">The basic character set is Latin-1. This character set is defined by ISO
standard 8859, part 1. The lower half (character codes <code class="docutils literal notranslate"><span class="pre">16#00#</span></code>
… <code class="docutils literal notranslate"><span class="pre">16#7F#)</span></code> is identical to standard ASCII coding, but the upper
half is used to represent additional characters. These include extended letters
used by European languages, such as French accents, the vowels with umlauts
used in German, and the extra letter A-ring used in Swedish.</p>
<p id="index-8">For a complete list of Latin-1 codes and their encodings, see the source
file of library unit <code class="docutils literal notranslate"><span class="pre">Ada.Characters.Latin_1</span></code> in file
<code class="file docutils literal notranslate"><span class="pre">a-chlat1.ads</span></code>.
You may use any of these extended characters freely in character or
string literals. In addition, the extended characters that represent
letters can be used in identifiers.</p>
</div>
<div class="section" id="other-8-bit-codes">
<span id="id5"></span><h3><span class="section-number">3.2.2. </span>Other 8-Bit Codes<a class="headerlink" href="#other-8-bit-codes" title="Permalink to this headline">¶</a></h3>
<p>GNAT also supports several other 8-bit coding schemes:</p>
<span class="target" id="index-9"></span><dl class="simple" id="index-10">
<dt><em>ISO 8859-2 (Latin-2)</em></dt><dd><p>Latin-2 letters allowed in identifiers, with uppercase and lowercase
equivalence.</p>
</dd>
</dl>
<span class="target" id="index-11"></span><dl class="simple" id="index-12">
<dt><em>ISO 8859-3 (Latin-3)</em></dt><dd><p>Latin-3 letters allowed in identifiers, with uppercase and lowercase
equivalence.</p>
</dd>
</dl>
<span class="target" id="index-13"></span><dl class="simple" id="index-14">
<dt><em>ISO 8859-4 (Latin-4)</em></dt><dd><p>Latin-4 letters allowed in identifiers, with uppercase and lowercase
equivalence.</p>
</dd>
</dl>
<span class="target" id="index-15"></span><dl class="simple" id="index-16">
<dt><em>ISO 8859-5 (Cyrillic)</em></dt><dd><p>ISO 8859-5 letters (Cyrillic) allowed in identifiers, with uppercase and
lowercase equivalence.</p>
</dd>
</dl>
<span class="target" id="index-17"></span><dl class="simple" id="index-18">
<dt><em>ISO 8859-15 (Latin-9)</em></dt><dd><p>ISO 8859-15 (Latin-9) letters allowed in identifiers, with uppercase and
lowercase equivalence</p>
</dd>
</dl>
<dl class="simple" id="index-19">
<dt><em>IBM PC (code page 437)</em></dt><dd><p>This code page is the normal default for PCs in the U.S. It corresponds
to the original IBM PC character set. This set has some, but not all, of
the extended Latin-1 letters, but these letters do not have the same
encoding as Latin-1. In this mode, these letters are allowed in
identifiers with uppercase and lowercase equivalence.</p>
</dd>
</dl>
<dl class="simple" id="index-20">
<dt><em>IBM PC (code page 850)</em></dt><dd><p>This code page is a modification of 437 extended to include all the
Latin-1 letters, but still not with the usual Latin-1 encoding. In this
mode, all these letters are allowed in identifiers with uppercase and
lowercase equivalence.</p>
</dd>
<dt><em>Full Upper 8-bit</em></dt><dd><p>Any character in the range 80-FF allowed in identifiers, and all are
considered distinct. In other words, there are no uppercase and lowercase
equivalences in this range. This is useful in conjunction with
certain encoding schemes used for some foreign character sets (e.g.,
the typical method of representing Chinese characters on the PC).</p>
</dd>
<dt><em>No Upper-Half</em></dt><dd><p>No upper-half characters in the range 80-FF are allowed in identifiers.
This gives Ada 83 compatibility for identifier names.</p>
</dd>
</dl>
<p>For precise data on the encodings permitted, and the uppercase and lowercase
equivalences that are recognized, see the file <code class="file docutils literal notranslate"><span class="pre">csets.adb</span></code> in
the GNAT compiler sources. You will need to obtain a full source release
of GNAT to obtain this file.</p>
</div>
<div class="section" id="wide-character-encodings">
<span id="id6"></span><h3><span class="section-number">3.2.3. </span>Wide_Character Encodings<a class="headerlink" href="#wide-character-encodings" title="Permalink to this headline">¶</a></h3>
<p>GNAT allows wide character codes to appear in character and string
literals, and also optionally in identifiers, by means of the following
possible encoding schemes:</p>
<dl>
<dt><em>Hex Coding</em></dt><dd><p>In this encoding, a wide character is represented by the following five
character sequence:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ESC</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="n">d</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">a</span></code>, <code class="docutils literal notranslate"><span class="pre">b</span></code>, <code class="docutils literal notranslate"><span class="pre">c</span></code>, <code class="docutils literal notranslate"><span class="pre">d</span></code> are the four hexadecimal
characters (using uppercase letters) of the wide character code. For
example, ESC A345 is used to represent the wide character with code
<code class="docutils literal notranslate"><span class="pre">16#A345#</span></code>.
This scheme is compatible with use of the full Wide_Character set.</p>
</dd>
<dt><em>Upper-Half Coding</em></dt><dd><p id="index-21">The wide character with encoding <code class="docutils literal notranslate"><span class="pre">16#abcd#</span></code> where the upper bit is on
(in other words, ‘a’ is in the range 8-F) is represented as two bytes,
<code class="docutils literal notranslate"><span class="pre">16#ab#</span></code> and <code class="docutils literal notranslate"><span class="pre">16#cd#</span></code>. The second byte cannot be a format control
character, but is not required to be in the upper half. This method can
be also used for shift-JIS or EUC, where the internal coding matches the
external coding.</p>
</dd>
<dt><em>Shift JIS Coding</em></dt><dd><p id="index-22">A wide character is represented by a two-character sequence,
<code class="docutils literal notranslate"><span class="pre">16#ab#</span></code> and
<code class="docutils literal notranslate"><span class="pre">16#cd#</span></code>, with the restrictions described for upper-half encoding as
described above. The internal character code is the corresponding JIS
character according to the standard algorithm for Shift-JIS
conversion. Only characters defined in the JIS code set table can be
used with this encoding method.</p>
</dd>
<dt><em>EUC Coding</em></dt><dd><p id="index-23">A wide character is represented by a two-character sequence
<code class="docutils literal notranslate"><span class="pre">16#ab#</span></code> and
<code class="docutils literal notranslate"><span class="pre">16#cd#</span></code>, with both characters being in the upper half. The internal
character code is the corresponding JIS character according to the EUC
encoding algorithm. Only characters defined in the JIS code set table
can be used with this encoding method.</p>
</dd>
<dt><em>UTF-8 Coding</em></dt><dd><p>A wide character is represented using
UCS Transformation Format 8 (UTF-8) as defined in Annex R of ISO
10646-1/Am.2. Depending on the character value, the representation
is a one, two, or three byte sequence:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">16</span><span class="c1">#0000#-16#007f#: 2#0xxxxxxx#</span>
<span class="mi">16</span><span class="c1">#0080#-16#07ff#: 2#110xxxxx# 2#10xxxxxx#</span>
<span class="mi">16</span><span class="c1">#0800#-16#ffff#: 2#1110xxxx# 2#10xxxxxx# 2#10xxxxxx#</span>
</pre></div>
</div>
<p>where the <code class="docutils literal notranslate"><span class="pre">xxx</span></code> bits correspond to the left-padded bits of the
16-bit character value. Note that all lower half ASCII characters
are represented as ASCII bytes and all upper half characters and
other wide characters are represented as sequences of upper-half
(The full UTF-8 scheme allows for encoding 31-bit characters as
6-byte sequences, and in the following section on wide wide
characters, the use of these sequences is documented).</p>
</dd>
<dt><em>Brackets Coding</em></dt><dd><p>In this encoding, a wide character is represented by the following eight
character sequence:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span> <span class="s2">&quot; a b c d &quot;</span> <span class="p">]</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">a</span></code>, <code class="docutils literal notranslate"><span class="pre">b</span></code>, <code class="docutils literal notranslate"><span class="pre">c</span></code>, <code class="docutils literal notranslate"><span class="pre">d</span></code> are the four hexadecimal
characters (using uppercase letters) of the wide character code. For
example, [‘A345’] is used to represent the wide character with code
<code class="docutils literal notranslate"><span class="pre">16#A345#</span></code>. It is also possible (though not required) to use the
Brackets coding for upper half characters. For example, the code
<code class="docutils literal notranslate"><span class="pre">16#A3#</span></code> can be represented as <code class="docutils literal notranslate"><span class="pre">['A3']</span></code>.</p>
<p>This scheme is compatible with use of the full Wide_Character set,
and is also the method used for wide character encoding in some standard
ACATS (Ada Conformity Assessment Test Suite) test suite distributions.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Some of these coding schemes do not permit the full use of the
Ada character set. For example, neither Shift JIS nor EUC allow the
use of the upper half of the Latin-1 set.</p>
</div>
</div>
<div class="section" id="wide-wide-character-encodings">
<span id="id7"></span><h3><span class="section-number">3.2.4. </span>Wide_Wide_Character Encodings<a class="headerlink" href="#wide-wide-character-encodings" title="Permalink to this headline">¶</a></h3>
<p>GNAT allows wide wide character codes to appear in character and string
literals, and also optionally in identifiers, by means of the following
possible encoding schemes:</p>
<dl>
<dt><em>UTF-8 Coding</em></dt><dd><p>A wide character is represented using
UCS Transformation Format 8 (UTF-8) as defined in Annex R of ISO
10646-1/Am.2. Depending on the character value, the representation
of character codes with values greater than 16#FFFF# is a
is a four, five, or six byte sequence:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">16</span><span class="c1">#01_0000#-16#10_FFFF#:     11110xxx 10xxxxxx 10xxxxxx</span>
                             <span class="mi">10</span><span class="n">xxxxxx</span>
<span class="mi">16</span><span class="c1">#0020_0000#-16#03FF_FFFF#: 111110xx 10xxxxxx 10xxxxxx</span>
                             <span class="mi">10</span><span class="n">xxxxxx</span> <span class="mi">10</span><span class="n">xxxxxx</span>
<span class="mi">16</span><span class="c1">#0400_0000#-16#7FFF_FFFF#: 1111110x 10xxxxxx 10xxxxxx</span>
                             <span class="mi">10</span><span class="n">xxxxxx</span> <span class="mi">10</span><span class="n">xxxxxx</span> <span class="mi">10</span><span class="n">xxxxxx</span>
</pre></div>
</div>
<p>where the <code class="docutils literal notranslate"><span class="pre">xxx</span></code> bits correspond to the left-padded bits of the
32-bit character value.</p>
</dd>
<dt><em>Brackets Coding</em></dt><dd><p>In this encoding, a wide wide character is represented by the following ten or
twelve byte character sequence:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span> <span class="s2">&quot; a b c d e f &quot;</span> <span class="p">]</span>
<span class="p">[</span> <span class="s2">&quot; a b c d e f g h &quot;</span> <span class="p">]</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">a-h</span></code> are the six or eight hexadecimal
characters (using uppercase letters) of the wide wide character code. For
example, [“1F4567”] is used to represent the wide wide character with code
<code class="docutils literal notranslate"><span class="pre">16#001F_4567#</span></code>.</p>
<p>This scheme is compatible with use of the full Wide_Wide_Character set,
and is also the method used for wide wide character encoding in some standard
ACATS (Ada Conformity Assessment Test Suite) test suite distributions.</p>
</dd>
</dl>
</div>
</div>
<div class="section" id="file-naming-topics-and-utilities">
<span id="id8"></span><h2><span class="section-number">3.3. </span>File Naming Topics and Utilities<a class="headerlink" href="#file-naming-topics-and-utilities" title="Permalink to this headline">¶</a></h2>
<p>GNAT has a default file naming scheme and also provides the user with
a high degree of control over how the names and extensions of the
source files correspond to the Ada compilation units that they contain.</p>
<div class="section" id="file-naming-rules">
<span id="id9"></span><h3><span class="section-number">3.3.1. </span>File Naming Rules<a class="headerlink" href="#file-naming-rules" title="Permalink to this headline">¶</a></h3>
<p>The default file name is determined by the name of the unit that the
file contains. The name is formed by taking the full expanded name of
the unit and replacing the separating dots with hyphens and using
lowercase for all letters.</p>
<p>An exception arises if the file name generated by the above rules starts
with one of the characters
<code class="docutils literal notranslate"><span class="pre">a</span></code>, <code class="docutils literal notranslate"><span class="pre">g</span></code>, <code class="docutils literal notranslate"><span class="pre">i</span></code>, or <code class="docutils literal notranslate"><span class="pre">s</span></code>, and the second character is a
minus. In this case, the character tilde is used in place
of the minus. The reason for this special rule is to avoid clashes with
the standard names for child units of the packages System, Ada,
Interfaces, and GNAT, which use the prefixes
<code class="docutils literal notranslate"><span class="pre">s-</span></code>, <code class="docutils literal notranslate"><span class="pre">a-</span></code>, <code class="docutils literal notranslate"><span class="pre">i-</span></code>, and <code class="docutils literal notranslate"><span class="pre">g-</span></code>,
respectively.</p>
<p>The file extension is <code class="file docutils literal notranslate"><span class="pre">.ads</span></code> for a spec and
<code class="file docutils literal notranslate"><span class="pre">.adb</span></code> for a body. The following table shows some
examples of these rules.</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 47%" />
<col style="width: 53%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>Source File</p></td>
<td><p>Ada Compilation Unit</p></td>
</tr>
<tr class="row-even"><td><p><code class="file docutils literal notranslate"><span class="pre">main.ads</span></code></p></td>
<td><p>Main (spec)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="file docutils literal notranslate"><span class="pre">main.adb</span></code></p></td>
<td><p>Main (body)</p></td>
</tr>
<tr class="row-even"><td><p><code class="file docutils literal notranslate"><span class="pre">arith_functions.ads</span></code></p></td>
<td><p>Arith_Functions (package spec)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="file docutils literal notranslate"><span class="pre">arith_functions.adb</span></code></p></td>
<td><p>Arith_Functions (package body)</p></td>
</tr>
<tr class="row-even"><td><p><code class="file docutils literal notranslate"><span class="pre">func-spec.ads</span></code></p></td>
<td><p>Func.Spec (child package spec)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="file docutils literal notranslate"><span class="pre">func-spec.adb</span></code></p></td>
<td><p>Func.Spec (child package body)</p></td>
</tr>
<tr class="row-even"><td><p><code class="file docutils literal notranslate"><span class="pre">main-sub.adb</span></code></p></td>
<td><p>Sub (subunit of Main)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="file docutils literal notranslate"><span class="pre">a~bad.adb</span></code></p></td>
<td><p>A.Bad (child package body)</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>Following these rules can result in excessively long
file names if corresponding
unit names are long (for example, if child units or subunits are
heavily nested). An option is available to shorten such long file names
(called file name ‘krunching’). This may be particularly useful when
programs being developed with GNAT are to be used on operating systems
with limited file name lengths. <a class="reference internal" href="#using-gnatkr"><span class="std std-ref">Using gnatkr</span></a>.</p>
<p>Of course, no file shortening algorithm can guarantee uniqueness over
all possible unit names; if file name krunching is used, it is your
responsibility to ensure no name clashes occur. Alternatively you
can specify the exact file names that you want used, as described
in the next section. Finally, if your Ada programs are migrating from a
compiler with a different naming convention, you can use the gnatchop
utility to produce source files that follow the GNAT naming conventions.
(For details see <a class="reference internal" href="#renaming-files-with-gnatchop"><span class="std std-ref">Renaming Files with gnatchop</span></a>.)</p>
<p>Note: in the case of Windows or Mac OS operating systems, case is not
significant. So for example on Windows if the canonical name is
<code class="file docutils literal notranslate"><span class="pre">main-sub.adb</span></code>, you can use the file name <code class="file docutils literal notranslate"><span class="pre">Main-Sub.adb</span></code> instead.
However, case is significant for other operating systems, so for example,
if you want to use other than canonically cased file names on a Unix system,
you need to follow the procedures described in the next section.</p>
</div>
<div class="section" id="using-other-file-names">
<span id="id10"></span><h3><span class="section-number">3.3.2. </span>Using Other File Names<a class="headerlink" href="#using-other-file-names" title="Permalink to this headline">¶</a></h3>
<p id="index-24">In the previous section, we have described the default rules used by
GNAT to determine the file name in which a given unit resides. It is
often convenient to follow these default rules, and if you follow them,
the compiler knows without being explicitly told where to find all
the files it needs.</p>
<p id="index-25">However, in some cases, particularly when a program is imported from
another Ada compiler environment, it may be more convenient for the
programmer to specify which file names contain which units. GNAT allows
arbitrary file names to be used by means of the Source_File_Name pragma.
The form of this pragma is as shown in the following examples:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma</span><span class="p"> </span><span class="n">Source_File_Name</span> <span class="o">(</span><span class="n">My_Utilities.Stacks</span><span class="p">,</span>
  <span class="n">Spec_File_Name</span> <span class="o">=&gt;</span> <span class="s">&quot;myutilst_a.ada&quot;</span><span class="o">)</span><span class="p">;</span>
<span class="kr">pragma</span><span class="p"> </span><span class="n">Source_File_name</span> <span class="o">(</span><span class="n">My_Utilities.Stacks</span><span class="p">,</span>
  <span class="n">Body_File_Name</span> <span class="o">=&gt;</span> <span class="s">&quot;myutilst.ada&quot;</span><span class="o">)</span><span class="p">;</span>
</pre></div>
</div>
<p>As shown in this example, the first argument for the pragma is the unit
name (in this example a child unit). The second argument has the form
of a named association. The identifier
indicates whether the file name is for a spec or a body;
the file name itself is given by a string literal.</p>
<p>The source file name pragma is a configuration pragma, which means that
normally it will be placed in the <code class="file docutils literal notranslate"><span class="pre">gnat.adc</span></code>
file used to hold configuration
pragmas that apply to a complete compilation environment.
For more details on how the <code class="file docutils literal notranslate"><span class="pre">gnat.adc</span></code> file is created and used
see <a class="reference internal" href="#handling-of-configuration-pragmas"><span class="std std-ref">Handling of Configuration Pragmas</span></a>.</p>
<p id="index-26">GNAT allows completely arbitrary file names to be specified using the
source file name pragma. However, if the file name specified has an
extension other than <code class="file docutils literal notranslate"><span class="pre">.ads</span></code> or <code class="file docutils literal notranslate"><span class="pre">.adb</span></code> it is necessary to use
a special syntax when compiling the file. The name in this case must be
preceded by the special sequence <code class="docutils literal notranslate"><span class="pre">-x</span></code> followed by a space and the name
of the language, here <code class="docutils literal notranslate"><span class="pre">ada</span></code>, as in:</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>$ gcc -c -x ada peculiar_file_name.sim
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">gnatmake</span></code> handles non-standard file names in the usual manner (the
non-standard file name for the main program is simply used as the
argument to gnatmake). Note that if the extension is also non-standard,
then it must be included in the <code class="docutils literal notranslate"><span class="pre">gnatmake</span></code> command, it may not
be omitted.</p>
</div>
<div class="section" id="alternative-file-naming-schemes">
<span id="id11"></span><h3><span class="section-number">3.3.3. </span>Alternative File Naming Schemes<a class="headerlink" href="#alternative-file-naming-schemes" title="Permalink to this headline">¶</a></h3>
<span class="target" id="index-27"></span><p id="index-28">The previous section described the use of the <code class="docutils literal notranslate"><span class="pre">Source_File_Name</span></code>
pragma to allow arbitrary names to be assigned to individual source files.
However, this approach requires one pragma for each file, and especially in
large systems can result in very long <code class="file docutils literal notranslate"><span class="pre">gnat.adc</span></code> files, and also create
a maintenance problem.</p>
<p id="index-29">GNAT also provides a facility for specifying systematic file naming schemes
other than the standard default naming scheme previously described. An
alternative scheme for naming is specified by the use of
<code class="docutils literal notranslate"><span class="pre">Source_File_Name</span></code> pragmas having the following format:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma</span><span class="p"> </span><span class="n">Source_File_Name</span> <span class="o">(</span>
   <span class="n">Spec_File_Name</span>  <span class="o">=&gt;</span> <span class="n">FILE_NAME_PATTERN</span>
 [ <span class="p">,</span> <span class="n">Casing</span>          <span class="o">=&gt;</span> <span class="n">CASING_SPEC</span>]
 [ <span class="p">,</span> <span class="n">Dot_Replacement</span> <span class="o">=&gt;</span> <span class="n">STRING_LITERAL</span> ] <span class="o">)</span><span class="p">;</span>

<span class="kr">pragma</span><span class="p"> </span><span class="n">Source_File_Name</span> <span class="o">(</span>
   <span class="n">Body_File_Name</span>  <span class="o">=&gt;</span> <span class="n">FILE_NAME_PATTERN</span>
 [ <span class="p">,</span> <span class="n">Casing</span>          <span class="o">=&gt;</span> <span class="n">CASING_SPEC</span> ]
 [ <span class="p">,</span> <span class="n">Dot_Replacement</span> <span class="o">=&gt;</span> <span class="n">STRING_LITERAL</span> ] <span class="o">)</span> <span class="p">;</span>

<span class="kr">pragma</span><span class="p"> </span><span class="n">Source_File_Name</span> <span class="o">(</span>
   <span class="n">Subunit_File_Name</span>  <span class="o">=&gt;</span> <span class="n">FILE_NAME_PATTERN</span>
 [ <span class="p">,</span> <span class="n">Casing</span>          <span class="o">=&gt;</span> <span class="n">CASING_SPEC</span> ]
 [ <span class="p">,</span> <span class="n">Dot_Replacement</span> <span class="o">=&gt;</span> <span class="n">STRING_LITERAL</span> ] <span class="o">)</span> <span class="p">;</span>

<span class="n">FILE_NAME_PATTERN</span> <span class="o">::=</span> <span class="n">STRING_LITERAL</span>
<span class="n">CASING_SPEC</span> <span class="o">::=</span> <span class="n">Lowercase</span> <span class="o">|</span> <span class="n">Uppercase</span> <span class="o">|</span> <span class="n">Mixedcase</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">FILE_NAME_PATTERN</span></code> string shows how the file name is constructed.
It contains a single asterisk character, and the unit name is substituted
systematically for this asterisk. The optional parameter
<code class="docutils literal notranslate"><span class="pre">Casing</span></code> indicates
whether the unit name is to be all upper-case letters, all lower-case letters,
or mixed-case. If no
<code class="docutils literal notranslate"><span class="pre">Casing</span></code> parameter is used, then the default is all
lower-case.</p>
<p>The optional <code class="docutils literal notranslate"><span class="pre">Dot_Replacement</span></code> string is used to replace any periods
that occur in subunit or child unit names. If no <code class="docutils literal notranslate"><span class="pre">Dot_Replacement</span></code>
argument is used then separating dots appear unchanged in the resulting
file name.
Although the above syntax indicates that the
<code class="docutils literal notranslate"><span class="pre">Casing</span></code> argument must appear
before the <code class="docutils literal notranslate"><span class="pre">Dot_Replacement</span></code> argument, but it
is also permissible to write these arguments in the opposite order.</p>
<p>As indicated, it is possible to specify different naming schemes for
bodies, specs, and subunits. Quite often the rule for subunits is the
same as the rule for bodies, in which case, there is no need to give
a separate <code class="docutils literal notranslate"><span class="pre">Subunit_File_Name</span></code> rule, and in this case the
<code class="docutils literal notranslate"><span class="pre">Body_File_name</span></code> rule is used for subunits as well.</p>
<p>The separate rule for subunits can also be used to implement the rather
unusual case of a compilation environment (e.g., a single directory) which
contains a subunit and a child unit with the same unit name. Although
both units cannot appear in the same partition, the Ada Reference Manual
allows (but does not require) the possibility of the two units coexisting
in the same environment.</p>
<p>The file name translation works in the following steps:</p>
<ul class="simple">
<li><p>If there is a specific <code class="docutils literal notranslate"><span class="pre">Source_File_Name</span></code> pragma for the given unit,
then this is always used, and any general pattern rules are ignored.</p></li>
<li><p>If there is a pattern type <code class="docutils literal notranslate"><span class="pre">Source_File_Name</span></code> pragma that applies to
the unit, then the resulting file name will be used if the file exists. If
more than one pattern matches, the latest one will be tried first, and the
first attempt resulting in a reference to a file that exists will be used.</p></li>
<li><p>If no pattern type <code class="docutils literal notranslate"><span class="pre">Source_File_Name</span></code> pragma that applies to the unit
for which the corresponding file exists, then the standard GNAT default
naming rules are used.</p></li>
</ul>
<p>As an example of the use of this mechanism, consider a commonly used scheme
in which file names are all lower case, with separating periods copied
unchanged to the resulting file name, and specs end with <code class="file docutils literal notranslate"><span class="pre">.1.ada</span></code>, and
bodies end with <code class="file docutils literal notranslate"><span class="pre">.2.ada</span></code>. GNAT will follow this scheme if the following
two pragmas appear:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma</span><span class="p"> </span><span class="n">Source_File_Name</span>
  <span class="o">(</span><span class="n">Spec_File_Name</span> <span class="o">=&gt;</span> <span class="s">&quot;.1.ada&quot;</span><span class="o">)</span><span class="p">;</span>
<span class="kr">pragma</span><span class="p"> </span><span class="n">Source_File_Name</span>
  <span class="o">(</span><span class="n">Body_File_Name</span> <span class="o">=&gt;</span> <span class="s">&quot;.2.ada&quot;</span><span class="o">)</span><span class="p">;</span>
</pre></div>
</div>
<p>The default GNAT scheme is actually implemented by providing the following
default pragmas internally:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma</span><span class="p"> </span><span class="n">Source_File_Name</span>
  <span class="o">(</span><span class="n">Spec_File_Name</span> <span class="o">=&gt;</span> <span class="s">&quot;.ads&quot;</span><span class="p">,</span> <span class="n">Dot_Replacement</span> <span class="o">=&gt;</span> <span class="s">&quot;-&quot;</span><span class="o">)</span><span class="p">;</span>
<span class="kr">pragma</span><span class="p"> </span><span class="n">Source_File_Name</span>
  <span class="o">(</span><span class="n">Body_File_Name</span> <span class="o">=&gt;</span> <span class="s">&quot;.adb&quot;</span><span class="p">,</span> <span class="n">Dot_Replacement</span> <span class="o">=&gt;</span> <span class="s">&quot;-&quot;</span><span class="o">)</span><span class="p">;</span>
</pre></div>
</div>
<p>Our final example implements a scheme typically used with one of the
Ada 83 compilers, where the separator character for subunits was ‘__’
(two underscores), specs were identified by adding <code class="file docutils literal notranslate"><span class="pre">_.ADA</span></code>, bodies
by adding <code class="file docutils literal notranslate"><span class="pre">.ADA</span></code>, and subunits by
adding <code class="file docutils literal notranslate"><span class="pre">.SEP</span></code>. All file names were
upper case. Child units were not present of course since this was an
Ada 83 compiler, but it seems reasonable to extend this scheme to use
the same double underscore separator for child units.</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma</span><span class="p"> </span><span class="n">Source_File_Name</span>
  <span class="o">(</span><span class="n">Spec_File_Name</span> <span class="o">=&gt;</span> <span class="s">&quot;_.ADA&quot;</span><span class="p">,</span>
   <span class="n">Dot_Replacement</span> <span class="o">=&gt;</span> <span class="s">&quot;__&quot;</span><span class="p">,</span>
   <span class="n">Casing</span> <span class="o">=</span> <span class="n">Uppercase</span><span class="o">)</span><span class="p">;</span>
<span class="kr">pragma</span><span class="p"> </span><span class="n">Source_File_Name</span>
  <span class="o">(</span><span class="n">Body_File_Name</span> <span class="o">=&gt;</span> <span class="s">&quot;.ADA&quot;</span><span class="p">,</span>
   <span class="n">Dot_Replacement</span> <span class="o">=&gt;</span> <span class="s">&quot;__&quot;</span><span class="p">,</span>
   <span class="n">Casing</span> <span class="o">=</span> <span class="n">Uppercase</span><span class="o">)</span><span class="p">;</span>
<span class="kr">pragma</span><span class="p"> </span><span class="n">Source_File_Name</span>
  <span class="o">(</span><span class="n">Subunit_File_Name</span> <span class="o">=&gt;</span> <span class="s">&quot;.SEP&quot;</span><span class="p">,</span>
   <span class="n">Dot_Replacement</span> <span class="o">=&gt;</span> <span class="s">&quot;__&quot;</span><span class="p">,</span>
   <span class="n">Casing</span> <span class="o">=</span> <span class="n">Uppercase</span><span class="o">)</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="handling-arbitrary-file-naming-conventions-with-gnatname">
<span id="index-30"></span><span id="id12"></span><h3><span class="section-number">3.3.4. </span>Handling Arbitrary File Naming Conventions with <code class="docutils literal notranslate"><span class="pre">gnatname</span></code><a class="headerlink" href="#handling-arbitrary-file-naming-conventions-with-gnatname" title="Permalink to this headline">¶</a></h3>
<div class="section" id="arbitrary-file-naming-conventions">
<span id="index-31"></span><span id="id13"></span><h4><span class="section-number">3.3.4.1. </span>Arbitrary File Naming Conventions<a class="headerlink" href="#arbitrary-file-naming-conventions" title="Permalink to this headline">¶</a></h4>
<p>The GNAT compiler must be able to know the source file name of a compilation
unit.  When using the standard GNAT default file naming conventions
(<code class="docutils literal notranslate"><span class="pre">.ads</span></code> for specs, <code class="docutils literal notranslate"><span class="pre">.adb</span></code> for bodies), the GNAT compiler
does not need additional information.</p>
<p>When the source file names do not follow the standard GNAT default file naming
conventions, the GNAT compiler must be given additional information through
a configuration pragmas file (<a class="reference internal" href="#configuration-pragmas"><span class="std std-ref">Configuration Pragmas</span></a>)
or a project file.
When the non-standard file naming conventions are well-defined,
a small number of pragmas <code class="docutils literal notranslate"><span class="pre">Source_File_Name</span></code> specifying a naming pattern
(<a class="reference internal" href="#alternative-file-naming-schemes"><span class="std std-ref">Alternative File Naming Schemes</span></a>) may be sufficient. However,
if the file naming conventions are irregular or arbitrary, a number
of pragma <code class="docutils literal notranslate"><span class="pre">Source_File_Name</span></code> for individual compilation units
must be defined.
To help maintain the correspondence between compilation unit names and
source file names within the compiler,
GNAT provides a tool <code class="docutils literal notranslate"><span class="pre">gnatname</span></code> to generate the required pragmas for a
set of files.</p>
</div>
<div class="section" id="running-gnatname">
<span id="id14"></span><h4><span class="section-number">3.3.4.2. </span>Running <code class="docutils literal notranslate"><span class="pre">gnatname</span></code><a class="headerlink" href="#running-gnatname" title="Permalink to this headline">¶</a></h4>
<p>The usual form of the <code class="docutils literal notranslate"><span class="pre">gnatname</span></code> command is:</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>$ gnatname <span class="o">[</span> switches <span class="o">]</span>  naming_pattern  <span class="o">[</span> naming_patterns <span class="o">]</span>
    <span class="o">[</span>--and <span class="o">[</span> switches <span class="o">]</span>  naming_pattern  <span class="o">[</span> naming_patterns <span class="o">]]</span>
</pre></div>
</div>
<p>All of the arguments are optional. If invoked without any argument,
<code class="docutils literal notranslate"><span class="pre">gnatname</span></code> will display its usage.</p>
<p>When used with at least one naming pattern, <code class="docutils literal notranslate"><span class="pre">gnatname</span></code> will attempt to
find all the compilation units in files that follow at least one of the
naming patterns. To find these compilation units,
<code class="docutils literal notranslate"><span class="pre">gnatname</span></code> will use the GNAT compiler in syntax-check-only mode on all
regular files.</p>
<p>One or several Naming Patterns may be given as arguments to <code class="docutils literal notranslate"><span class="pre">gnatname</span></code>.
Each Naming Pattern is enclosed between double quotes (or single
quotes on Windows).
A Naming Pattern is a regular expression similar to the wildcard patterns
used in file names by the Unix shells or the DOS prompt.</p>
<p><code class="docutils literal notranslate"><span class="pre">gnatname</span></code> may be called with several sections of directories/patterns.
Sections are separated by the switch <code class="switch docutils literal notranslate"><span class="pre">--and</span></code>. In each section, there must be
at least one pattern. If no directory is specified in a section, the current
directory (or the project directory if <code class="switch docutils literal notranslate"><span class="pre">-P</span></code> is used) is implied.
The options other that the directory switches and the patterns apply globally
even if they are in different sections.</p>
<p>Examples of Naming Patterns are:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="s2">&quot;*.[12].ada&quot;</span>
<span class="s2">&quot;*.ad[sb]*&quot;</span>
<span class="s2">&quot;body_*&quot;</span>    <span class="s2">&quot;spec_*&quot;</span>
</pre></div>
</div>
<p>For a more complete description of the syntax of Naming Patterns,
see the second kind of regular expressions described in <code class="file docutils literal notranslate"><span class="pre">g-regexp.ads</span></code>
(the ‘Glob’ regular expressions).</p>
<p>When invoked without the switch <code class="switch docutils literal notranslate"><span class="pre">-P</span></code>, <code class="docutils literal notranslate"><span class="pre">gnatname</span></code> will create a
configuration pragmas file <code class="file docutils literal notranslate"><span class="pre">gnat.adc</span></code> in the current working directory,
with pragmas <code class="docutils literal notranslate"><span class="pre">Source_File_Name</span></code> for each file that contains a valid Ada
unit.</p>
</div>
<div class="section" id="switches-for-gnatname">
<span id="id15"></span><h4><span class="section-number">3.3.4.3. </span>Switches for <code class="docutils literal notranslate"><span class="pre">gnatname</span></code><a class="headerlink" href="#switches-for-gnatname" title="Permalink to this headline">¶</a></h4>
<p>Switches for <code class="docutils literal notranslate"><span class="pre">gnatname</span></code> must precede any specified Naming Pattern.</p>
<p>You may specify any of the following switches to <code class="docutils literal notranslate"><span class="pre">gnatname</span></code>:</p>
<dl class="simple" id="index-32">
<dt><code class="switch docutils literal notranslate"><span class="pre">--version</span></code></dt><dd><p>Display Copyright and version, then exit disregarding all other options.</p>
</dd>
</dl>
<dl class="simple" id="index-33">
<dt><code class="switch docutils literal notranslate"><span class="pre">--help</span></code></dt><dd><p>If <code class="switch docutils literal notranslate"><span class="pre">--version</span></code> was not used, display usage, then exit disregarding
all other options.</p>
</dd>
<dt><code class="switch docutils literal notranslate"><span class="pre">--subdirs=</span><em><span class="pre">dir</span></em></code></dt><dd><p>Real object, library or exec directories are subdirectories &lt;dir&gt; of the
specified ones.</p>
</dd>
<dt><code class="switch docutils literal notranslate"><span class="pre">--no-backup</span></code></dt><dd><p>Do not create a backup copy of an existing project file.</p>
</dd>
<dt><code class="switch docutils literal notranslate"><span class="pre">--and</span></code></dt><dd><p>Start another section of directories/patterns.</p>
</dd>
</dl>
<dl class="simple" id="index-34">
<dt><code class="switch docutils literal notranslate"><span class="pre">-c</span><em><span class="pre">filename</span></em></code></dt><dd><p>Create a configuration pragmas file <code class="file docutils literal notranslate"><span class="pre">filename</span></code> (instead of the default
<code class="file docutils literal notranslate"><span class="pre">gnat.adc</span></code>).
There may be zero, one or more space between <code class="switch docutils literal notranslate"><span class="pre">-c</span></code> and
<code class="file docutils literal notranslate"><span class="pre">filename</span></code>.
<code class="file docutils literal notranslate"><span class="pre">filename</span></code> may include directory information. <code class="file docutils literal notranslate"><span class="pre">filename</span></code> must be
writable. There may be only one switch <code class="switch docutils literal notranslate"><span class="pre">-c</span></code>.
When a switch <code class="switch docutils literal notranslate"><span class="pre">-c</span></code> is
specified, no switch <code class="switch docutils literal notranslate"><span class="pre">-P</span></code> may be specified (see below).</p>
</dd>
</dl>
<dl class="simple" id="index-35">
<dt><code class="switch docutils literal notranslate"><span class="pre">-d</span><em><span class="pre">dir</span></em></code></dt><dd><p>Look for source files in directory <code class="file docutils literal notranslate"><span class="pre">dir</span></code>. There may be zero, one or more
spaces between <code class="switch docutils literal notranslate"><span class="pre">-d</span></code> and <code class="file docutils literal notranslate"><span class="pre">dir</span></code>.
<code class="file docutils literal notranslate"><span class="pre">dir</span></code> may end with <code class="docutils literal notranslate"><span class="pre">/**</span></code>, that is it may be of the form
<code class="docutils literal notranslate"><span class="pre">root_dir/**</span></code>. In this case, the directory <code class="docutils literal notranslate"><span class="pre">root_dir</span></code> and all of its
subdirectories, recursively, have to be searched for sources.
When a switch <code class="switch docutils literal notranslate"><span class="pre">-d</span></code>
is specified, the current working directory will not be searched for source
files, unless it is explicitly specified with a <code class="switch docutils literal notranslate"><span class="pre">-d</span></code>
or <code class="switch docutils literal notranslate"><span class="pre">-D</span></code> switch.
Several switches <code class="switch docutils literal notranslate"><span class="pre">-d</span></code> may be specified.
If <code class="file docutils literal notranslate"><span class="pre">dir</span></code> is a relative path, it is relative to the directory of
the configuration pragmas file specified with switch
<code class="switch docutils literal notranslate"><span class="pre">-c</span></code>,
or to the directory of the project file specified with switch
<code class="switch docutils literal notranslate"><span class="pre">-P</span></code> or,
if neither switch <code class="switch docutils literal notranslate"><span class="pre">-c</span></code>
nor switch <code class="switch docutils literal notranslate"><span class="pre">-P</span></code> are specified, it is relative to the
current working directory. The directory
specified with switch <code class="switch docutils literal notranslate"><span class="pre">-d</span></code> must exist and be readable.</p>
</dd>
</dl>
<dl id="index-36">
<dt><code class="switch docutils literal notranslate"><span class="pre">-D</span><em><span class="pre">filename</span></em></code></dt><dd><p>Look for source files in all directories listed in text file <code class="file docutils literal notranslate"><span class="pre">filename</span></code>.
There may be zero, one or more spaces between <code class="switch docutils literal notranslate"><span class="pre">-D</span></code>
and <code class="file docutils literal notranslate"><span class="pre">filename</span></code>.
<code class="file docutils literal notranslate"><span class="pre">filename</span></code> must be an existing, readable text file.
Each nonempty line in <code class="file docutils literal notranslate"><span class="pre">filename</span></code> must be a directory.
Specifying switch <code class="switch docutils literal notranslate"><span class="pre">-D</span></code> is equivalent to specifying as many
switches <code class="switch docutils literal notranslate"><span class="pre">-d</span></code> as there are nonempty lines in
<code class="file docutils literal notranslate"><span class="pre">file</span></code>.</p>
</dd>
<dt><code class="switch docutils literal notranslate"><span class="pre">-eL</span></code></dt><dd><p>Follow symbolic links when processing project files.</p>
</dd>
<dt id="index-37"><code class="switch docutils literal notranslate"><span class="pre">-f</span><em><span class="pre">pattern</span></em></code></dt><dd><p>Foreign patterns. Using this switch, it is possible to add sources of languages
other than Ada to the list of sources of a project file.
It is only useful if a -P switch is used.
For example,</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>gnatname -Pprj -f<span class="s2">&quot;*.c&quot;</span> <span class="s2">&quot;*.ada&quot;</span>
</pre></div>
</div>
<p>will look for Ada units in all files with the <code class="file docutils literal notranslate"><span class="pre">.ada</span></code> extension,
and will add to the list of file for project <code class="file docutils literal notranslate"><span class="pre">prj.gpr</span></code> the C files
with extension <code class="file docutils literal notranslate"><span class="pre">.c</span></code>.</p>
</dd>
<dt id="index-38"><code class="switch docutils literal notranslate"><span class="pre">-h</span></code></dt><dd><p>Output usage (help) information. The output is written to <code class="file docutils literal notranslate"><span class="pre">stdout</span></code>.</p>
</dd>
<dt id="index-39"><code class="switch docutils literal notranslate"><span class="pre">-P</span><em><span class="pre">proj</span></em></code></dt><dd><p>Create or update project file <code class="file docutils literal notranslate"><span class="pre">proj</span></code>. There may be zero, one or more space
between <code class="switch docutils literal notranslate"><span class="pre">-P</span></code> and <code class="file docutils literal notranslate"><span class="pre">proj</span></code>. <code class="file docutils literal notranslate"><span class="pre">proj</span></code> may include directory
information. <code class="file docutils literal notranslate"><span class="pre">proj</span></code> must be writable.
There may be only one switch <code class="switch docutils literal notranslate"><span class="pre">-P</span></code>.
When a switch <code class="switch docutils literal notranslate"><span class="pre">-P</span></code> is specified,
no switch <code class="switch docutils literal notranslate"><span class="pre">-c</span></code> may be specified.
On all platforms, except on VMS, when <code class="docutils literal notranslate"><span class="pre">gnatname</span></code> is invoked for an
existing project file &lt;proj&gt;.gpr, a backup copy of the project file is created
in the project directory with file name &lt;proj&gt;.gpr.saved_x. ‘x’ is the first
non negative number that makes this backup copy a new file.</p>
</dd>
<dt id="index-40"><code class="switch docutils literal notranslate"><span class="pre">-v</span></code></dt><dd><p>Verbose mode. Output detailed explanation of behavior to <code class="file docutils literal notranslate"><span class="pre">stdout</span></code>.
This includes name of the file written, the name of the directories to search
and, for each file in those directories whose name matches at least one of
the Naming Patterns, an indication of whether the file contains a unit,
and if so the name of the unit.</p>
</dd>
</dl>
<dl id="index-41">
<dt><code class="switch docutils literal notranslate"><span class="pre">-v</span> <span class="pre">-v</span></code></dt><dd><p>Very Verbose mode. In addition to the output produced in verbose mode,
for each file in the searched directories whose name matches none of
the Naming Patterns, an indication is given that there is no match.</p>
</dd>
<dt id="index-42"><code class="switch docutils literal notranslate"><span class="pre">-x</span><em><span class="pre">pattern</span></em></code></dt><dd><p>Excluded patterns. Using this switch, it is possible to exclude some files
that would match the name patterns. For example,</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>gnatname -x <span class="s2">&quot;*_nt.ada&quot;</span> <span class="s2">&quot;*.ada&quot;</span>
</pre></div>
</div>
<p>will look for Ada units in all files with the <code class="file docutils literal notranslate"><span class="pre">.ada</span></code> extension,
except those whose names end with <code class="file docutils literal notranslate"><span class="pre">_nt.ada</span></code>.</p>
</dd>
</dl>
</div>
<div class="section" id="examples-of-gnatname-usage">
<span id="id16"></span><h4><span class="section-number">3.3.4.4. </span>Examples of <code class="docutils literal notranslate"><span class="pre">gnatname</span></code> Usage<a class="headerlink" href="#examples-of-gnatname-usage" title="Permalink to this headline">¶</a></h4>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>$ gnatname -c /home/me/names.adc -d sources <span class="s2">&quot;[a-z]*.ada*&quot;</span>
</pre></div>
</div>
<p>In this example, the directory <code class="file docutils literal notranslate"><span class="pre">/home/me</span></code> must already exist
and be writable. In addition, the directory
<code class="file docutils literal notranslate"><span class="pre">/home/me/sources</span></code> (specified by
<code class="switch docutils literal notranslate"><span class="pre">-d</span> <span class="pre">sources</span></code>) must exist and be readable.</p>
<p>Note the optional spaces after <code class="switch docutils literal notranslate"><span class="pre">-c</span></code> and <code class="switch docutils literal notranslate"><span class="pre">-d</span></code>.</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>$ gnatname -P/home/me/proj -x <span class="s2">&quot;*_nt_body.ada&quot;</span>
-dsources -dsources/plus -Dcommon_dirs.txt <span class="s2">&quot;body_*&quot;</span> <span class="s2">&quot;spec_*&quot;</span>
</pre></div>
</div>
<p>Note that several switches <code class="switch docutils literal notranslate"><span class="pre">-d</span></code> may be used,
even in conjunction with one or several switches
<code class="switch docutils literal notranslate"><span class="pre">-D</span></code>. Several Naming Patterns and one excluded pattern
are used in this example.</p>
</div>
</div>
<div class="section" id="file-name-krunching-with-gnatkr">
<span id="id17"></span><h3><span class="section-number">3.3.5. </span>File Name Krunching with <code class="docutils literal notranslate"><span class="pre">gnatkr</span></code><a class="headerlink" href="#file-name-krunching-with-gnatkr" title="Permalink to this headline">¶</a></h3>
<p id="index-43">This section discusses the method used by the compiler to shorten
the default file names chosen for Ada units so that they do not
exceed the maximum length permitted. It also describes the
<code class="docutils literal notranslate"><span class="pre">gnatkr</span></code> utility that can be used to determine the result of
applying this shortening.</p>
<div class="section" id="about-gnatkr">
<span id="id18"></span><h4><span class="section-number">3.3.5.1. </span>About <code class="docutils literal notranslate"><span class="pre">gnatkr</span></code><a class="headerlink" href="#about-gnatkr" title="Permalink to this headline">¶</a></h4>
<p>The default file naming rule in GNAT
is that the file name must be derived from
the unit name. The exact default rule is as follows:</p>
<ul>
<li><p>Take the unit name and replace all dots by hyphens.</p></li>
<li><p>If such a replacement occurs in the
second character position of a name, and the first character is
<code class="samp docutils literal notranslate"><span class="pre">a</span></code>, <code class="samp docutils literal notranslate"><span class="pre">g</span></code>, <code class="samp docutils literal notranslate"><span class="pre">s</span></code>, or <code class="samp docutils literal notranslate"><span class="pre">i</span></code>,
then replace the dot by the character
<code class="samp docutils literal notranslate"><span class="pre">~</span></code> (tilde)
instead of a minus.</p>
<p>The reason for this exception is to avoid clashes
with the standard names for children of System, Ada, Interfaces,
and GNAT, which use the prefixes
<code class="samp docutils literal notranslate"><span class="pre">s-</span></code>, <code class="samp docutils literal notranslate"><span class="pre">a-</span></code>, <code class="samp docutils literal notranslate"><span class="pre">i-</span></code>, and <code class="samp docutils literal notranslate"><span class="pre">g-</span></code>,
respectively.</p>
</li>
</ul>
<p>The <code class="switch docutils literal notranslate"><span class="pre">-gnatk</span><em><span class="pre">nn</span></em></code>
switch of the compiler activates a ‘krunching’
circuit that limits file names to nn characters (where nn is a decimal
integer).</p>
<p>The <code class="docutils literal notranslate"><span class="pre">gnatkr</span></code> utility can be used to determine the krunched name for
a given file, when krunched to a specified maximum length.</p>
</div>
<div class="section" id="using-gnatkr">
<span id="id19"></span><h4><span class="section-number">3.3.5.2. </span>Using <code class="docutils literal notranslate"><span class="pre">gnatkr</span></code><a class="headerlink" href="#using-gnatkr" title="Permalink to this headline">¶</a></h4>
<p>The <code class="docutils literal notranslate"><span class="pre">gnatkr</span></code> command has the form:</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>$ gnatkr name <span class="o">[</span> length <span class="o">]</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">name</span></code> is the uncrunched file name, derived from the name of the unit
in the standard manner described in the previous section (i.e., in particular
all dots are replaced by hyphens). The file name may or may not have an
extension (defined as a suffix of the form period followed by arbitrary
characters other than period). If an extension is present then it will
be preserved in the output. For example, when krunching <code class="file docutils literal notranslate"><span class="pre">hellofile.ads</span></code>
to eight characters, the result will be hellofil.ads.</p>
<p>Note: for compatibility with previous versions of <code class="docutils literal notranslate"><span class="pre">gnatkr</span></code> dots may
appear in the name instead of hyphens, but the last dot will always be
taken as the start of an extension. So if <code class="docutils literal notranslate"><span class="pre">gnatkr</span></code> is given an argument
such as <code class="file docutils literal notranslate"><span class="pre">Hello.World.adb</span></code> it will be treated exactly as if the first
period had been a hyphen, and for example krunching to eight characters
gives the result <code class="file docutils literal notranslate"><span class="pre">hellworl.adb</span></code>.</p>
<p>Note that the result is always all lower case.
Characters of the other case are folded as required.</p>
<p><code class="docutils literal notranslate"><span class="pre">length</span></code> represents the length of the krunched name. The default
when no argument is given is 8 characters. A length of zero stands for
unlimited, in other words do not chop except for system files where the
implied crunching length is always eight characters.</p>
<p>The output is the krunched name. The output has an extension only if the
original argument was a file name with an extension.</p>
</div>
<div class="section" id="krunching-method">
<span id="id20"></span><h4><span class="section-number">3.3.5.3. </span>Krunching Method<a class="headerlink" href="#krunching-method" title="Permalink to this headline">¶</a></h4>
<p>The initial file name is determined by the name of the unit that the file
contains. The name is formed by taking the full expanded name of the
unit and replacing the separating dots with hyphens and
using lowercase
for all letters, except that a hyphen in the second character position is
replaced by a tilde if the first character is
<code class="samp docutils literal notranslate"><span class="pre">a</span></code>, <code class="samp docutils literal notranslate"><span class="pre">i</span></code>, <code class="samp docutils literal notranslate"><span class="pre">g</span></code>, or <code class="samp docutils literal notranslate"><span class="pre">s</span></code>.
The extension is <code class="docutils literal notranslate"><span class="pre">.ads</span></code> for a
spec and <code class="docutils literal notranslate"><span class="pre">.adb</span></code> for a body.
Krunching does not affect the extension, but the file name is shortened to
the specified length by following these rules:</p>
<ul>
<li><p>The name is divided into segments separated by hyphens, tildes or
underscores and all hyphens, tildes, and underscores are
eliminated. If this leaves the name short enough, we are done.</p></li>
<li><p>If the name is too long, the longest segment is located (left-most
if there are two of equal length), and shortened by dropping
its last character. This is repeated until the name is short enough.</p>
<p>As an example, consider the krunching of <code class="file docutils literal notranslate"><span class="pre">our-strings-wide_fixed.adb</span></code>
to fit the name into 8 characters as required by some operating systems:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">our</span><span class="o">-</span><span class="n">strings</span><span class="o">-</span><span class="n">wide_fixed</span> <span class="mi">22</span>
<span class="n">our</span> <span class="n">strings</span> <span class="n">wide</span> <span class="n">fixed</span> <span class="mi">19</span>
<span class="n">our</span> <span class="n">string</span>  <span class="n">wide</span> <span class="n">fixed</span> <span class="mi">18</span>
<span class="n">our</span> <span class="n">strin</span>   <span class="n">wide</span> <span class="n">fixed</span> <span class="mi">17</span>
<span class="n">our</span> <span class="n">stri</span>    <span class="n">wide</span> <span class="n">fixed</span> <span class="mi">16</span>
<span class="n">our</span> <span class="n">stri</span>    <span class="n">wide</span> <span class="n">fixe</span>  <span class="mi">15</span>
<span class="n">our</span> <span class="nb">str</span>     <span class="n">wide</span> <span class="n">fixe</span>  <span class="mi">14</span>
<span class="n">our</span> <span class="nb">str</span>     <span class="n">wid</span>  <span class="n">fixe</span>  <span class="mi">13</span>
<span class="n">our</span> <span class="nb">str</span>     <span class="n">wid</span>  <span class="n">fix</span>   <span class="mi">12</span>
<span class="n">ou</span>  <span class="nb">str</span>     <span class="n">wid</span>  <span class="n">fix</span>   <span class="mi">11</span>
<span class="n">ou</span>  <span class="n">st</span>      <span class="n">wid</span>  <span class="n">fix</span>   <span class="mi">10</span>
<span class="n">ou</span>  <span class="n">st</span>      <span class="n">wi</span>   <span class="n">fix</span>   <span class="mi">9</span>
<span class="n">ou</span>  <span class="n">st</span>      <span class="n">wi</span>   <span class="n">fi</span>    <span class="mi">8</span>
<span class="n">Final</span> <span class="n">file</span> <span class="n">name</span><span class="p">:</span> <span class="n">oustwifi</span><span class="o">.</span><span class="n">adb</span>
</pre></div>
</div>
</li>
<li><p>The file names for all predefined units are always krunched to eight
characters. The krunching of these predefined units uses the following
special prefix replacements:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 60%" />
<col style="width: 40%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>Prefix</p></td>
<td><p>Replacement</p></td>
</tr>
<tr class="row-even"><td><p><code class="file docutils literal notranslate"><span class="pre">ada-</span></code></p></td>
<td><p><code class="file docutils literal notranslate"><span class="pre">a-</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="file docutils literal notranslate"><span class="pre">gnat-</span></code></p></td>
<td><p><code class="file docutils literal notranslate"><span class="pre">g-</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="file docutils literal notranslate"><span class="pre">interfac</span> <span class="pre">es-</span></code></p></td>
<td><p><code class="file docutils literal notranslate"><span class="pre">i-</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="file docutils literal notranslate"><span class="pre">system-</span></code></p></td>
<td><p><code class="file docutils literal notranslate"><span class="pre">s-</span></code></p></td>
</tr>
</tbody>
</table>
<p>These system files have a hyphen in the second character position. That
is why normal user files replace such a character with a
tilde, to avoid confusion with system file names.</p>
<p>As an example of this special rule, consider
<code class="file docutils literal notranslate"><span class="pre">ada-strings-wide_fixed.adb</span></code>, which gets krunched as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ada</span><span class="o">-</span><span class="n">strings</span><span class="o">-</span><span class="n">wide_fixed</span> <span class="mi">22</span>
<span class="n">a</span><span class="o">-</span>  <span class="n">strings</span> <span class="n">wide</span> <span class="n">fixed</span> <span class="mi">18</span>
<span class="n">a</span><span class="o">-</span>  <span class="n">string</span>  <span class="n">wide</span> <span class="n">fixed</span> <span class="mi">17</span>
<span class="n">a</span><span class="o">-</span>  <span class="n">strin</span>   <span class="n">wide</span> <span class="n">fixed</span> <span class="mi">16</span>
<span class="n">a</span><span class="o">-</span>  <span class="n">stri</span>    <span class="n">wide</span> <span class="n">fixed</span> <span class="mi">15</span>
<span class="n">a</span><span class="o">-</span>  <span class="n">stri</span>    <span class="n">wide</span> <span class="n">fixe</span>  <span class="mi">14</span>
<span class="n">a</span><span class="o">-</span>  <span class="nb">str</span>     <span class="n">wide</span> <span class="n">fixe</span>  <span class="mi">13</span>
<span class="n">a</span><span class="o">-</span>  <span class="nb">str</span>     <span class="n">wid</span>  <span class="n">fixe</span>  <span class="mi">12</span>
<span class="n">a</span><span class="o">-</span>  <span class="nb">str</span>     <span class="n">wid</span>  <span class="n">fix</span>   <span class="mi">11</span>
<span class="n">a</span><span class="o">-</span>  <span class="n">st</span>      <span class="n">wid</span>  <span class="n">fix</span>   <span class="mi">10</span>
<span class="n">a</span><span class="o">-</span>  <span class="n">st</span>      <span class="n">wi</span>   <span class="n">fix</span>   <span class="mi">9</span>
<span class="n">a</span><span class="o">-</span>  <span class="n">st</span>      <span class="n">wi</span>   <span class="n">fi</span>    <span class="mi">8</span>
<span class="n">Final</span> <span class="n">file</span> <span class="n">name</span><span class="p">:</span> <span class="n">a</span><span class="o">-</span><span class="n">stwifi</span><span class="o">.</span><span class="n">adb</span>
</pre></div>
</div>
</li>
</ul>
<p>Of course no file shortening algorithm can guarantee uniqueness over all
possible unit names, and if file name krunching is used then it is your
responsibility to ensure that no name clashes occur. The utility
program <code class="docutils literal notranslate"><span class="pre">gnatkr</span></code> is supplied for conveniently determining the
krunched name of a file.</p>
</div>
<div class="section" id="examples-of-gnatkr-usage">
<span id="id21"></span><h4><span class="section-number">3.3.5.4. </span>Examples of <code class="docutils literal notranslate"><span class="pre">gnatkr</span></code> Usage<a class="headerlink" href="#examples-of-gnatkr-usage" title="Permalink to this headline">¶</a></h4>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ gnatkr very_long_unit_name.ads      --&gt; velounna.ads
$ gnatkr grandparent-parent-child.ads --&gt; grparchi.ads
$ gnatkr Grandparent.Parent.Child.ads --&gt; grparchi.ads
$ gnatkr grandparent-parent-child     --&gt; grparchi
$ gnatkr very_long_unit_name.ads/count=6 --&gt; vlunna.ads
$ gnatkr very_long_unit_name.ads/count=0 --&gt; very_long_unit_name.ads
</pre></div>
</div>
</div>
</div>
<div class="section" id="renaming-files-with-gnatchop">
<span id="id22"></span><h3><span class="section-number">3.3.6. </span>Renaming Files with <code class="docutils literal notranslate"><span class="pre">gnatchop</span></code><a class="headerlink" href="#renaming-files-with-gnatchop" title="Permalink to this headline">¶</a></h3>
<p id="index-44">This section discusses how to handle files with multiple units by using
the <code class="docutils literal notranslate"><span class="pre">gnatchop</span></code> utility. This utility is also useful in renaming
files to meet the standard GNAT default file naming conventions.</p>
<div class="section" id="handling-files-with-multiple-units">
<span id="id23"></span><h4><span class="section-number">3.3.6.1. </span>Handling Files with Multiple Units<a class="headerlink" href="#handling-files-with-multiple-units" title="Permalink to this headline">¶</a></h4>
<p>The basic compilation model of GNAT requires that a file submitted to the
compiler have only one unit and there be a strict correspondence
between the file name and the unit name.</p>
<p>If you want to keep your files with multiple units,
perhaps to maintain compatibility with some other Ada compilation system,
you can use <code class="docutils literal notranslate"><span class="pre">gnatname</span></code> to generate or update your project files.
Generated or modified project files can be processed by GNAT.</p>
<p>See <a class="reference internal" href="#handling-arbitrary-file-naming-conventions-with-gnatname"><span class="std std-ref">Handling Arbitrary File Naming Conventions with gnatname</span></a>
for more details on how to use <cite>gnatname</cite>.</p>
<p>Alternatively, if you want to permanently restructure a set of ‘foreign’
files so that they match the GNAT rules, and do the remaining development
using the GNAT structure, you can simply use <code class="docutils literal notranslate"><span class="pre">gnatchop</span></code> once, generate the
new set of files and work with them from that point on.</p>
<p>Note that if your file containing multiple units starts with a byte order
mark (BOM) specifying UTF-8 encoding, then the files generated by gnatchop
will each start with a copy of this BOM, meaning that they can be compiled
automatically in UTF-8 mode without needing to specify an explicit encoding.</p>
</div>
<div class="section" id="operating-gnatchop-in-compilation-mode">
<span id="id24"></span><h4><span class="section-number">3.3.6.2. </span>Operating gnatchop in Compilation Mode<a class="headerlink" href="#operating-gnatchop-in-compilation-mode" title="Permalink to this headline">¶</a></h4>
<p>The basic function of <code class="docutils literal notranslate"><span class="pre">gnatchop</span></code> is to take a file with multiple units
and split it into separate files. The boundary between files is reasonably
clear, except for the issue of comments and pragmas. In default mode, the
rule is that any pragmas between units belong to the previous unit, except
that configuration pragmas always belong to the following unit. Any comments
belong to the following unit. These rules
almost always result in the right choice of
the split point without needing to mark it explicitly and most users will
find this default to be what they want. In this default mode it is incorrect to
submit a file containing only configuration pragmas, or one that ends in
configuration pragmas, to <code class="docutils literal notranslate"><span class="pre">gnatchop</span></code>.</p>
<p>However, using a special option to activate ‘compilation mode’,
<code class="docutils literal notranslate"><span class="pre">gnatchop</span></code>
can perform another function, which is to provide exactly the semantics
required by the RM for handling of configuration pragmas in a compilation.
In the absence of configuration pragmas (at the main file level), this
option has no effect, but it causes such configuration pragmas to be handled
in a quite different manner.</p>
<p>First, in compilation mode, if <code class="docutils literal notranslate"><span class="pre">gnatchop</span></code> is given a file that consists of
only configuration pragmas, then this file is appended to the
<code class="file docutils literal notranslate"><span class="pre">gnat.adc</span></code> file in the current directory. This behavior provides
the required behavior described in the RM for the actions to be taken
on submitting such a file to the compiler, namely that these pragmas
should apply to all subsequent compilations in the same compilation
environment. Using GNAT, the current directory, possibly containing a
<code class="file docutils literal notranslate"><span class="pre">gnat.adc</span></code> file is the representation
of a compilation environment. For more information on the
<code class="file docutils literal notranslate"><span class="pre">gnat.adc</span></code> file, see <a class="reference internal" href="#handling-of-configuration-pragmas"><span class="std std-ref">Handling of Configuration Pragmas</span></a>.</p>
<p>Second, in compilation mode, if <code class="docutils literal notranslate"><span class="pre">gnatchop</span></code>
is given a file that starts with
configuration pragmas, and contains one or more units, then these
configuration pragmas are prepended to each of the chopped files. This
behavior provides the required behavior described in the RM for the
actions to be taken on compiling such a file, namely that the pragmas
apply to all units in the compilation, but not to subsequently compiled
units.</p>
<p>Finally, if configuration pragmas appear between units, they are appended
to the previous unit. This results in the previous unit being illegal,
since the compiler does not accept configuration pragmas that follow
a unit. This provides the required RM behavior that forbids configuration
pragmas other than those preceding the first compilation unit of a
compilation.</p>
<p>For most purposes, <code class="docutils literal notranslate"><span class="pre">gnatchop</span></code> will be used in default mode. The
compilation mode described above is used only if you need exactly
accurate behavior with respect to compilations, and you have files
that contain multiple units and configuration pragmas. In this
circumstance the use of <code class="docutils literal notranslate"><span class="pre">gnatchop</span></code> with the compilation mode
switch provides the required behavior, and is for example the mode
in which GNAT processes the ACVC tests.</p>
</div>
<div class="section" id="command-line-for-gnatchop">
<span id="id25"></span><h4><span class="section-number">3.3.6.3. </span>Command Line for <code class="docutils literal notranslate"><span class="pre">gnatchop</span></code><a class="headerlink" href="#command-line-for-gnatchop" title="Permalink to this headline">¶</a></h4>
<p>The <code class="docutils literal notranslate"><span class="pre">gnatchop</span></code> command has the form:</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>$ gnatchop switches file_name <span class="o">[</span>file_name ...<span class="o">]</span>
      <span class="o">[</span>directory<span class="o">]</span>
</pre></div>
</div>
<p>The only required argument is the file name of the file to be chopped.
There are no restrictions on the form of this file name. The file itself
contains one or more Ada units, in normal GNAT format, concatenated
together. As shown, more than one file may be presented to be chopped.</p>
<p>When run in default mode, <code class="docutils literal notranslate"><span class="pre">gnatchop</span></code> generates one output file in
the current directory for each unit in each of the files.</p>
<p><code class="docutils literal notranslate"><span class="pre">directory</span></code>, if specified, gives the name of the directory to which
the output files will be written. If it is not specified, all files are
written to the current directory.</p>
<p>For example, given a
file called <code class="file docutils literal notranslate"><span class="pre">hellofiles</span></code> containing</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="k">procedure </span><span class="nf">Hello</span><span class="p">;</span>

<span class="kr">with</span><span class="nn"> Ada.Text_IO;</span> <span class="kr">use</span><span class="p"> </span><span class="n">Ada.Text_IO</span><span class="p">;</span>
<span class="k">procedure </span><span class="nf">Hello</span> <span class="kr">is</span><span class="p"></span>
<span class="kr">begin</span><span class="p"></span>
   <span class="n">Put_Line</span> <span class="o">(</span><span class="s">&quot;Hello&quot;</span><span class="o">)</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Hello</span><span class="p">;</span>
</pre></div>
</div>
<p>the command</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>$ gnatchop hellofiles
</pre></div>
</div>
<p>generates two files in the current directory, one called
<code class="file docutils literal notranslate"><span class="pre">hello.ads</span></code> containing the single line that is the procedure spec,
and the other called <code class="file docutils literal notranslate"><span class="pre">hello.adb</span></code> containing the remaining text. The
original file is not affected. The generated files can be compiled in
the normal manner.</p>
<p>When gnatchop is invoked on a file that is empty or that contains only empty
lines and/or comments, gnatchop will not fail, but will not produce any
new sources.</p>
<p>For example, given a
file called <code class="file docutils literal notranslate"><span class="pre">toto.txt</span></code> containing</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="c">--  Just a comment</span>
</pre></div>
</div>
<p>the command</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>$ gnatchop toto.txt
</pre></div>
</div>
<p>will not produce any new file and will result in the following warnings:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">toto</span><span class="o">.</span><span class="n">txt</span><span class="p">:</span><span class="mi">1</span><span class="p">:</span><span class="mi">01</span><span class="p">:</span> <span class="n">warning</span><span class="p">:</span> <span class="n">empty</span> <span class="n">file</span><span class="p">,</span> <span class="n">contains</span> <span class="n">no</span> <span class="n">compilation</span> <span class="n">units</span>
<span class="n">no</span> <span class="n">compilation</span> <span class="n">units</span> <span class="n">found</span>
<span class="n">no</span> <span class="n">source</span> <span class="n">files</span> <span class="n">written</span>
</pre></div>
</div>
</div>
<div class="section" id="switches-for-gnatchop">
<span id="id26"></span><h4><span class="section-number">3.3.6.4. </span>Switches for <code class="docutils literal notranslate"><span class="pre">gnatchop</span></code><a class="headerlink" href="#switches-for-gnatchop" title="Permalink to this headline">¶</a></h4>
<p><code class="docutils literal notranslate"><span class="pre">gnatchop</span></code> recognizes the following switches:</p>
<dl class="simple" id="index-45">
<dt><code class="switch docutils literal notranslate"><span class="pre">--version</span></code></dt><dd><p>Display Copyright and version, then exit disregarding all other options.</p>
</dd>
</dl>
<dl class="simple" id="index-46">
<dt><code class="switch docutils literal notranslate"><span class="pre">--help</span></code></dt><dd><p>If <code class="switch docutils literal notranslate"><span class="pre">--version</span></code> was not used, display usage, then exit disregarding
all other options.</p>
</dd>
</dl>
<dl class="simple" id="index-47">
<dt><code class="switch docutils literal notranslate"><span class="pre">-c</span></code></dt><dd><p>Causes <code class="docutils literal notranslate"><span class="pre">gnatchop</span></code> to operate in compilation mode, in which
configuration pragmas are handled according to strict RM rules. See
previous section for a full description of this mode.</p>
</dd>
<dt><code class="switch docutils literal notranslate"><span class="pre">-gnat</span><em><span class="pre">xxx</span></em></code></dt><dd><p>This passes the given <code class="switch docutils literal notranslate"><span class="pre">-gnat</span><em><span class="pre">xxx</span></em></code> switch to <code class="docutils literal notranslate"><span class="pre">gnat</span></code> which is
used to parse the given file. Not all <em>xxx</em> options make sense,
but for example, the use of <code class="switch docutils literal notranslate"><span class="pre">-gnati2</span></code> allows <code class="docutils literal notranslate"><span class="pre">gnatchop</span></code> to
process a source file that uses Latin-2 coding for identifiers.</p>
</dd>
<dt><code class="switch docutils literal notranslate"><span class="pre">-h</span></code></dt><dd><p>Causes <code class="docutils literal notranslate"><span class="pre">gnatchop</span></code> to generate a brief help summary to the standard
output file showing usage information.</p>
</dd>
</dl>
<dl class="simple" id="index-48">
<dt><code class="switch docutils literal notranslate"><span class="pre">-k</span><em><span class="pre">mm</span></em></code></dt><dd><p>Limit generated file names to the specified number <code class="docutils literal notranslate"><span class="pre">mm</span></code>
of characters.
This is useful if the
resulting set of files is required to be interoperable with systems
which limit the length of file names.
No space is allowed between the <code class="switch docutils literal notranslate"><span class="pre">-k</span></code> and the numeric value. The numeric
value may be omitted in which case a default of <code class="switch docutils literal notranslate"><span class="pre">-k8</span></code>,
suitable for use
with DOS-like file systems, is used. If no <code class="switch docutils literal notranslate"><span class="pre">-k</span></code> switch
is present then
there is no limit on the length of file names.</p>
</dd>
</dl>
<dl class="simple" id="index-49">
<dt><code class="switch docutils literal notranslate"><span class="pre">-p</span></code></dt><dd><p>Causes the file modification time stamp of the input file to be
preserved and used for the time stamp of the output file(s). This may be
useful for preserving coherency of time stamps in an environment where
<code class="docutils literal notranslate"><span class="pre">gnatchop</span></code> is used as part of a standard build process.</p>
</dd>
</dl>
<dl class="simple" id="index-50">
<dt><code class="switch docutils literal notranslate"><span class="pre">-q</span></code></dt><dd><p>Causes output of informational messages indicating the set of generated
files to be suppressed. Warnings and error messages are unaffected.</p>
</dd>
</dl>
<span class="target" id="index-51"></span><dl id="index-52">
<dt><code class="switch docutils literal notranslate"><span class="pre">-r</span></code></dt><dd><p>Generate <code class="docutils literal notranslate"><span class="pre">Source_Reference</span></code> pragmas. Use this switch if the output
files are regarded as temporary and development is to be done in terms
of the original unchopped file. This switch causes
<code class="docutils literal notranslate"><span class="pre">Source_Reference</span></code> pragmas to be inserted into each of the
generated files to refers back to the original file name and line number.
The result is that all error messages refer back to the original
unchopped file.
In addition, the debugging information placed into the object file (when
the <code class="switch docutils literal notranslate"><span class="pre">-g</span></code> switch of <code class="docutils literal notranslate"><span class="pre">gcc</span></code> or <code class="docutils literal notranslate"><span class="pre">gnatmake</span></code> is
specified)
also refers back to this original file so that tools like profilers and
debuggers will give information in terms of the original unchopped file.</p>
<p>If the original file to be chopped itself contains
a <code class="docutils literal notranslate"><span class="pre">Source_Reference</span></code>
pragma referencing a third file, then gnatchop respects
this pragma, and the generated <code class="docutils literal notranslate"><span class="pre">Source_Reference</span></code> pragmas
in the chopped file refer to the original file, with appropriate
line numbers. This is particularly useful when <code class="docutils literal notranslate"><span class="pre">gnatchop</span></code>
is used in conjunction with <code class="docutils literal notranslate"><span class="pre">gnatprep</span></code> to compile files that
contain preprocessing statements and multiple units.</p>
</dd>
</dl>
<dl class="simple" id="index-53">
<dt><code class="switch docutils literal notranslate"><span class="pre">-v</span></code></dt><dd><p>Causes <code class="docutils literal notranslate"><span class="pre">gnatchop</span></code> to operate in verbose mode. The version
number and copyright notice are output, as well as exact copies of
the gnat1 commands spawned to obtain the chop control information.</p>
</dd>
</dl>
<dl class="simple" id="index-54">
<dt><code class="switch docutils literal notranslate"><span class="pre">-w</span></code></dt><dd><p>Overwrite existing file names. Normally <code class="docutils literal notranslate"><span class="pre">gnatchop</span></code> regards it as a
fatal error if there is already a file with the same name as a
file it would otherwise output, in other words if the files to be
chopped contain duplicated units. This switch bypasses this
check, and causes all but the last instance of such duplicated
units to be skipped.</p>
</dd>
</dl>
<dl class="simple" id="index-55">
<dt><code class="switch docutils literal notranslate"><span class="pre">--GCC=</span><em><span class="pre">xxxx</span></em></code></dt><dd><p>Specify the path of the GNAT parser to be used. When this switch is used,
no attempt is made to add the prefix to the GNAT parser executable.</p>
</dd>
</dl>
</div>
<div class="section" id="examples-of-gnatchop-usage">
<span id="id27"></span><h4><span class="section-number">3.3.6.5. </span>Examples of <code class="docutils literal notranslate"><span class="pre">gnatchop</span></code> Usage<a class="headerlink" href="#examples-of-gnatchop-usage" title="Permalink to this headline">¶</a></h4>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>$ gnatchop -w hello_s.ada prerelease/files
</pre></div>
</div>
<p>Chops the source file <code class="file docutils literal notranslate"><span class="pre">hello_s.ada</span></code>. The output files will be
placed in the directory <code class="file docutils literal notranslate"><span class="pre">prerelease/files</span></code>,
overwriting any
files with matching names in that directory (no files in the current
directory are modified).</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>$ gnatchop archive
</pre></div>
</div>
<p>Chops the source file <code class="file docutils literal notranslate"><span class="pre">archive</span></code>
into the current directory. One
useful application of <code class="docutils literal notranslate"><span class="pre">gnatchop</span></code> is in sending sets of sources
around, for example in email messages. The required sources are simply
concatenated (for example, using a Unix <code class="docutils literal notranslate"><span class="pre">cat</span></code>
command), and then
<code class="docutils literal notranslate"><span class="pre">gnatchop</span></code> is used at the other end to reconstitute the original
file names.</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>$ gnatchop file1 file2 file3 direc
</pre></div>
</div>
<p>Chops all units in files <code class="file docutils literal notranslate"><span class="pre">file1</span></code>, <code class="file docutils literal notranslate"><span class="pre">file2</span></code>, <code class="file docutils literal notranslate"><span class="pre">file3</span></code>, placing
the resulting files in the directory <code class="file docutils literal notranslate"><span class="pre">direc</span></code>. Note that if any units
occur more than once anywhere within this set of files, an error message
is generated, and no files are written. To override this check, use the
<code class="switch docutils literal notranslate"><span class="pre">-w</span></code> switch,
in which case the last occurrence in the last file will
be the one that is output, and earlier duplicate occurrences for a given
unit will be skipped.</p>
</div>
</div>
</div>
<div class="section" id="configuration-pragmas">
<span id="id28"></span><h2><span class="section-number">3.4. </span>Configuration Pragmas<a class="headerlink" href="#configuration-pragmas" title="Permalink to this headline">¶</a></h2>
<span class="target" id="index-56"></span><p id="index-57">Configuration pragmas include those pragmas described as
such in the Ada Reference Manual, as well as
implementation-dependent pragmas that are configuration pragmas.
See the <code class="docutils literal notranslate"><span class="pre">Implementation_Defined_Pragmas</span></code> chapter in the
<cite>GNAT_Reference_Manual</cite> for details on these
additional GNAT-specific configuration pragmas.
Most notably, the pragma <code class="docutils literal notranslate"><span class="pre">Source_File_Name</span></code>, which allows
specifying non-default names for source files, is a configuration
pragma. The following is a complete list of configuration pragmas
recognized by GNAT:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Ada_83</span>
<span class="n">Ada_95</span>
<span class="n">Ada_05</span>
<span class="n">Ada_2005</span>
<span class="n">Ada_12</span>
<span class="n">Ada_2012</span>
<span class="n">Allow_Integer_Address</span>
<span class="n">Annotate</span>
<span class="n">Assertion_Policy</span>
<span class="n">Assume_No_Invalid_Values</span>
<span class="n">C_Pass_By_Copy</span>
<span class="n">Check_Float_Overflow</span>
<span class="n">Check_Name</span>
<span class="n">Check_Policy</span>
<span class="n">Compile_Time_Error</span>
<span class="n">Compile_Time_Warning</span>
<span class="n">Compiler_Unit</span>
<span class="n">Compiler_Unit_Warning</span>
<span class="n">Component_Alignment</span>
<span class="n">Convention_Identifier</span>
<span class="n">Debug_Policy</span>
<span class="n">Detect_Blocking</span>
<span class="n">Default_Scalar_Storage_Order</span>
<span class="n">Default_Storage_Pool</span>
<span class="n">Disable_Atomic_Synchronization</span>
<span class="n">Discard_Names</span>
<span class="n">Elaboration_Checks</span>
<span class="n">Eliminate</span>
<span class="n">Enable_Atomic_Synchronization</span>
<span class="n">Extend_System</span>
<span class="n">Extensions_Allowed</span>
<span class="n">External_Name_Casing</span>
<span class="n">Fast_Math</span>
<span class="n">Favor_Top_Level</span>
<span class="n">Ignore_Pragma</span>
<span class="n">Implicit_Packing</span>
<span class="n">Initialize_Scalars</span>
<span class="n">Interrupt_State</span>
<span class="n">License</span>
<span class="n">Locking_Policy</span>
<span class="n">No_Component_Reordering</span>
<span class="n">No_Heap_Finalization</span>
<span class="n">No_Run_Time</span>
<span class="n">No_Strict_Aliasing</span>
<span class="n">Normalize_Scalars</span>
<span class="n">Optimize_Alignment</span>
<span class="n">Overflow_Mode</span>
<span class="n">Overriding_Renamings</span>
<span class="n">Partition_Elaboration_Policy</span>
<span class="n">Persistent_BSS</span>
<span class="n">Prefix_Exception_Messages</span>
<span class="n">Priority_Specific_Dispatching</span>
<span class="n">Profile</span>
<span class="n">Profile_Warnings</span>
<span class="n">Propagate_Exceptions</span>
<span class="n">Queuing_Policy</span>
<span class="n">Rational</span>
<span class="n">Ravenscar</span>
<span class="n">Rename_Pragma</span>
<span class="n">Restricted_Run_Time</span>
<span class="n">Restrictions</span>
<span class="n">Restrictions_Warnings</span>
<span class="n">Reviewable</span>
<span class="n">Short_Circuit_And_Or</span>
<span class="n">Short_Descriptors</span>
<span class="n">Source_File_Name</span>
<span class="n">Source_File_Name_Project</span>
<span class="n">SPARK_Mode</span>
<span class="n">Style_Checks</span>
<span class="n">Suppress</span>
<span class="n">Suppress_Exception_Locations</span>
<span class="n">Task_Dispatching_Policy</span>
<span class="n">Unevaluated_Use_Of_Old</span>
<span class="n">Universal_Data</span>
<span class="n">Unsuppress</span>
<span class="n">Use_VADS_Size</span>
<span class="n">Validity_Checks</span>
<span class="n">Warning_As_Error</span>
<span class="n">Warnings</span>
<span class="n">Wide_Character_Encoding</span>
</pre></div>
</div>
<div class="section" id="handling-of-configuration-pragmas">
<span id="id29"></span><h3><span class="section-number">3.4.1. </span>Handling of Configuration Pragmas<a class="headerlink" href="#handling-of-configuration-pragmas" title="Permalink to this headline">¶</a></h3>
<p>Configuration pragmas may either appear at the start of a compilation
unit, or they can appear in a configuration pragma file to apply to
all compilations performed in a given compilation environment.</p>
<p>GNAT also provides the <code class="docutils literal notranslate"><span class="pre">gnatchop</span></code> utility to provide an automatic
way to handle configuration pragmas following the semantics for
compilations (that is, files with multiple units), described in the RM.
See <a class="reference internal" href="#operating-gnatchop-in-compilation-mode"><span class="std std-ref">Operating gnatchop in Compilation Mode</span></a> for details.
However, for most purposes, it will be more convenient to edit the
<code class="file docutils literal notranslate"><span class="pre">gnat.adc</span></code> file that contains configuration pragmas directly,
as described in the following section.</p>
<p>In the case of <code class="docutils literal notranslate"><span class="pre">Restrictions</span></code> pragmas appearing as configuration
pragmas in individual compilation units, the exact handling depends on
the type of restriction.</p>
<p>Restrictions that require partition-wide consistency (like
<code class="docutils literal notranslate"><span class="pre">No_Tasking</span></code>) are
recognized wherever they appear
and can be freely inherited, e.g. from a <em>with</em>ed unit to the <em>with</em>ing
unit. This makes sense since the binder will in any case insist on seeing
consistent use, so any unit not conforming to any restrictions that are
anywhere in the partition will be rejected, and you might as well find
that out at compile time rather than at bind time.</p>
<p>For restrictions that do not require partition-wide consistency, e.g.
SPARK or No_Implementation_Attributes, in general the restriction applies
only to the unit in which the pragma appears, and not to any other units.</p>
<p>The exception is No_Elaboration_Code which always applies to the entire
object file from a compilation, i.e. to the body, spec, and all subunits.
This restriction can be specified in a configuration pragma file, or it
can be on the body and/or the spec (in eithe case it applies to all the
relevant units). It can appear on a subunit only if it has previously
appeared in the body of spec.</p>
</div>
<div class="section" id="the-configuration-pragmas-files">
<span id="id30"></span><h3><span class="section-number">3.4.2. </span>The Configuration Pragmas Files<a class="headerlink" href="#the-configuration-pragmas-files" title="Permalink to this headline">¶</a></h3>
<p id="index-58">In GNAT a compilation environment is defined by the current
directory at the time that a compile command is given. This current
directory is searched for a file whose name is <code class="file docutils literal notranslate"><span class="pre">gnat.adc</span></code>. If
this file is present, it is expected to contain one or more
configuration pragmas that will be applied to the current compilation.
However, if the switch <code class="switch docutils literal notranslate"><span class="pre">-gnatA</span></code> is used, <code class="file docutils literal notranslate"><span class="pre">gnat.adc</span></code> is not
considered. When taken into account, <code class="file docutils literal notranslate"><span class="pre">gnat.adc</span></code> is added to the
dependencies, so that if <code class="file docutils literal notranslate"><span class="pre">gnat.adc</span></code> is modified later, an invocation of
<code class="docutils literal notranslate"><span class="pre">gnatmake</span></code> will recompile the source.</p>
<p>Configuration pragmas may be entered into the <code class="file docutils literal notranslate"><span class="pre">gnat.adc</span></code> file
either by running <code class="docutils literal notranslate"><span class="pre">gnatchop</span></code> on a source file that consists only of
configuration pragmas, or more conveniently by direct editing of the
<code class="file docutils literal notranslate"><span class="pre">gnat.adc</span></code> file, which is a standard format source file.</p>
<p>Besides <code class="file docutils literal notranslate"><span class="pre">gnat.adc</span></code>, additional files containing configuration
pragmas may be applied to the current compilation using the switch
<code class="switch docutils literal notranslate"><span class="pre">-gnatec=</span><em><span class="pre">path</span></em></code> where <code class="docutils literal notranslate"><span class="pre">path</span></code> must designate an existing file that
contains only configuration pragmas. These configuration pragmas are
in addition to those found in <code class="file docutils literal notranslate"><span class="pre">gnat.adc</span></code> (provided <code class="file docutils literal notranslate"><span class="pre">gnat.adc</span></code>
is present and switch <code class="switch docutils literal notranslate"><span class="pre">-gnatA</span></code> is not used).</p>
<p>It is allowable to specify several switches <code class="switch docutils literal notranslate"><span class="pre">-gnatec=</span></code>, all of which
will be taken into account.</p>
<p>Files containing configuration pragmas specified with switches
<code class="switch docutils literal notranslate"><span class="pre">-gnatec=</span></code> are added to the dependencies, unless they are
temporary files. A file is considered temporary if its name ends in
<code class="file docutils literal notranslate"><span class="pre">.tmp</span></code> or <code class="file docutils literal notranslate"><span class="pre">.TMP</span></code>. Certain tools follow this naming
convention because they pass information to <code class="docutils literal notranslate"><span class="pre">gcc</span></code> via
temporary files that are immediately deleted; it doesn’t make sense to
depend on a file that no longer exists. Such tools include
<code class="docutils literal notranslate"><span class="pre">gprbuild</span></code>, <code class="docutils literal notranslate"><span class="pre">gnatmake</span></code>, and <code class="docutils literal notranslate"><span class="pre">gnatcheck</span></code>.</p>
<p>By default, configuration pragma files are stored by their absolute paths in
ALI files. You can use the <code class="switch docutils literal notranslate"><span class="pre">-gnateb</span></code> switch in order to store them by
their basename instead.</p>
<p>If you are using project file, a separate mechanism is provided using
project attributes.</p>
</div>
</div>
<div class="section" id="generating-object-files">
<span id="id31"></span><h2><span class="section-number">3.5. </span>Generating Object Files<a class="headerlink" href="#generating-object-files" title="Permalink to this headline">¶</a></h2>
<p>An Ada program consists of a set of source files, and the first step in
compiling the program is to generate the corresponding object files.
These are generated by compiling a subset of these source files.
The files you need to compile are the following:</p>
<ul class="simple">
<li><p>If a package spec has no body, compile the package spec to produce the
object file for the package.</p></li>
<li><p>If a package has both a spec and a body, compile the body to produce the
object file for the package. The source file for the package spec need
not be compiled in this case because there is only one object file, which
contains the code for both the spec and body of the package.</p></li>
<li><p>For a subprogram, compile the subprogram body to produce the object file
for the subprogram. The spec, if one is present, is as usual in a
separate file, and need not be compiled.</p></li>
</ul>
<ul id="index-59">
<li><p>In the case of subunits, only compile the parent unit. A single object
file is generated for the entire subunit tree, which includes all the
subunits.</p></li>
<li><p>Compile child units independently of their parent units
(though, of course, the spec of all the ancestor unit must be present in order
to compile a child unit).</p>
</li>
<li id="index-60"><p>Compile generic units in the same manner as any other units. The object
files in this case are small dummy files that contain at most the
flag used for elaboration checking. This is because GNAT always handles generic
instantiation by means of macro expansion. However, it is still necessary to
compile generic units, for dependency checking and elaboration purposes.</p></li>
</ul>
<p>The preceding rules describe the set of files that must be compiled to
generate the object files for a program. Each object file has the same
name as the corresponding source file, except that the extension is
<code class="file docutils literal notranslate"><span class="pre">.o</span></code> as usual.</p>
<p>You may wish to compile other files for the purpose of checking their
syntactic and semantic correctness. For example, in the case where a
package has a separate spec and body, you would not normally compile the
spec. However, it is convenient in practice to compile the spec to make
sure it is error-free before compiling clients of this spec, because such
compilations will fail if there is an error in the spec.</p>
<p>GNAT provides an option for compiling such files purely for the
purposes of checking correctness; such compilations are not required as
part of the process of building a program. To compile a file in this
checking mode, use the <code class="switch docutils literal notranslate"><span class="pre">-gnatc</span></code> switch.</p>
</div>
<div class="section" id="source-dependencies">
<span id="id32"></span><h2><span class="section-number">3.6. </span>Source Dependencies<a class="headerlink" href="#source-dependencies" title="Permalink to this headline">¶</a></h2>
<p>A given object file clearly depends on the source file which is compiled
to produce it. Here we are using “depends” in the sense of a typical
<code class="docutils literal notranslate"><span class="pre">make</span></code> utility; in other words, an object file depends on a source
file if changes to the source file require the object file to be
recompiled.
In addition to this basic dependency, a given object may depend on
additional source files as follows:</p>
<ul class="simple">
<li><p>If a file being compiled <em>with</em>s a unit <code class="docutils literal notranslate"><span class="pre">X</span></code>, the object file
depends on the file containing the spec of unit <code class="docutils literal notranslate"><span class="pre">X</span></code>. This includes
files that are <em>with</em>ed implicitly either because they are parents
of <em>with</em>ed child units or they are run-time units required by the
language constructs used in a particular unit.</p></li>
<li><p>If a file being compiled instantiates a library level generic unit, the
object file depends on both the spec and body files for this generic
unit.</p></li>
<li><p>If a file being compiled instantiates a generic unit defined within a
package, the object file depends on the body file for the package as
well as the spec file.</p></li>
</ul>
<span class="target" id="index-61"></span><ul id="index-62">
<li><p>If a file being compiled contains a call to a subprogram for which
pragma <code class="docutils literal notranslate"><span class="pre">Inline</span></code> applies and inlining is activated with the
<code class="switch docutils literal notranslate"><span class="pre">-gnatn</span></code> switch, the object file depends on the file containing the
body of this subprogram as well as on the file containing the spec. Note
that for inlining to actually occur as a result of the use of this switch,
it is necessary to compile in optimizing mode.</p>
<p id="index-63">The use of <code class="switch docutils literal notranslate"><span class="pre">-gnatN</span></code> activates  inlining optimization
that is performed by the front end of the compiler. This inlining does
not require that the code generation be optimized. Like <code class="switch docutils literal notranslate"><span class="pre">-gnatn</span></code>,
the use of this switch generates additional dependencies.</p>
<p>When using a gcc-based back end, then the use of
<code class="switch docutils literal notranslate"><span class="pre">-gnatN</span></code> is deprecated, and the use of <code class="switch docutils literal notranslate"><span class="pre">-gnatn</span></code> is preferred.
Historically front end inlining was more extensive than the gcc back end
inlining, but that is no longer the case.</p>
</li>
<li><p>If an object file <code class="file docutils literal notranslate"><span class="pre">O</span></code> depends on the proper body of a subunit through
inlining or instantiation, it depends on the parent unit of the subunit.
This means that any modification of the parent unit or one of its subunits
affects the compilation of <code class="file docutils literal notranslate"><span class="pre">O</span></code>.</p></li>
<li><p>The object file for a parent unit depends on all its subunit body files.</p></li>
<li><p>The previous two rules meant that for purposes of computing dependencies and
recompilation, a body and all its subunits are treated as an indivisible whole.</p>
<p>These rules are applied transitively: if unit <code class="docutils literal notranslate"><span class="pre">A</span></code> <em>with</em>s
unit <code class="docutils literal notranslate"><span class="pre">B</span></code>, whose elaboration calls an inlined procedure in package
<code class="docutils literal notranslate"><span class="pre">C</span></code>, the object file for unit <code class="docutils literal notranslate"><span class="pre">A</span></code> will depend on the body of
<code class="docutils literal notranslate"><span class="pre">C</span></code>, in file <code class="file docutils literal notranslate"><span class="pre">c.adb</span></code>.</p>
<p>The set of dependent files described by these rules includes all the
files on which the unit is semantically dependent, as dictated by the
Ada language standard. However, it is a superset of what the
standard describes, because it includes generic, inline, and subunit
dependencies.</p>
<p>An object file must be recreated by recompiling the corresponding source
file if any of the source files on which it depends are modified. For
example, if the <code class="docutils literal notranslate"><span class="pre">make</span></code> utility is used to control compilation,
the rule for an Ada object file must mention all the source files on
which the object file depends, according to the above definition.
The determination of the necessary
recompilations is done automatically when one uses <code class="docutils literal notranslate"><span class="pre">gnatmake</span></code>.</p>
</li>
</ul>
</div>
<div class="section" id="the-ada-library-information-files">
<span id="id33"></span><h2><span class="section-number">3.7. </span>The Ada Library Information Files<a class="headerlink" href="#the-ada-library-information-files" title="Permalink to this headline">¶</a></h2>
<span class="target" id="index-64"></span><p id="index-65">Each compilation actually generates two output files. The first of these
is the normal object file that has a <code class="file docutils literal notranslate"><span class="pre">.o</span></code> extension. The second is a
text file containing full dependency information. It has the same
name as the source file, but an <code class="file docutils literal notranslate"><span class="pre">.ali</span></code> extension.
This file is known as the Ada Library Information (<code class="file docutils literal notranslate"><span class="pre">ALI</span></code>) file.
The following information is contained in the <code class="file docutils literal notranslate"><span class="pre">ALI</span></code> file.</p>
<ul class="simple">
<li><p>Version information (indicates which version of GNAT was used to compile
the unit(s) in question)</p></li>
<li><p>Main program information (including priority and time slice settings,
as well as the wide character encoding used during compilation).</p></li>
<li><p>List of arguments used in the <code class="docutils literal notranslate"><span class="pre">gcc</span></code> command for the compilation</p></li>
<li><p>Attributes of the unit, including configuration pragmas used, an indication
of whether the compilation was successful, exception model used etc.</p></li>
<li><p>A list of relevant restrictions applying to the unit (used for consistency)
checking.</p></li>
<li><p>Categorization information (e.g., use of pragma <code class="docutils literal notranslate"><span class="pre">Pure</span></code>).</p></li>
<li><p>Information on all <em>with</em>ed units, including presence of
<code class="docutils literal notranslate"><span class="pre">Elaborate</span></code> or <code class="docutils literal notranslate"><span class="pre">Elaborate_All</span></code> pragmas.</p></li>
<li><p>Information from any <code class="docutils literal notranslate"><span class="pre">Linker_Options</span></code> pragmas used in the unit</p></li>
<li><p>Information on the use of <code class="docutils literal notranslate"><span class="pre">Body_Version</span></code> or <code class="docutils literal notranslate"><span class="pre">Version</span></code>
attributes in the unit.</p></li>
<li><p>Dependency information. This is a list of files, together with
time stamp and checksum information. These are files on which
the unit depends in the sense that recompilation is required
if any of these units are modified.</p></li>
<li><p>Cross-reference data. Contains information on all entities referenced
in the unit. Used by tools like <code class="docutils literal notranslate"><span class="pre">gnatxref</span></code> and <code class="docutils literal notranslate"><span class="pre">gnatfind</span></code> to
provide cross-reference information.</p></li>
</ul>
<p>For a full detailed description of the format of the <code class="file docutils literal notranslate"><span class="pre">ALI</span></code> file,
see the source of the body of unit <code class="docutils literal notranslate"><span class="pre">Lib.Writ</span></code>, contained in file
<code class="file docutils literal notranslate"><span class="pre">lib-writ.adb</span></code> in the GNAT compiler sources.</p>
</div>
<div class="section" id="binding-an-ada-program">
<span id="id34"></span><h2><span class="section-number">3.8. </span>Binding an Ada Program<a class="headerlink" href="#binding-an-ada-program" title="Permalink to this headline">¶</a></h2>
<p>When using languages such as C and C++, once the source files have been
compiled the only remaining step in building an executable program
is linking the object modules together. This means that it is possible to
link an inconsistent version of a program, in which two units have
included different versions of the same header.</p>
<p>The rules of Ada do not permit such an inconsistent program to be built.
For example, if two clients have different versions of the same package,
it is illegal to build a program containing these two clients.
These rules are enforced by the GNAT binder, which also determines an
elaboration order consistent with the Ada rules.</p>
<p>The GNAT binder is run after all the object files for a program have
been created. It is given the name of the main program unit, and from
this it determines the set of units required by the program, by reading the
corresponding ALI files. It generates error messages if the program is
inconsistent or if no valid order of elaboration exists.</p>
<p>If no errors are detected, the binder produces a main program, in Ada by
default, that contains calls to the elaboration procedures of those
compilation unit that require them, followed by
a call to the main program. This Ada program is compiled to generate the
object file for the main program. The name of
the Ada file is <code class="file docutils literal notranslate"><span class="pre">b~xxx</span></code>.adb` (with the corresponding spec
<code class="file docutils literal notranslate"><span class="pre">b~xxx</span></code>.ads`) where <code class="docutils literal notranslate"><span class="pre">xxx</span></code> is the name of the
main program unit.</p>
<p>Finally, the linker is used to build the resulting executable program,
using the object from the main program from the bind step as well as the
object files for the Ada units of the program.</p>
</div>
<div class="section" id="gnat-and-libraries">
<span id="id35"></span><h2><span class="section-number">3.9. </span>GNAT and Libraries<a class="headerlink" href="#gnat-and-libraries" title="Permalink to this headline">¶</a></h2>
<p id="index-66">This section describes how to build and use libraries with GNAT, and also shows
how to recompile the GNAT run-time library. You should be familiar with the
Project Manager facility (see the <em>GNAT_Project_Manager</em> chapter of the
<em>GPRbuild User’s Guide</em>) before reading this chapter.</p>
<div class="section" id="introduction-to-libraries-in-gnat">
<span id="id36"></span><h3><span class="section-number">3.9.1. </span>Introduction to Libraries in GNAT<a class="headerlink" href="#introduction-to-libraries-in-gnat" title="Permalink to this headline">¶</a></h3>
<p>A library is, conceptually, a collection of objects which does not have its
own main thread of execution, but rather provides certain services to the
applications that use it. A library can be either statically linked with the
application, in which case its code is directly included in the application,
or, on platforms that support it, be dynamically linked, in which case
its code is shared by all applications making use of this library.</p>
<p>GNAT supports both types of libraries.
In the static case, the compiled code can be provided in different ways. The
simplest approach is to provide directly the set of objects resulting from
compilation of the library source files. Alternatively, you can group the
objects into an archive using whatever commands are provided by the operating
system. For the latter case, the objects are grouped into a shared library.</p>
<p>In the GNAT environment, a library has three types of components:</p>
<ul class="simple">
<li><p>Source files,</p></li>
<li><p><code class="file docutils literal notranslate"><span class="pre">ALI</span></code> files (see <a class="reference internal" href="#the-ada-library-information-files"><span class="std std-ref">The Ada Library Information Files</span></a>), and</p></li>
<li><p>Object files, an archive or a shared library.</p></li>
</ul>
<p>A GNAT library may expose all its source files, which is useful for
documentation purposes. Alternatively, it may expose only the units needed by
an external user to make use of the library. That is to say, the specs
reflecting the library services along with all the units needed to compile
those specs, which can include generic bodies or any body implementing an
inlined routine. In the case of <em>stand-alone libraries</em> those exposed
units are called <em>interface units</em> (<a class="reference internal" href="#stand-alone-ada-libraries"><span class="std std-ref">Stand-alone Ada Libraries</span></a>).</p>
<p>All compilation units comprising an application, including those in a library,
need to be elaborated in an order partially defined by Ada’s semantics. GNAT
computes the elaboration order from the <code class="file docutils literal notranslate"><span class="pre">ALI</span></code> files and this is why they
constitute a mandatory part of GNAT libraries.
<em>Stand-alone libraries</em> are the exception to this rule because a specific
library elaboration routine is produced independently of the application(s)
using the library.</p>
</div>
<div class="section" id="general-ada-libraries">
<span id="id37"></span><h3><span class="section-number">3.9.2. </span>General Ada Libraries<a class="headerlink" href="#general-ada-libraries" title="Permalink to this headline">¶</a></h3>
<div class="section" id="building-a-library">
<span id="id38"></span><h4><span class="section-number">3.9.2.1. </span>Building a library<a class="headerlink" href="#building-a-library" title="Permalink to this headline">¶</a></h4>
<p>The easiest way to build a library is to use the Project Manager,
which supports a special type of project called a <em>Library Project</em>
(see the <em>Library Projects</em> section in the <em>GNAT Project Manager</em>
chapter of the <em>GPRbuild User’s Guide</em>).</p>
<p>A project is considered a library project, when two project-level attributes
are defined in it: <code class="docutils literal notranslate"><span class="pre">Library_Name</span></code> and <code class="docutils literal notranslate"><span class="pre">Library_Dir</span></code>. In order to
control different aspects of library configuration, additional optional
project-level attributes can be specified:</p>
<ul class="simple">
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">Library_Kind</span></code></dt><dd><p>This attribute controls whether the library is to be static or dynamic</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">Library_Version</span></code></dt><dd><p>This attribute specifies the library version; this value is used
during dynamic linking of shared libraries to determine if the currently
installed versions of the binaries are compatible.</p>
</dd>
</dl>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">Library_Options</span></code></p></li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">Library_GCC</span></code></dt><dd><p>These attributes specify additional low-level options to be used during
library generation, and redefine the actual application used to generate
library.</p>
</dd>
</dl>
</li>
</ul>
<p>The GNAT Project Manager takes full care of the library maintenance task,
including recompilation of the source files for which objects do not exist
or are not up to date, assembly of the library archive, and installation of
the library (i.e., copying associated source, object and <code class="file docutils literal notranslate"><span class="pre">ALI</span></code> files
to the specified location).</p>
<p>Here is a simple library project file:</p>
<div class="highlight-gpr notranslate"><div class="highlight"><pre><span></span><span class="k">project </span><span class="nf">My_Lib</span> <span class="kr">is</span><span class="p"></span>
  <span class="kr">for</span><span class="p"> </span><span class="n">Source_Dirs</span> <span class="kr">use</span><span class="p"> </span><span class="o">(</span><span class="s">&quot;src1&quot;</span><span class="p">,</span> <span class="s">&quot;src2&quot;</span><span class="o">)</span><span class="p">;</span>
  <span class="kr">for</span><span class="p"> </span><span class="n">Object_Dir</span> <span class="kr">use</span><span class="p"> </span><span class="s">&quot;obj&quot;</span><span class="p">;</span>
  <span class="kr">for</span><span class="p"> </span><span class="n">Library_Name</span> <span class="kr">use</span><span class="p"> </span><span class="s">&quot;mylib&quot;</span><span class="p">;</span>
  <span class="kr">for</span><span class="p"> </span><span class="n">Library_Dir</span> <span class="kr">use</span><span class="p"> </span><span class="s">&quot;lib&quot;</span><span class="p">;</span>
  <span class="kr">for</span><span class="p"> </span><span class="n">Library_Kind</span> <span class="kr">use</span><span class="p"> </span><span class="s">&quot;dynamic&quot;</span><span class="p">;</span>
<span class="k">end </span><span class="nf">My_lib</span><span class="p">;</span>
</pre></div>
</div>
<p>and the compilation command to build and install the library:</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>$ gnatmake -Pmy_lib
</pre></div>
</div>
<p>It is not entirely trivial to perform manually all the steps required to
produce a library. We recommend that you use the GNAT Project Manager
for this task. In special cases where this is not desired, the necessary
steps are discussed below.</p>
<p>There are various possibilities for compiling the units that make up the
library: for example with a Makefile (<a class="reference internal" href="building_executable_programs_with_gnat.html#using-the-gnu-make-utility"><span class="std std-ref">Using the GNU make Utility</span></a>) or
with a conventional script. For simple libraries, it is also possible to create
a dummy main program which depends upon all the packages that comprise the
interface of the library. This dummy main program can then be given to
<code class="docutils literal notranslate"><span class="pre">gnatmake</span></code>, which will ensure that all necessary objects are built.</p>
<p>After this task is accomplished, you should follow the standard procedure
of the underlying operating system to produce the static or shared library.</p>
<p>Here is an example of such a dummy program:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">with</span><span class="p"> </span><span class="n">My_Lib.Service1</span><span class="p">;</span>
<span class="kr">with</span><span class="nn"> My_Lib.Service2;</span><span class="p"></span>
<span class="kr">with</span><span class="nn"> My_Lib.Service3;</span>
<span class="k">procedure </span><span class="nf">My_Lib_Dummy</span> <span class="kr">is</span><span class="p"></span>
<span class="kr">begin</span><span class="p"></span>
   <span class="kr">null</span><span class="p">;</span>
<span class="kr">end</span><span class="p">;</span>
</pre></div>
</div>
<p>Here are the generic commands that will build an archive or a shared library.</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span><span class="c1"># compiling the library</span>
$ gnatmake -c my_lib_dummy.adb

<span class="c1"># we don&#39;t need the dummy object itself</span>
$ rm my_lib_dummy.o my_lib_dummy.ali

<span class="c1"># create an archive with the remaining objects</span>
$ ar rc libmy_lib.a *.o
<span class="c1"># some systems may require &quot;ranlib&quot; to be run as well</span>

<span class="c1"># or create a shared library</span>
$ gcc -shared -o libmy_lib.so *.o
<span class="c1"># some systems may require the code to have been compiled with -fPIC</span>

<span class="c1"># remove the object files that are now in the library</span>
$ rm *.o

<span class="c1"># Make the ALI files read-only so that gnatmake will not try to</span>
<span class="c1"># regenerate the objects that are in the library</span>
$ chmod -w *.ali
</pre></div>
</div>
<p>Please note that the library must have a name of the form <code class="file docutils literal notranslate"><span class="pre">lib</span><em><span class="pre">xxx</span></em><span class="pre">.a</span></code>
or <code class="file docutils literal notranslate"><span class="pre">lib</span><em><span class="pre">xxx</span></em><span class="pre">.so</span></code> (or <code class="file docutils literal notranslate"><span class="pre">lib</span><em><span class="pre">xxx</span></em><span class="pre">.dll</span></code> on Windows) in order to
be accessed by the directive <code class="switch docutils literal notranslate"><span class="pre">-l</span><em><span class="pre">xxx</span></em></code> at link time.</p>
</div>
<div class="section" id="installing-a-library">
<span id="id39"></span><h4><span class="section-number">3.9.2.2. </span>Installing a library<a class="headerlink" href="#installing-a-library" title="Permalink to this headline">¶</a></h4>
<span class="target" id="index-67"></span><p id="index-68">If you use project files, library installation is part of the library build
process (see the <em>Installing a Library with Project Files</em> section of the
<em>GNAT Project Manager</em> chapter of the <em>GPRbuild User’s Guide</em>).</p>
<p>When project files are not an option, it is also possible, but not recommended,
to install the library so that the sources needed to use the library are on the
Ada source path and the ALI files &amp; libraries be on the Ada Object path (see
<a class="reference internal" href="building_executable_programs_with_gnat.html#search-paths-and-the-run-time-library-rtl"><span class="std std-ref">Search Paths and the Run-Time Library (RTL)</span></a>. Alternatively, the system
administrator can place general-purpose libraries in the default compiler
paths, by specifying the libraries’ location in the configuration files
<code class="file docutils literal notranslate"><span class="pre">ada_source_path</span></code> and <code class="file docutils literal notranslate"><span class="pre">ada_object_path</span></code>. These configuration files
must be located in the GNAT installation tree at the same place as the gcc spec
file. The location of the gcc spec file can be determined as follows:</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>$ gcc -v
</pre></div>
</div>
<p>The configuration files mentioned above have a simple format: each line
must contain one unique directory name.
Those names are added to the corresponding path
in their order of appearance in the file. The names can be either absolute
or relative; in the latter case, they are relative to where theses files
are located.</p>
<p>The files <code class="file docutils literal notranslate"><span class="pre">ada_source_path</span></code> and <code class="file docutils literal notranslate"><span class="pre">ada_object_path</span></code> might not be
present in a
GNAT installation, in which case, GNAT will look for its run-time library in
the directories <code class="file docutils literal notranslate"><span class="pre">adainclude</span></code> (for the sources) and <code class="file docutils literal notranslate"><span class="pre">adalib</span></code> (for the
objects and <code class="file docutils literal notranslate"><span class="pre">ALI</span></code> files). When the files exist, the compiler does not
look in <code class="file docutils literal notranslate"><span class="pre">adainclude</span></code> and <code class="file docutils literal notranslate"><span class="pre">adalib</span></code>, and thus the
<code class="file docutils literal notranslate"><span class="pre">ada_source_path</span></code> file
must contain the location for the GNAT run-time sources (which can simply
be <code class="file docutils literal notranslate"><span class="pre">adainclude</span></code>). In the same way, the <code class="file docutils literal notranslate"><span class="pre">ada_object_path</span></code> file must
contain the location for the GNAT run-time objects (which can simply
be <code class="file docutils literal notranslate"><span class="pre">adalib</span></code>).</p>
<p>You can also specify a new default path to the run-time library at compilation
time with the switch <code class="switch docutils literal notranslate"><span class="pre">--RTS=rts-path</span></code>. You can thus choose / change
the run-time library you want your program to be compiled with. This switch is
recognized by <code class="docutils literal notranslate"><span class="pre">gcc</span></code>, <code class="docutils literal notranslate"><span class="pre">gnatmake</span></code>, <code class="docutils literal notranslate"><span class="pre">gnatbind</span></code>,
<code class="docutils literal notranslate"><span class="pre">gnatls</span></code>, <code class="docutils literal notranslate"><span class="pre">gnatfind</span></code> and <code class="docutils literal notranslate"><span class="pre">gnatxref</span></code>.</p>
<p>It is possible to install a library before or after the standard GNAT
library, by reordering the lines in the configuration files. In general, a
library must be installed before the GNAT library if it redefines
any part of it.</p>
</div>
<div class="section" id="using-a-library">
<span id="id40"></span><h4><span class="section-number">3.9.2.3. </span>Using a library<a class="headerlink" href="#using-a-library" title="Permalink to this headline">¶</a></h4>
<p>Once again, the project facility greatly simplifies the use of
libraries. In this context, using a library is just a matter of adding a
<em>with</em> clause in the user project. For instance, to make use of the
library <code class="docutils literal notranslate"><span class="pre">My_Lib</span></code> shown in examples in earlier sections, you can
write:</p>
<div class="highlight-gpr notranslate"><div class="highlight"><pre><span></span><span class="kr">with</span><span class="p"> </span><span class="s">&quot;my_lib&quot;</span><span class="p">;</span>
<span class="k">project </span><span class="nf">My_Proj</span> <span class="kr">is</span><span class="p"></span>
  <span class="o">...</span>
<span class="k">end </span><span class="nf">My_Proj</span><span class="p">;</span>
</pre></div>
</div>
<p>Even if you have a third-party, non-Ada library, you can still use GNAT’s
Project Manager facility to provide a wrapper for it. For example, the
following project, when <em>with</em>ed by your main project, will link with the
third-party library <code class="file docutils literal notranslate"><span class="pre">liba.a</span></code>:</p>
<div class="highlight-gpr notranslate"><div class="highlight"><pre><span></span><span class="k">project </span><span class="nf">Liba</span> <span class="kr">is</span><span class="p"></span>
   <span class="kr">for</span><span class="p"> </span><span class="n">Externally_Built</span> <span class="kr">use</span><span class="p"> </span><span class="s">&quot;true&quot;</span><span class="p">;</span>
   <span class="kr">for</span><span class="p"> </span><span class="n">Source_Files</span> <span class="kr">use</span><span class="p"> </span><span class="o">()</span><span class="p">;</span>
   <span class="kr">for</span><span class="p"> </span><span class="n">Library_Dir</span> <span class="kr">use</span><span class="p"> </span><span class="s">&quot;lib&quot;</span><span class="p">;</span>
   <span class="kr">for</span><span class="p"> </span><span class="n">Library_Name</span> <span class="kr">use</span><span class="p"> </span><span class="s">&quot;a&quot;</span><span class="p">;</span>
   <span class="kr">for</span><span class="p"> </span><span class="n">Library_Kind</span> <span class="kr">use</span><span class="p"> </span><span class="s">&quot;static&quot;</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Liba</span><span class="p">;</span>
</pre></div>
</div>
<p>This is an alternative to the use of <code class="docutils literal notranslate"><span class="pre">pragma</span> <span class="pre">Linker_Options</span></code>. It is
especially interesting in the context of systems with several interdependent
static libraries where finding a proper linker order is not easy and best be
left to the tools having visibility over project dependence information.</p>
<p>In order to use an Ada library manually, you need to make sure that this
library is on both your source and object path
(see <a class="reference internal" href="building_executable_programs_with_gnat.html#search-paths-and-the-run-time-library-rtl"><span class="std std-ref">Search Paths and the Run-Time Library (RTL)</span></a>
and <a class="reference internal" href="building_executable_programs_with_gnat.html#search-paths-for-gnatbind"><span class="std std-ref">Search Paths for gnatbind</span></a>). Furthermore, when the objects are grouped
in an archive or a shared library, you need to specify the desired
library at link time.</p>
<p>For example, you can use the library <code class="file docutils literal notranslate"><span class="pre">mylib</span></code> installed in
<code class="file docutils literal notranslate"><span class="pre">/dir/my_lib_src</span></code> and <code class="file docutils literal notranslate"><span class="pre">/dir/my_lib_obj</span></code> with the following commands:</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>$ gnatmake -aI/dir/my_lib_src -aO/dir/my_lib_obj my_appl <span class="se">\\</span>
  -largs -lmy_lib
</pre></div>
</div>
<p>This can be expressed more simply:</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>$ gnatmake my_appl
</pre></div>
</div>
<p>when the following conditions are met:</p>
<ul>
<li><p><code class="file docutils literal notranslate"><span class="pre">/dir/my_lib_src</span></code> has been added by the user to the environment
variable <span class="target" id="index-69"></span><code class="xref std std-envvar docutils literal notranslate"><span class="pre">ADA_INCLUDE_PATH</span></code>, or by the administrator to the file
<code class="file docutils literal notranslate"><span class="pre">ada_source_path</span></code></p></li>
<li><p><code class="file docutils literal notranslate"><span class="pre">/dir/my_lib_obj</span></code> has been added by the user to the environment
variable <span class="target" id="index-70"></span><code class="xref std std-envvar docutils literal notranslate"><span class="pre">ADA_OBJECTS_PATH</span></code>, or by the administrator to the file
<code class="file docutils literal notranslate"><span class="pre">ada_object_path</span></code></p></li>
<li><p>a pragma <code class="docutils literal notranslate"><span class="pre">Linker_Options</span></code> has been added to one of the sources.
For example:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma</span><span class="p"> </span><span class="n">Linker_Options</span> <span class="o">(</span><span class="s">&quot;-lmy_lib&quot;</span><span class="o">)</span><span class="p">;</span>
</pre></div>
</div>
</li>
</ul>
<p>Note that you may also load a library dynamically at
run time given its filename, as illustrated in the GNAT <code class="file docutils literal notranslate"><span class="pre">plugins</span></code> example
in the directory <code class="file docutils literal notranslate"><span class="pre">share/examples/gnat/plugins</span></code> within the GNAT
install area.</p>
</div>
</div>
<div class="section" id="stand-alone-ada-libraries">
<span id="id41"></span><h3><span class="section-number">3.9.3. </span>Stand-alone Ada Libraries<a class="headerlink" href="#stand-alone-ada-libraries" title="Permalink to this headline">¶</a></h3>
<div class="section" id="introduction-to-stand-alone-libraries">
<span id="index-71"></span><span id="id42"></span><h4><span class="section-number">3.9.3.1. </span>Introduction to Stand-alone Libraries<a class="headerlink" href="#introduction-to-stand-alone-libraries" title="Permalink to this headline">¶</a></h4>
<p>A Stand-alone Library (abbreviated ‘SAL’) is a library that contains the
necessary code to
elaborate the Ada units that are included in the library. In contrast with
an ordinary library, which consists of all sources, objects and <code class="file docutils literal notranslate"><span class="pre">ALI</span></code>
files of the
library, a SAL may specify a restricted subset of compilation units
to serve as a library interface. In this case, the fully
self-sufficient set of files will normally consist of an objects
archive, the sources of interface units’ specs, and the <code class="file docutils literal notranslate"><span class="pre">ALI</span></code>
files of interface units.
If an interface spec contains a generic unit or an inlined subprogram,
the body’s
source must also be provided; if the units that must be provided in the source
form depend on other units, the source and <code class="file docutils literal notranslate"><span class="pre">ALI</span></code> files of those must
also be provided.</p>
<p>The main purpose of a SAL is to minimize the recompilation overhead of client
applications when a new version of the library is installed. Specifically,
if the interface sources have not changed, client applications do not need to
be recompiled. If, furthermore, a SAL is provided in the shared form and its
version, controlled by <code class="docutils literal notranslate"><span class="pre">Library_Version</span></code> attribute, is not changed,
then the clients do not need to be relinked.</p>
<p>SALs also allow the library providers to minimize the amount of library source
text exposed to the clients.  Such ‘information hiding’ might be useful or
necessary for various reasons.</p>
<p>Stand-alone libraries are also well suited to be used in an executable whose
main routine is not written in Ada.</p>
</div>
<div class="section" id="building-a-stand-alone-library">
<span id="id43"></span><h4><span class="section-number">3.9.3.2. </span>Building a Stand-alone Library<a class="headerlink" href="#building-a-stand-alone-library" title="Permalink to this headline">¶</a></h4>
<p>GNAT’s Project facility provides a simple way of building and installing
stand-alone libraries; see the <em>Stand-alone Library Projects</em> section
in the <em>GNAT Project Manager</em> chapter of the <em>GPRbuild User’s Guide</em>.
To be a Stand-alone Library Project, in addition to the two attributes
that make a project a Library Project (<code class="docutils literal notranslate"><span class="pre">Library_Name</span></code> and
<code class="docutils literal notranslate"><span class="pre">Library_Dir</span></code>; see the <em>Library Projects</em> section in the
<em>GNAT Project Manager</em> chapter of the <em>GPRbuild User’s Guide</em>),
the attribute <code class="docutils literal notranslate"><span class="pre">Library_Interface</span></code> must be defined.  For example:</p>
<div class="highlight-gpr notranslate"><div class="highlight"><pre><span></span><span class="kr">for</span><span class="p"> </span><span class="n">Library_Dir</span> <span class="kr">use</span><span class="p"> </span><span class="s">&quot;lib_dir&quot;</span><span class="p">;</span>
<span class="kr">for</span><span class="p"> </span><span class="n">Library_Name</span> <span class="kr">use</span><span class="p"> </span><span class="s">&quot;dummy&quot;</span><span class="p">;</span>
<span class="kr">for</span><span class="p"> </span><span class="n">Library_Interface</span> <span class="kr">use</span><span class="p"> </span><span class="o">(</span><span class="s">&quot;int1&quot;</span><span class="p">,</span> <span class="s">&quot;int1.child&quot;</span><span class="o">)</span><span class="p">;</span>
</pre></div>
</div>
<p>Attribute <code class="docutils literal notranslate"><span class="pre">Library_Interface</span></code> has a non-empty string list value,
each string in the list designating a unit contained in an immediate source
of the project file.</p>
<p>When a Stand-alone Library is built, first the binder is invoked to build
a package whose name depends on the library name
(<code class="file docutils literal notranslate"><span class="pre">b~dummy.ads/b</span></code> in the example above).
This binder-generated package includes initialization and
finalization procedures whose
names depend on the library name (<code class="docutils literal notranslate"><span class="pre">dummyinit</span></code> and <code class="docutils literal notranslate"><span class="pre">dummyfinal</span></code>
in the example
above). The object corresponding to this package is included in the library.</p>
<p>You must ensure timely (e.g., prior to any use of interfaces in the SAL)
calling of these procedures if a static SAL is built, or if a shared SAL
is built
with the project-level attribute <code class="docutils literal notranslate"><span class="pre">Library_Auto_Init</span></code> set to
<code class="docutils literal notranslate"><span class="pre">&quot;false&quot;</span></code>.</p>
<p>For a Stand-Alone Library, only the <code class="file docutils literal notranslate"><span class="pre">ALI</span></code> files of the Interface Units
(those that are listed in attribute <code class="docutils literal notranslate"><span class="pre">Library_Interface</span></code>) are copied to
the Library Directory. As a consequence, only the Interface Units may be
imported from Ada units outside of the library. If other units are imported,
the binding phase will fail.</p>
<p>It is also possible to build an encapsulated library where not only
the code to elaborate and finalize the library is embedded but also
ensuring that the library is linked only against static
libraries. So an encapsulated library only depends on system
libraries, all other code, including the GNAT runtime, is embedded. To
build an encapsulated library the attribute
<code class="docutils literal notranslate"><span class="pre">Library_Standalone</span></code> must be set to <code class="docutils literal notranslate"><span class="pre">encapsulated</span></code>:</p>
<div class="highlight-gpr notranslate"><div class="highlight"><pre><span></span><span class="kr">for</span><span class="p"> </span><span class="n">Library_Dir</span> <span class="kr">use</span><span class="p"> </span><span class="s">&quot;lib_dir&quot;</span><span class="p">;</span>
<span class="kr">for</span><span class="p"> </span><span class="n">Library_Name</span> <span class="kr">use</span><span class="p"> </span><span class="s">&quot;dummy&quot;</span><span class="p">;</span>
<span class="kr">for</span><span class="p"> </span><span class="n">Library_Kind</span> <span class="kr">use</span><span class="p"> </span><span class="s">&quot;dynamic&quot;</span><span class="p">;</span>
<span class="kr">for</span><span class="p"> </span><span class="n">Library_Interface</span> <span class="kr">use</span><span class="p"> </span><span class="o">(</span><span class="s">&quot;int1&quot;</span><span class="p">,</span> <span class="s">&quot;int1.child&quot;</span><span class="o">)</span><span class="p">;</span>
<span class="kr">for</span><span class="p"> </span><span class="n">Library_Standalone</span> <span class="kr">use</span><span class="p"> </span><span class="s">&quot;encapsulated&quot;</span><span class="p">;</span>
</pre></div>
</div>
<p>The default value for this attribute is <code class="docutils literal notranslate"><span class="pre">standard</span></code> in which case
a stand-alone library is built.</p>
<p>The attribute <code class="docutils literal notranslate"><span class="pre">Library_Src_Dir</span></code> may be specified for a
Stand-Alone Library. <code class="docutils literal notranslate"><span class="pre">Library_Src_Dir</span></code> is a simple attribute that has a
single string value. Its value must be the path (absolute or relative to the
project directory) of an existing directory. This directory cannot be the
object directory or one of the source directories, but it can be the same as
the library directory. The sources of the Interface
Units of the library that are needed by an Ada client of the library will be
copied to the designated directory, called the Interface Copy directory.
These sources include the specs of the Interface Units, but they may also
include bodies and subunits, when pragmas <code class="docutils literal notranslate"><span class="pre">Inline</span></code> or <code class="docutils literal notranslate"><span class="pre">Inline_Always</span></code>
are used, or when there is a generic unit in the spec. Before the sources
are copied to the Interface Copy directory, an attempt is made to delete all
files in the Interface Copy directory.</p>
<p>Building stand-alone libraries by hand is somewhat tedious, but for those
occasions when it is necessary here are the steps that you need to perform:</p>
<ul>
<li><p>Compile all library sources.</p></li>
<li><p>Invoke the binder with the switch <code class="switch docutils literal notranslate"><span class="pre">-n</span></code> (No Ada main program),
with all the <code class="file docutils literal notranslate"><span class="pre">ALI</span></code> files of the interfaces, and
with the switch <code class="switch docutils literal notranslate"><span class="pre">-L</span></code> to give specific names to the <code class="docutils literal notranslate"><span class="pre">init</span></code>
and <code class="docutils literal notranslate"><span class="pre">final</span></code> procedures.  For example:</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>$ gnatbind -n int1.ali int2.ali -Lsal1
</pre></div>
</div>
</li>
<li><p>Compile the binder generated file:</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>$ gcc -c b~int2.adb
</pre></div>
</div>
</li>
<li><p>Link the dynamic library with all the necessary object files,
indicating to the linker the names of the <code class="docutils literal notranslate"><span class="pre">init</span></code> (and possibly
<code class="docutils literal notranslate"><span class="pre">final</span></code>) procedures for automatic initialization (and finalization).
The built library should be placed in a directory different from
the object directory.</p></li>
<li><p>Copy the <code class="docutils literal notranslate"><span class="pre">ALI</span></code> files of the interface to the library directory,
add in this copy an indication that it is an interface to a SAL
(i.e., add a word <code class="docutils literal notranslate"><span class="pre">SL</span></code> on the line in the <code class="file docutils literal notranslate"><span class="pre">ALI</span></code> file that starts
with letter ‘P’) and make the modified copy of the <code class="file docutils literal notranslate"><span class="pre">ALI</span></code> file
read-only.</p></li>
</ul>
<p>Using SALs is not different from using other libraries
(see <a class="reference internal" href="#using-a-library"><span class="std std-ref">Using a library</span></a>).</p>
</div>
<div class="section" id="creating-a-stand-alone-library-to-be-used-in-a-non-ada-context">
<span id="id44"></span><h4><span class="section-number">3.9.3.3. </span>Creating a Stand-alone Library to be used in a non-Ada context<a class="headerlink" href="#creating-a-stand-alone-library-to-be-used-in-a-non-ada-context" title="Permalink to this headline">¶</a></h4>
<p>It is easy to adapt the SAL build procedure discussed above for use of a SAL in
a non-Ada context.</p>
<p>The only extra step required is to ensure that library interface subprograms
are compatible with the main program, by means of <code class="docutils literal notranslate"><span class="pre">pragma</span> <span class="pre">Export</span></code>
or <code class="docutils literal notranslate"><span class="pre">pragma</span> <span class="pre">Convention</span></code>.</p>
<p>Here is an example of simple library interface for use with C main program:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="k">package </span><span class="nf">My_Package</span> <span class="kr">is</span><span class="p"></span>

   <span class="k">procedure </span><span class="nf">Do_Something</span><span class="p">;</span>
   <span class="kr">pragma</span><span class="p"> </span><span class="n">Export</span> <span class="o">(</span><span class="n">C</span><span class="p">,</span> <span class="n">Do_Something</span><span class="p">,</span> <span class="s">&quot;do_something&quot;</span><span class="o">)</span><span class="p">;</span>

   <span class="k">procedure </span><span class="nf">Do_Something_Else</span><span class="p">;</span>
   <span class="kr">pragma</span><span class="p"> </span><span class="n">Export</span> <span class="o">(</span><span class="n">C</span><span class="p">,</span> <span class="n">Do_Something_Else</span><span class="p">,</span> <span class="s">&quot;do_something_else&quot;</span><span class="o">)</span><span class="p">;</span>

<span class="k">end </span><span class="nf">My_Package</span><span class="p">;</span>
</pre></div>
</div>
<p>On the foreign language side, you must provide a ‘foreign’ view of the
library interface; remember that it should contain elaboration routines in
addition to interface subprograms.</p>
<p>The example below shows the content of <code class="file docutils literal notranslate"><span class="pre">mylib_interface.h</span></code> (note
that there is no rule for the naming of this file, any name can be used)</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/* the library elaboration procedure */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="nf">mylibinit</span> <span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/* the library finalization procedure */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="nf">mylibfinal</span> <span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/* the interface exported by the library */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="nf">do_something</span> <span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="nf">do_something_else</span> <span class="p">(</span><span class="kt">void</span><span class="p">);</span>
</pre></div>
</div>
<p>Libraries built as explained above can be used from any program, provided
that the elaboration procedures (named <code class="docutils literal notranslate"><span class="pre">mylibinit</span></code> in the previous
example) are called before the library services are used. Any number of
libraries can be used simultaneously, as long as the elaboration
procedure of each library is called.</p>
<p>Below is an example of a C program that uses the <code class="docutils literal notranslate"><span class="pre">mylib</span></code> library.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&quot;mylib_interface.h&quot;</span><span class="cp"></span>

<span class="kt">int</span>
<span class="nf">main</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
   <span class="cm">/* First, elaborate the library before using it */</span>
   <span class="n">mylibinit</span> <span class="p">();</span>

   <span class="cm">/* Main program, using the library exported entities */</span>
   <span class="n">do_something</span> <span class="p">();</span>
   <span class="n">do_something_else</span> <span class="p">();</span>

   <span class="cm">/* Library finalization at the end of the program */</span>
   <span class="n">mylibfinal</span> <span class="p">();</span>
   <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Note that invoking any library finalization procedure generated by
<code class="docutils literal notranslate"><span class="pre">gnatbind</span></code> shuts down the Ada run-time environment.
Consequently, the
finalization of all Ada libraries must be performed at the end of the program.
No call to these libraries or to the Ada run-time library should be made
after the finalization phase.</p>
<p>Note also that special care must be taken with multi-tasks
applications. The initialization and finalization routines are not
protected against concurrent access. If such requirement is needed it
must be ensured at the application level using a specific operating
system services like a mutex or a critical-section.</p>
</div>
<div class="section" id="restrictions-in-stand-alone-libraries">
<span id="id45"></span><h4><span class="section-number">3.9.3.4. </span>Restrictions in Stand-alone Libraries<a class="headerlink" href="#restrictions-in-stand-alone-libraries" title="Permalink to this headline">¶</a></h4>
<p>The pragmas listed below should be used with caution inside libraries,
as they can create incompatibilities with other Ada libraries:</p>
<ul class="simple">
<li><p>pragma <code class="docutils literal notranslate"><span class="pre">Locking_Policy</span></code></p></li>
<li><p>pragma <code class="docutils literal notranslate"><span class="pre">Partition_Elaboration_Policy</span></code></p></li>
<li><p>pragma <code class="docutils literal notranslate"><span class="pre">Queuing_Policy</span></code></p></li>
<li><p>pragma <code class="docutils literal notranslate"><span class="pre">Task_Dispatching_Policy</span></code></p></li>
<li><p>pragma <code class="docutils literal notranslate"><span class="pre">Unreserve_All_Interrupts</span></code></p></li>
</ul>
<p>When using a library that contains such pragmas, the user must make sure
that all libraries use the same pragmas with the same values. Otherwise,
<code class="docutils literal notranslate"><span class="pre">Program_Error</span></code> will
be raised during the elaboration of the conflicting
libraries. The usage of these pragmas and its consequences for the user
should therefore be well documented.</p>
<p>Similarly, the traceback in the exception occurrence mechanism should be
enabled or disabled in a consistent manner across all libraries.
Otherwise, Program_Error will be raised during the elaboration of the
conflicting libraries.</p>
<p>If the <code class="docutils literal notranslate"><span class="pre">Version</span></code> or <code class="docutils literal notranslate"><span class="pre">Body_Version</span></code>
attributes are used inside a library, then you need to
perform a <code class="docutils literal notranslate"><span class="pre">gnatbind</span></code> step that specifies all <code class="file docutils literal notranslate"><span class="pre">ALI</span></code> files in all
libraries, so that version identifiers can be properly computed.
In practice these attributes are rarely used, so this is unlikely
to be a consideration.</p>
</div>
</div>
<div class="section" id="rebuilding-the-gnat-run-time-library">
<span id="id46"></span><h3><span class="section-number">3.9.4. </span>Rebuilding the GNAT Run-Time Library<a class="headerlink" href="#rebuilding-the-gnat-run-time-library" title="Permalink to this headline">¶</a></h3>
<span class="target" id="index-72"></span><span class="target" id="index-73"></span><span class="target" id="index-74"></span><p id="index-75">It may be useful to recompile the GNAT library in various debugging or
experimentation contexts. A project file called
<code class="file docutils literal notranslate"><span class="pre">libada.gpr</span></code> is provided to that effect and can be found in
the directory containing the GNAT library. The location of this
directory depends on the way the GNAT environment has been installed and can
be determined by means of the command:</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>$ gnatls -v
</pre></div>
</div>
<p>The last entry in the source search path usually contains the
gnat library (the <code class="file docutils literal notranslate"><span class="pre">adainclude</span></code> directory). This project file contains its
own documentation and in particular the set of instructions needed to rebuild a
new library and to use it.</p>
<p>Note that rebuilding the GNAT Run-Time is only recommended for temporary
experiments or debugging, and is not supported.</p>
</div>
</div>
<div class="section" id="conditional-compilation">
<span id="index-76"></span><span id="id47"></span><h2><span class="section-number">3.10. </span>Conditional Compilation<a class="headerlink" href="#conditional-compilation" title="Permalink to this headline">¶</a></h2>
<p>This section presents some guidelines for modeling conditional compilation in Ada and describes the
gnatprep preprocessor utility.</p>
<div class="section" id="modeling-conditional-compilation-in-ada">
<span id="index-77"></span><span id="id48"></span><h3><span class="section-number">3.10.1. </span>Modeling Conditional Compilation in Ada<a class="headerlink" href="#modeling-conditional-compilation-in-ada" title="Permalink to this headline">¶</a></h3>
<p>It is often necessary to arrange for a single source program
to serve multiple purposes, where it is compiled in different
ways to achieve these different goals. Some examples of the
need for this feature are</p>
<ul class="simple">
<li><p>Adapting a program to a different hardware environment</p></li>
<li><p>Adapting a program to a different target architecture</p></li>
<li><p>Turning debugging features on and off</p></li>
<li><p>Arranging for a program to compile with different compilers</p></li>
</ul>
<p>In C, or C++, the typical approach would be to use the preprocessor
that is defined as part of the language. The Ada language does not
contain such a feature. This is not an oversight, but rather a very
deliberate design decision, based on the experience that overuse of
the preprocessing features in C and C++ can result in programs that
are extremely difficult to maintain. For example, if we have ten
switches that can be on or off, this means that there are a thousand
separate programs, any one of which might not even be syntactically
correct, and even if syntactically correct, the resulting program
might not work correctly. Testing all combinations can quickly become
impossible.</p>
<p>Nevertheless, the need to tailor programs certainly exists, and in
this section we will discuss how this can
be achieved using Ada in general, and GNAT in particular.</p>
<div class="section" id="use-of-boolean-constants">
<span id="id49"></span><h4><span class="section-number">3.10.1.1. </span>Use of Boolean Constants<a class="headerlink" href="#use-of-boolean-constants" title="Permalink to this headline">¶</a></h4>
<p>In the case where the difference is simply which code
sequence is executed, the cleanest solution is to use Boolean
constants to control which code is executed.</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="n">FP_Initialize_Required</span> <span class="o">:</span> <span class="kr">constant</span><span class="p"> </span><span class="n">Boolean</span> <span class="o">:=</span> <span class="kc">True</span><span class="p">;</span>
<span class="o">...</span>
<span class="kr">if</span><span class="p"> </span><span class="n">FP_Initialize_Required</span> <span class="kr">then</span><span class="p"></span>
<span class="o">...</span>
<span class="k">end if</span><span class="p">;</span>
</pre></div>
</div>
<p>Not only will the code inside the <code class="docutils literal notranslate"><span class="pre">if</span></code> statement not be executed if
the constant Boolean is <code class="docutils literal notranslate"><span class="pre">False</span></code>, but it will also be completely
deleted from the program.
However, the code is only deleted after the <code class="docutils literal notranslate"><span class="pre">if</span></code> statement
has been checked for syntactic and semantic correctness.
(In contrast, with preprocessors the code is deleted before the
compiler ever gets to see it, so it is not checked until the switch
is turned on.)</p>
<p id="index-78">Typically the Boolean constants will be in a separate package,
something like:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="k">package </span><span class="nf">Config</span> <span class="kr">is</span><span class="p"></span>
   <span class="n">FP_Initialize_Required</span> <span class="o">:</span> <span class="kr">constant</span><span class="p"> </span><span class="n">Boolean</span> <span class="o">:=</span> <span class="kc">True</span><span class="p">;</span>
   <span class="n">Reset_Available</span>        <span class="o">:</span> <span class="kr">constant</span><span class="p"> </span><span class="n">Boolean</span> <span class="o">:=</span> <span class="kc">False</span><span class="p">;</span>
   <span class="o">...</span>
<span class="k">end </span><span class="nf">Config</span><span class="p">;</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">Config</span></code> package exists in multiple forms for the various targets,
with an appropriate script selecting the version of <code class="docutils literal notranslate"><span class="pre">Config</span></code> needed.
Then any other unit requiring conditional compilation can do a <em>with</em>
of <code class="docutils literal notranslate"><span class="pre">Config</span></code> to make the constants visible.</p>
</div>
<div class="section" id="debugging-a-special-case">
<span id="id50"></span><h4><span class="section-number">3.10.1.2. </span>Debugging - A Special Case<a class="headerlink" href="#debugging-a-special-case" title="Permalink to this headline">¶</a></h4>
<p>A common use of conditional code is to execute statements (for example
dynamic checks, or output of intermediate results) under control of a
debug switch, so that the debugging behavior can be turned on and off.
This can be done using a Boolean constant to control whether the code
is active:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">if</span><span class="p"> </span><span class="n">Debugging</span> <span class="kr">then</span><span class="p"></span>
   <span class="n">Put_Line</span> <span class="o">(</span><span class="s">&quot;got to the first stage!&quot;</span><span class="o">)</span><span class="p">;</span>
<span class="k">end if</span><span class="p">;</span>
</pre></div>
</div>
<p>or</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">if</span><span class="p"> </span><span class="n">Debugging</span> <span class="kr">and</span><span class="p"> </span><span class="kr">then</span><span class="p"> </span><span class="n">Temperature</span> <span class="o">&gt;</span> <span class="mi">999</span><span class="o">.</span><span class="mi">0</span> <span class="kr">then</span><span class="p"></span>
   <span class="kr">raise</span><span class="p"> </span><span class="n">Temperature_Crazy</span><span class="p">;</span>
<span class="k">end if</span><span class="p">;</span>
</pre></div>
</div>
<p id="index-79">Since this is a common case, there are special features to deal with
this in a convenient manner. For the case of tests, Ada 2005 has added
a pragma <code class="docutils literal notranslate"><span class="pre">Assert</span></code> that can be used for such tests. This pragma is modeled
on the <code class="docutils literal notranslate"><span class="pre">Assert</span></code> pragma that has always been available in GNAT, so this
feature may be used with GNAT even if you are not using Ada 2005 features.
The use of pragma <code class="docutils literal notranslate"><span class="pre">Assert</span></code> is described in the
<cite>GNAT_Reference_Manual</cite>, but as an
example, the last test could be written:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma</span><span class="p"> </span><span class="n">Assert</span> <span class="o">(</span><span class="n">Temperature</span> <span class="o">&lt;=</span> <span class="mi">999</span><span class="o">.</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;Temperature Crazy&quot;</span><span class="o">)</span><span class="p">;</span>
</pre></div>
</div>
<p>or simply</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma</span><span class="p"> </span><span class="n">Assert</span> <span class="o">(</span><span class="n">Temperature</span> <span class="o">&lt;=</span> <span class="mi">999</span><span class="o">.</span><span class="mi">0</span><span class="o">)</span><span class="p">;</span>
</pre></div>
</div>
<p>In both cases, if assertions are active and the temperature is excessive,
the exception <code class="docutils literal notranslate"><span class="pre">Assert_Failure</span></code> will be raised, with the given string in
the first case or a string indicating the location of the pragma in the second
case used as the exception message.</p>
<p id="index-80">You can turn assertions on and off by using the <code class="docutils literal notranslate"><span class="pre">Assertion_Policy</span></code>
pragma.</p>
<p id="index-81">This is an Ada 2005 pragma which is implemented in all modes by
GNAT. Alternatively, you can use the <code class="switch docutils literal notranslate"><span class="pre">-gnata</span></code> switch
to enable assertions from the command line, which applies to
all versions of Ada.</p>
<p id="index-82">For the example above with the <code class="docutils literal notranslate"><span class="pre">Put_Line</span></code>, the GNAT-specific pragma
<code class="docutils literal notranslate"><span class="pre">Debug</span></code> can be used:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma</span><span class="p"> </span><span class="n">Debug</span> <span class="o">(</span><span class="n">Put_Line</span> <span class="o">(</span><span class="s">&quot;got to the first stage!&quot;</span><span class="o">))</span><span class="p">;</span>
</pre></div>
</div>
<p>If debug pragmas are enabled, the argument, which must be of the form of
a procedure call, is executed (in this case, <code class="docutils literal notranslate"><span class="pre">Put_Line</span></code> will be called).
Only one call can be present, but of course a special debugging procedure
containing any code you like can be included in the program and then
called in a pragma <code class="docutils literal notranslate"><span class="pre">Debug</span></code> argument as needed.</p>
<p>One advantage of pragma <code class="docutils literal notranslate"><span class="pre">Debug</span></code> over the <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">Debugging</span> <span class="pre">then</span></code>
construct is that pragma <code class="docutils literal notranslate"><span class="pre">Debug</span></code> can appear in declarative contexts,
such as at the very beginning of a procedure, before local declarations have
been elaborated.</p>
<p id="index-83">Debug pragmas are enabled using either the <code class="switch docutils literal notranslate"><span class="pre">-gnata</span></code> switch that also
controls assertions, or with a separate Debug_Policy pragma.</p>
<p>The latter pragma is new in the Ada 2005 versions of GNAT (but it can be used
in Ada 95 and Ada 83 programs as well), and is analogous to
pragma <code class="docutils literal notranslate"><span class="pre">Assertion_Policy</span></code> to control assertions.</p>
<p><code class="docutils literal notranslate"><span class="pre">Assertion_Policy</span></code> and <code class="docutils literal notranslate"><span class="pre">Debug_Policy</span></code> are configuration pragmas,
and thus they can appear in <code class="file docutils literal notranslate"><span class="pre">gnat.adc</span></code> if you are not using a
project file, or in the file designated to contain configuration pragmas
in a project file.
They then apply to all subsequent compilations. In practice the use of
the <code class="switch docutils literal notranslate"><span class="pre">-gnata</span></code> switch is often the most convenient method of controlling
the status of these pragmas.</p>
<p>Note that a pragma is not a statement, so in contexts where a statement
sequence is required, you can’t just write a pragma on its own. You have
to add a <code class="docutils literal notranslate"><span class="pre">null</span></code> statement.</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">if</span><span class="p"> </span><span class="o">...</span> <span class="kr">then</span><span class="p"></span>
   <span class="o">...</span> <span class="c">-- some statements</span>
<span class="kr">else</span><span class="p"></span>
   <span class="kr">pragma</span><span class="p"> </span><span class="n">Assert</span> <span class="o">(</span><span class="n">Num_Cases</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="o">)</span><span class="p">;</span>
   <span class="kr">null</span><span class="p">;</span>
<span class="k">end if</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="conditionalizing-declarations">
<span id="id51"></span><h4><span class="section-number">3.10.1.3. </span>Conditionalizing Declarations<a class="headerlink" href="#conditionalizing-declarations" title="Permalink to this headline">¶</a></h4>
<p>In some cases it may be necessary to conditionalize declarations to meet
different requirements. For example we might want a bit string whose length
is set to meet some hardware message requirement.</p>
<p>This may be possible using declare blocks controlled
by conditional constants:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">if</span><span class="p"> </span><span class="n">Small_Machine</span> <span class="kr">then</span><span class="p"></span>
   <span class="kr">declare</span><span class="p"></span>
      <span class="n">X</span> <span class="o">:</span> <span class="n">Bit_String</span> <span class="o">(</span><span class="mi">1</span> <span class="o">..</span> <span class="mi">10</span><span class="o">)</span><span class="p">;</span>
   <span class="kr">begin</span><span class="p"></span>
      <span class="o">...</span>
   <span class="kr">end</span><span class="p">;</span>
<span class="kr">else</span><span class="p"></span>
   <span class="kr">declare</span><span class="p"></span>
      <span class="n">X</span> <span class="o">:</span> <span class="n">Large_Bit_String</span> <span class="o">(</span><span class="mi">1</span> <span class="o">..</span> <span class="mi">1000</span><span class="o">)</span><span class="p">;</span>
   <span class="kr">begin</span><span class="p"></span>
      <span class="o">...</span>
   <span class="kr">end</span><span class="p">;</span>
<span class="k">end if</span><span class="p">;</span>
</pre></div>
</div>
<p>Note that in this approach, both declarations are analyzed by the
compiler so this can only be used where both declarations are legal,
even though one of them will not be used.</p>
<p>Another approach is to define integer constants, e.g., <code class="docutils literal notranslate"><span class="pre">Bits_Per_Word</span></code>,
or Boolean constants, e.g., <code class="docutils literal notranslate"><span class="pre">Little_Endian</span></code>, and then write declarations
that are parameterized by these constants. For example</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">for</span><span class="p"> </span><span class="n">Rec</span> <span class="kr">use</span><span class="p"></span>
  <span class="n">Field1</span> <span class="kr">at</span><span class="p"> </span><span class="mi">0</span> <span class="kr">range</span><span class="p"> </span><span class="n">Boolean</span><span class="na">&#39;Pos</span> <span class="o">(</span><span class="n">Little_Endian</span><span class="o">)</span> <span class="o">*</span> <span class="mi">10</span> <span class="o">..</span> <span class="n">Bits_Per_Word</span><span class="p">;</span>
<span class="k">end record</span><span class="p">;</span>
</pre></div>
</div>
<p>If <code class="docutils literal notranslate"><span class="pre">Bits_Per_Word</span></code> is set to 32, this generates either</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">for</span><span class="p"> </span><span class="n">Rec</span> <span class="kr">use</span><span class="p"></span>
  <span class="n">Field1</span> <span class="kr">at</span><span class="p"> </span><span class="mi">0</span> <span class="kr">range</span><span class="p"> </span><span class="mi">0</span> <span class="o">..</span> <span class="mi">32</span><span class="p">;</span>
<span class="k">end record</span><span class="p">;</span>
</pre></div>
</div>
<p>for the big endian case, or</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">for</span><span class="p"> </span><span class="n">Rec</span> <span class="kr">use</span><span class="p"> </span><span class="kr">record</span><span class="p"></span>
    <span class="n">Field1</span> <span class="kr">at</span><span class="p"> </span><span class="mi">0</span> <span class="kr">range</span><span class="p"> </span><span class="mi">10</span> <span class="o">..</span> <span class="mi">32</span><span class="p">;</span>
<span class="k">end record</span><span class="p">;</span>
</pre></div>
</div>
<p>for the little endian case. Since a powerful subset of Ada expression
notation is usable for creating static constants, clever use of this
feature can often solve quite difficult problems in conditionalizing
compilation (note incidentally that in Ada 95, the little endian
constant was introduced as <code class="docutils literal notranslate"><span class="pre">System.Default_Bit_Order</span></code>, so you do not
need to define this one yourself).</p>
</div>
<div class="section" id="use-of-alternative-implementations">
<span id="id52"></span><h4><span class="section-number">3.10.1.4. </span>Use of Alternative Implementations<a class="headerlink" href="#use-of-alternative-implementations" title="Permalink to this headline">¶</a></h4>
<p>In some cases, none of the approaches described above are adequate. This
can occur for example if the set of declarations required is radically
different for two different configurations.</p>
<p>In this situation, the official Ada way of dealing with conditionalizing
such code is to write separate units for the different cases. As long as
this does not result in excessive duplication of code, this can be done
without creating maintenance problems. The approach is to share common
code as far as possible, and then isolate the code and declarations
that are different. Subunits are often a convenient method for breaking
out a piece of a unit that is to be conditionalized, with separate files
for different versions of the subunit for different targets, where the
build script selects the right one to give to the compiler.</p>
<p id="index-84">As an example, consider a situation where a new feature in Ada 2005
allows something to be done in a really nice way. But your code must be able
to compile with an Ada 95 compiler. Conceptually you want to say:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">if</span><span class="p"> </span><span class="n">Ada_2005</span> <span class="kr">then</span><span class="p"></span>
   <span class="o">...</span> <span class="n">neat</span> <span class="n">Ada</span> <span class="mi">2005</span> <span class="n">code</span>
<span class="kr">else</span><span class="p"></span>
   <span class="o">...</span> <span class="kr">not</span><span class="p"> </span><span class="n">quite</span> <span class="n">as</span> <span class="n">neat</span> <span class="n">Ada</span> <span class="mi">95</span> <span class="n">code</span>
<span class="k">end if</span><span class="p">;</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">Ada_2005</span></code> is a Boolean constant.</p>
<p>But this won’t work when <code class="docutils literal notranslate"><span class="pre">Ada_2005</span></code> is set to <code class="docutils literal notranslate"><span class="pre">False</span></code>,
since the <code class="docutils literal notranslate"><span class="pre">then</span></code> clause will be illegal for an Ada 95 compiler.
(Recall that although such unreachable code would eventually be deleted
by the compiler, it still needs to be legal.  If it uses features
introduced in Ada 2005, it will be illegal in Ada 95.)</p>
<p>So instead we write</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="k">procedure </span><span class="nf">Insert</span> <span class="kr">is</span><span class="p"> </span><span class="kr">separate</span><span class="p">;</span>
</pre></div>
</div>
<p>Then we have two files for the subunit <code class="docutils literal notranslate"><span class="pre">Insert</span></code>, with the two sets of
code.
If the package containing this is called <code class="docutils literal notranslate"><span class="pre">File_Queries</span></code>, then we might
have two files</p>
<ul class="simple">
<li><p><code class="file docutils literal notranslate"><span class="pre">file_queries-insert-2005.adb</span></code></p></li>
<li><p><code class="file docutils literal notranslate"><span class="pre">file_queries-insert-95.adb</span></code></p></li>
</ul>
<p>and the build script renames the appropriate file to <code class="file docutils literal notranslate"><span class="pre">file_queries-insert.adb</span></code> and then carries out the compilation.</p>
<p>This can also be done with project files’ naming schemes. For example:</p>
<div class="highlight-gpr notranslate"><div class="highlight"><pre><span></span><span class="kr">for</span><span class="p"> </span><span class="kr">body</span><span class="p"> </span><span class="o">(</span><span class="s">&quot;File_Queries.Insert&quot;</span><span class="o">)</span> <span class="kr">use</span><span class="p"> </span><span class="s">&quot;file_queries-insert-2005.ada&quot;</span><span class="p">;</span>
</pre></div>
</div>
<p>Note also that with project files it is desirable to use a different extension
than <code class="file docutils literal notranslate"><span class="pre">ads</span></code> / <code class="file docutils literal notranslate"><span class="pre">adb</span></code> for alternative versions. Otherwise a naming
conflict may arise through another commonly used feature: to declare as part
of the project a set of directories containing all the sources obeying the
default naming scheme.</p>
<p>The use of alternative units is certainly feasible in all situations,
and for example the Ada part of the GNAT run-time is conditionalized
based on the target architecture using this approach. As a specific example,
consider the implementation of the AST feature in VMS. There is one
spec: <code class="file docutils literal notranslate"><span class="pre">s-asthan.ads</span></code> which is the same for all architectures, and three
bodies:</p>
<ul class="simple">
<li><dl class="simple">
<dt><code class="file docutils literal notranslate"><span class="pre">s-asthan.adb</span></code></dt><dd><p>used for all non-VMS operating systems</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="file docutils literal notranslate"><span class="pre">s-asthan-vms-alpha.adb</span></code></dt><dd><p>used for VMS on the Alpha</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="file docutils literal notranslate"><span class="pre">s-asthan-vms-ia64.adb</span></code></dt><dd><p>used for VMS on the ia64</p>
</dd>
</dl>
</li>
</ul>
<p>The dummy version <code class="file docutils literal notranslate"><span class="pre">s-asthan.adb</span></code> simply raises exceptions noting that
this operating system feature is not available, and the two remaining
versions interface with the corresponding versions of VMS to provide
VMS-compatible AST handling. The GNAT build script knows the architecture
and operating system, and automatically selects the right version,
renaming it if necessary to <code class="file docutils literal notranslate"><span class="pre">s-asthan.adb</span></code> before the run-time build.</p>
<p>Another style for arranging alternative implementations is through Ada’s
access-to-subprogram facility.
In case some functionality is to be conditionally included,
you can declare an access-to-procedure variable <code class="docutils literal notranslate"><span class="pre">Ref</span></code> that is initialized
to designate a ‘do nothing’ procedure, and then invoke <code class="docutils literal notranslate"><span class="pre">Ref.all</span></code>
when appropriate.
In some library package, set <code class="docutils literal notranslate"><span class="pre">Ref</span></code> to <code class="docutils literal notranslate"><span class="pre">Proc'Access</span></code> for some
procedure <code class="docutils literal notranslate"><span class="pre">Proc</span></code> that performs the relevant processing.
The initialization only occurs if the library package is included in the
program.
The same idea can also be implemented using tagged types and dispatching
calls.</p>
</div>
<div class="section" id="preprocessing">
<span id="id53"></span><h4><span class="section-number">3.10.1.5. </span>Preprocessing<a class="headerlink" href="#preprocessing" title="Permalink to this headline">¶</a></h4>
<p id="index-85">Although it is quite possible to conditionalize code without the use of
C-style preprocessing, as described earlier in this section, it is
nevertheless convenient in some cases to use the C approach. Moreover,
older Ada compilers have often provided some preprocessing capability,
so legacy code may depend on this approach, even though it is not
standard.</p>
<p>To accommodate such use, GNAT provides a preprocessor (modeled to a large
extent on the various preprocessors that have been used
with legacy code on other compilers, to enable easier transition).</p>
<p id="index-86">The preprocessor may be used in two separate modes. It can be used quite
separately from the compiler, to generate a separate output source file
that is then fed to the compiler as a separate step. This is the
<code class="docutils literal notranslate"><span class="pre">gnatprep</span></code> utility, whose use is fully described in
<a class="reference internal" href="#preprocessing-with-gnatprep"><span class="std std-ref">Preprocessing with gnatprep</span></a>.</p>
<p>The preprocessing language allows such constructs as</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#if DEBUG or else (PRIORITY &gt; 4) then</span>
   <span class="n">sequence</span> <span class="n">of</span> <span class="n">declarations</span>
<span class="cp">#else</span>
   <span class="n">completely</span> <span class="n">different</span> <span class="n">sequence</span> <span class="n">of</span> <span class="n">declarations</span>
<span class="cp">#end if;</span>
</pre></div>
</div>
<p>The values of the symbols <code class="docutils literal notranslate"><span class="pre">DEBUG</span></code> and <code class="docutils literal notranslate"><span class="pre">PRIORITY</span></code> can be
defined either on the command line or in a separate file.</p>
<p>The other way of running the preprocessor is even closer to the C style and
often more convenient. In this approach the preprocessing is integrated into
the compilation process. The compiler is given the preprocessor input which
includes <code class="docutils literal notranslate"><span class="pre">#if</span></code> lines etc, and then the compiler carries out the
preprocessing internally and processes the resulting output.
For more details on this approach, see <a class="reference internal" href="#integrated-preprocessing"><span class="std std-ref">Integrated Preprocessing</span></a>.</p>
</div>
</div>
<div class="section" id="preprocessing-with-gnatprep">
<span id="id54"></span><h3><span class="section-number">3.10.2. </span>Preprocessing with <code class="docutils literal notranslate"><span class="pre">gnatprep</span></code><a class="headerlink" href="#preprocessing-with-gnatprep" title="Permalink to this headline">¶</a></h3>
<span class="target" id="index-87"></span><p id="index-88">This section discusses how to use GNAT’s <code class="docutils literal notranslate"><span class="pre">gnatprep</span></code> utility for simple
preprocessing.
Although designed for use with GNAT, <code class="docutils literal notranslate"><span class="pre">gnatprep</span></code> does not depend on any
special GNAT features.
For further discussion of conditional compilation in general, see
<a class="reference internal" href="#conditional-compilation"><span class="std std-ref">Conditional Compilation</span></a>.</p>
<div class="section" id="preprocessing-symbols">
<span id="id55"></span><h4><span class="section-number">3.10.2.1. </span>Preprocessing Symbols<a class="headerlink" href="#preprocessing-symbols" title="Permalink to this headline">¶</a></h4>
<p>Preprocessing symbols are defined in <em>definition files</em> and referenced in the
sources to be preprocessed. A preprocessing symbol is an identifier, following
normal Ada (case-insensitive) rules for its syntax, with the restriction that
all characters need to be in the ASCII set (no accented letters).</p>
</div>
<div class="section" id="using-gnatprep">
<span id="id56"></span><h4><span class="section-number">3.10.2.2. </span>Using <code class="docutils literal notranslate"><span class="pre">gnatprep</span></code><a class="headerlink" href="#using-gnatprep" title="Permalink to this headline">¶</a></h4>
<p>To call <code class="docutils literal notranslate"><span class="pre">gnatprep</span></code> use:</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>$ gnatprep <span class="o">[</span> switches <span class="o">]</span> infile outfile <span class="o">[</span> deffile <span class="o">]</span>
</pre></div>
</div>
<p>where</p>
<ul class="simple">
<li><dl class="simple">
<dt><em>switches</em></dt><dd><p>is an optional sequence of switches as described in the next section.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><em>infile</em></dt><dd><p>is the full name of the input file, which is an Ada source
file containing preprocessor directives.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><em>outfile</em></dt><dd><p>is the full name of the output file, which is an Ada source
in standard Ada form. When used with GNAT, this file name will
normally have an <code class="docutils literal notranslate"><span class="pre">ads</span></code> or <code class="docutils literal notranslate"><span class="pre">adb</span></code> suffix.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">deffile</span></code></dt><dd><p>is the full name of a text file containing definitions of
preprocessing symbols to be referenced by the preprocessor. This argument is
optional, and can be replaced by the use of the <code class="switch docutils literal notranslate"><span class="pre">-D</span></code> switch.</p>
</dd>
</dl>
</li>
</ul>
</div>
<div class="section" id="switches-for-gnatprep">
<span id="id57"></span><h4><span class="section-number">3.10.2.3. </span>Switches for <code class="docutils literal notranslate"><span class="pre">gnatprep</span></code><a class="headerlink" href="#switches-for-gnatprep" title="Permalink to this headline">¶</a></h4>
<dl class="simple" id="index-89">
<dt><code class="switch docutils literal notranslate"><span class="pre">--version</span></code></dt><dd><p>Display Copyright and version, then exit disregarding all other options.</p>
</dd>
</dl>
<dl class="simple" id="index-90">
<dt><code class="switch docutils literal notranslate"><span class="pre">--help</span></code></dt><dd><p>If <code class="switch docutils literal notranslate"><span class="pre">--version</span></code> was not used, display usage and then exit disregarding
all other options.</p>
</dd>
</dl>
<dl class="simple" id="index-91">
<dt><code class="switch docutils literal notranslate"><span class="pre">-b</span></code></dt><dd><p>Causes both preprocessor lines and the lines deleted by
preprocessing to be replaced by blank lines in the output source file,
preserving line numbers in the output file.</p>
</dd>
</dl>
<dl class="simple" id="index-92">
<dt><code class="switch docutils literal notranslate"><span class="pre">-c</span></code></dt><dd><p>Causes both preprocessor lines and the lines deleted
by preprocessing to be retained in the output source as comments marked
with the special string <code class="docutils literal notranslate"><span class="pre">&quot;--!</span> <span class="pre">&quot;</span></code>. This option will result in line numbers
being preserved in the output file.</p>
</dd>
</dl>
<dl class="simple" id="index-93">
<dt><code class="switch docutils literal notranslate"><span class="pre">-C</span></code></dt><dd><p>Causes comments to be scanned. Normally comments are ignored by gnatprep.
If this option is specified, then comments are scanned and any $symbol
substitutions performed as in program text. This is particularly useful
when structured comments are used (e.g., for programs written in a
pre-2014 version of the SPARK Ada subset). Note that this switch is not
available when  doing integrated preprocessing (it would be useless in
this context since comments are ignored by the compiler in any case).</p>
</dd>
</dl>
<dl class="simple" id="index-94">
<dt><code class="switch docutils literal notranslate"><span class="pre">-D</span><em><span class="pre">symbol</span></em><span class="pre">[=</span><em><span class="pre">value</span></em><span class="pre">]</span></code></dt><dd><p>Defines a new preprocessing symbol with the specified value. If no value is given
on the command line, then symbol is considered to be <code class="docutils literal notranslate"><span class="pre">True</span></code>. This switch
can be used in place of a definition file.</p>
</dd>
</dl>
<dl id="index-95">
<dt><code class="switch docutils literal notranslate"><span class="pre">-r</span></code></dt><dd><p>Causes a <code class="docutils literal notranslate"><span class="pre">Source_Reference</span></code> pragma to be generated that
references the original input file, so that error messages will use
the file name of this original file. The use of this switch implies
that preprocessor lines are not to be removed from the file, so its
use will force <code class="docutils literal notranslate"><span class="pre">-b</span></code> mode if <code class="docutils literal notranslate"><span class="pre">-c</span></code>
has not been specified explicitly.</p>
<p>Note that if the file to be preprocessed contains multiple units, then
it will be necessary to <code class="docutils literal notranslate"><span class="pre">gnatchop</span></code> the output file from
<code class="docutils literal notranslate"><span class="pre">gnatprep</span></code>. If a <code class="docutils literal notranslate"><span class="pre">Source_Reference</span></code> pragma is present
in the preprocessed file, it will be respected by
<code class="docutils literal notranslate"><span class="pre">gnatchop</span> <span class="pre">-r</span></code>
so that the final chopped files will correctly refer to the original
input source file for <code class="docutils literal notranslate"><span class="pre">gnatprep</span></code>.</p>
</dd>
</dl>
<dl class="simple" id="index-96">
<dt><code class="switch docutils literal notranslate"><span class="pre">-s</span></code></dt><dd><p>Causes a sorted list of symbol names and values to be
listed on the standard output file.</p>
</dd>
</dl>
<dl class="simple" id="index-97">
<dt><code class="switch docutils literal notranslate"><span class="pre">-T</span></code></dt><dd><p>Use LF as line terminators when writing files. By default the line terminator
of the host (LF under unix, CR/LF under Windows) is used.</p>
</dd>
</dl>
<dl class="simple" id="index-98">
<dt><code class="switch docutils literal notranslate"><span class="pre">-u</span></code></dt><dd><p>Causes undefined symbols to be treated as having the value FALSE in the context
of a preprocessor test. In the absence of this option, an undefined symbol in
a <code class="docutils literal notranslate"><span class="pre">#if</span></code> or <code class="docutils literal notranslate"><span class="pre">#elsif</span></code> test will be treated as an error.</p>
</dd>
</dl>
<dl class="simple" id="index-99">
<dt><code class="switch docutils literal notranslate"><span class="pre">-v</span></code></dt><dd><p>Verbose mode: generates more output about work done.</p>
</dd>
</dl>
<p>Note: if neither <code class="switch docutils literal notranslate"><span class="pre">-b</span></code> nor <code class="switch docutils literal notranslate"><span class="pre">-c</span></code> is present,
then preprocessor lines and
deleted lines are completely removed from the output, unless -r is
specified, in which case -b is assumed.</p>
</div>
<div class="section" id="form-of-definitions-file">
<span id="id58"></span><h4><span class="section-number">3.10.2.4. </span>Form of Definitions File<a class="headerlink" href="#form-of-definitions-file" title="Permalink to this headline">¶</a></h4>
<p>The definitions file contains lines of the form:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">symbol</span> <span class="o">:=</span> <span class="n">value</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">symbol</span></code> is a preprocessing symbol, and <code class="docutils literal notranslate"><span class="pre">value</span></code> is one of the following:</p>
<ul class="simple">
<li><p>Empty, corresponding to a null substitution,</p></li>
<li><p>A string literal using normal Ada syntax, or</p></li>
<li><p>Any sequence of characters from the set {letters, digits, period, underline}.</p></li>
</ul>
<p>Comment lines may also appear in the definitions file, starting with
the usual <code class="docutils literal notranslate"><span class="pre">--</span></code>,
and comments may be added to the definitions lines.</p>
</div>
<div class="section" id="form-of-input-text-for-gnatprep">
<span id="id59"></span><h4><span class="section-number">3.10.2.5. </span>Form of Input Text for <code class="docutils literal notranslate"><span class="pre">gnatprep</span></code><a class="headerlink" href="#form-of-input-text-for-gnatprep" title="Permalink to this headline">¶</a></h4>
<p>The input text may contain preprocessor conditional inclusion lines,
as well as general symbol substitution sequences.</p>
<p>The preprocessor conditional inclusion commands have the form:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#if &lt;expression&gt; [then]</span>
   <span class="n">lines</span>
<span class="cp">#elsif &lt;expression&gt; [then]</span>
   <span class="n">lines</span>
<span class="cp">#elsif &lt;expression&gt; [then]</span>
   <span class="n">lines</span>
<span class="p">...</span>
<span class="cp">#else</span>
   <span class="n">lines</span>
<span class="cp">#end if;</span>
</pre></div>
</div>
<p>In this example, &lt;expression&gt; is defined by the following grammar:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">expression</span><span class="o">&gt;</span> <span class="p">:</span><span class="o">:=</span>  <span class="o">&lt;</span><span class="n">symbol</span><span class="o">&gt;</span>
<span class="o">&lt;</span><span class="n">expression</span><span class="o">&gt;</span> <span class="p">:</span><span class="o">:=</span>  <span class="o">&lt;</span><span class="n">symbol</span><span class="o">&gt;</span> <span class="o">=</span> <span class="s2">&quot;&lt;value&gt;&quot;</span>
<span class="o">&lt;</span><span class="n">expression</span><span class="o">&gt;</span> <span class="p">:</span><span class="o">:=</span>  <span class="o">&lt;</span><span class="n">symbol</span><span class="o">&gt;</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">symbol</span><span class="o">&gt;</span>
<span class="o">&lt;</span><span class="n">expression</span><span class="o">&gt;</span> <span class="p">:</span><span class="o">:=</span>  <span class="o">&lt;</span><span class="n">symbol</span><span class="o">&gt;</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">integer</span><span class="o">&gt;</span>
<span class="o">&lt;</span><span class="n">expression</span><span class="o">&gt;</span> <span class="p">:</span><span class="o">:=</span>  <span class="o">&lt;</span><span class="n">symbol</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">integer</span><span class="o">&gt;</span>
<span class="o">&lt;</span><span class="n">expression</span><span class="o">&gt;</span> <span class="p">:</span><span class="o">:=</span>  <span class="o">&lt;</span><span class="n">symbol</span><span class="o">&gt;</span> <span class="o">&gt;=</span> <span class="o">&lt;</span><span class="n">integer</span><span class="o">&gt;</span>
<span class="o">&lt;</span><span class="n">expression</span><span class="o">&gt;</span> <span class="p">:</span><span class="o">:=</span>  <span class="o">&lt;</span><span class="n">symbol</span><span class="o">&gt;</span> <span class="o">&lt;</span> <span class="o">&lt;</span><span class="n">integer</span><span class="o">&gt;</span>
<span class="o">&lt;</span><span class="n">expression</span><span class="o">&gt;</span> <span class="p">:</span><span class="o">:=</span>  <span class="o">&lt;</span><span class="n">symbol</span><span class="o">&gt;</span> <span class="o">&lt;=</span> <span class="o">&lt;</span><span class="n">integer</span><span class="o">&gt;</span>
<span class="o">&lt;</span><span class="n">expression</span><span class="o">&gt;</span> <span class="p">:</span><span class="o">:=</span>  <span class="o">&lt;</span><span class="n">symbol</span><span class="o">&gt;</span> <span class="s1">&#39;Defined</span>
<span class="o">&lt;</span><span class="n">expression</span><span class="o">&gt;</span> <span class="p">:</span><span class="o">:=</span>  <span class="ow">not</span> <span class="o">&lt;</span><span class="n">expression</span><span class="o">&gt;</span>
<span class="o">&lt;</span><span class="n">expression</span><span class="o">&gt;</span> <span class="p">:</span><span class="o">:=</span>  <span class="o">&lt;</span><span class="n">expression</span><span class="o">&gt;</span> <span class="ow">and</span> <span class="o">&lt;</span><span class="n">expression</span><span class="o">&gt;</span>
<span class="o">&lt;</span><span class="n">expression</span><span class="o">&gt;</span> <span class="p">:</span><span class="o">:=</span>  <span class="o">&lt;</span><span class="n">expression</span><span class="o">&gt;</span> <span class="ow">or</span> <span class="o">&lt;</span><span class="n">expression</span><span class="o">&gt;</span>
<span class="o">&lt;</span><span class="n">expression</span><span class="o">&gt;</span> <span class="p">:</span><span class="o">:=</span>  <span class="o">&lt;</span><span class="n">expression</span><span class="o">&gt;</span> <span class="ow">and</span> <span class="n">then</span> <span class="o">&lt;</span><span class="n">expression</span><span class="o">&gt;</span>
<span class="o">&lt;</span><span class="n">expression</span><span class="o">&gt;</span> <span class="p">:</span><span class="o">:=</span>  <span class="o">&lt;</span><span class="n">expression</span><span class="o">&gt;</span> <span class="ow">or</span> <span class="k">else</span> <span class="o">&lt;</span><span class="n">expression</span><span class="o">&gt;</span>
<span class="o">&lt;</span><span class="n">expression</span><span class="o">&gt;</span> <span class="p">:</span><span class="o">:=</span>  <span class="p">(</span> <span class="o">&lt;</span><span class="n">expression</span><span class="o">&gt;</span> <span class="p">)</span>
</pre></div>
</div>
<p>Note the following restriction: it is not allowed to have “and” or “or”
following “not” in the same expression without parentheses. For example, this
is not allowed:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">not</span><span class="p"> </span><span class="n">X</span> <span class="kr">or</span><span class="p"> </span><span class="n">Y</span>
</pre></div>
</div>
<p>This can be expressed instead as one of the following forms:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="o">(</span><span class="kr">not</span><span class="p"> </span><span class="n">X</span><span class="o">)</span> <span class="kr">or</span><span class="p"> </span><span class="n">Y</span>
<span class="kr">not</span><span class="p"> </span><span class="o">(</span><span class="n">X</span> <span class="kr">or</span><span class="p"> </span><span class="n">Y</span><span class="o">)</span>
</pre></div>
</div>
<p>For the first test (&lt;expression&gt; ::= &lt;symbol&gt;) the symbol must have
either the value true or false, that is to say the right-hand of the
symbol definition must be one of the (case-insensitive) literals
<code class="docutils literal notranslate"><span class="pre">True</span></code> or <code class="docutils literal notranslate"><span class="pre">False</span></code>. If the value is true, then the
corresponding lines are included, and if the value is false, they are
excluded.</p>
<p>When comparing a symbol to an integer, the integer is any non negative
literal integer as defined in the Ada Reference Manual, such as 3, 16#FF# or
2#11#. The symbol value must also be a non negative integer. Integer values
in the range 0 .. 2**31-1 are supported.</p>
<p>The test (&lt;expression&gt; ::= &lt;symbol&gt;’Defined) is true only if
the symbol has been defined in the definition file or by a <code class="switch docutils literal notranslate"><span class="pre">-D</span></code>
switch on the command line. Otherwise, the test is false.</p>
<p>The equality tests are case insensitive, as are all the preprocessor lines.</p>
<p>If the symbol referenced is not defined in the symbol definitions file,
then the effect depends on whether or not switch <code class="switch docutils literal notranslate"><span class="pre">-u</span></code>
is specified. If so, then the symbol is treated as if it had the value
false and the test fails. If this switch is not specified, then
it is an error to reference an undefined symbol. It is also an error to
reference a symbol that is defined with a value other than <code class="docutils literal notranslate"><span class="pre">True</span></code>
or <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
<p>The use of the <code class="docutils literal notranslate"><span class="pre">not</span></code> operator inverts the sense of this logical test.
The <code class="docutils literal notranslate"><span class="pre">not</span></code> operator cannot be combined with the <code class="docutils literal notranslate"><span class="pre">or</span></code> or <code class="docutils literal notranslate"><span class="pre">and</span></code>
operators, without parentheses. For example, “if not X or Y then” is not
allowed, but “if (not X) or Y then” and “if not (X or Y) then” are.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">then</span></code> keyword is optional as shown</p>
<p>The <code class="docutils literal notranslate"><span class="pre">#</span></code> must be the first non-blank character on a line, but
otherwise the format is free form. Spaces or tabs may appear between
the <code class="docutils literal notranslate"><span class="pre">#</span></code> and the keyword. The keywords and the symbols are case
insensitive as in normal Ada code. Comments may be used on a
preprocessor line, but other than that, no other tokens may appear on a
preprocessor line. Any number of <code class="docutils literal notranslate"><span class="pre">elsif</span></code> clauses can be present,
including none at all. The <code class="docutils literal notranslate"><span class="pre">else</span></code> is optional, as in Ada.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">#</span></code> marking the start of a preprocessor line must be the first
non-blank character on the line, i.e., it must be preceded only by
spaces or horizontal tabs.</p>
<p>Symbol substitution outside of preprocessor lines is obtained by using
the sequence:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$symbol
</pre></div>
</div>
<p>anywhere within a source line, except in a comment or within a
string literal. The identifier
following the <code class="docutils literal notranslate"><span class="pre">$</span></code> must match one of the symbols defined in the symbol
definition file, and the result is to substitute the value of the
symbol in place of <code class="docutils literal notranslate"><span class="pre">$symbol</span></code> in the output file.</p>
<p>Note that although the substitution of strings within a string literal
is not possible, it is possible to have a symbol whose defined value is
a string literal. So instead of setting XYZ to <code class="docutils literal notranslate"><span class="pre">hello</span></code> and writing:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="n">Header</span> <span class="o">:</span> <span class="n">String</span> <span class="o">:=</span> <span class="s">&quot;$XYZ&quot;</span><span class="p">;</span>
</pre></div>
</div>
<p>you should set XYZ to <code class="docutils literal notranslate"><span class="pre">&quot;hello&quot;</span></code> and write:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="n">Header</span> <span class="o">:</span> <span class="n">String</span> <span class="o">:=</span> $<span class="n">XYZ</span><span class="p">;</span>
</pre></div>
</div>
<p>and then the substitution will occur as desired.</p>
</div>
</div>
<div class="section" id="integrated-preprocessing">
<span id="id60"></span><h3><span class="section-number">3.10.3. </span>Integrated Preprocessing<a class="headerlink" href="#integrated-preprocessing" title="Permalink to this headline">¶</a></h3>
<p>As noted above, a file to be preprocessed consists of Ada source code
in which preprocessing lines have been inserted. However,
instead of using <code class="docutils literal notranslate"><span class="pre">gnatprep</span></code> to explicitly preprocess a file as a separate
step before compilation, you can carry out the preprocessing implicitly
as part of compilation. Such <em>integrated preprocessing</em>, which is the common
style with C, is performed when either or both of the following switches
are passed to the compiler:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="switch docutils literal notranslate"><span class="pre">-gnatep</span></code>, which specifies the <em>preprocessor data file</em>.
This file dictates how the source files will be preprocessed (e.g., which
symbol definition files apply to which sources).</p></li>
<li><p><code class="switch docutils literal notranslate"><span class="pre">-gnateD</span></code>, which defines values for preprocessing symbols.</p></li>
</ul>
</div></blockquote>
<p>Integrated preprocessing applies only to Ada source files, it is
not available for configuration pragma files.</p>
<p>With integrated preprocessing, the output from the preprocessor is not,
by default, written to any external file. Instead it is passed
internally to the compiler. To preserve the result of
preprocessing in a file, either run <code class="docutils literal notranslate"><span class="pre">gnatprep</span></code>
in standalone mode or else supply the <code class="switch docutils literal notranslate"><span class="pre">-gnateG</span></code> switch
(described below) to the compiler.</p>
<p>When using project files:</p>
<blockquote>
<div><ul class="simple">
<li><p>the builder switch <code class="switch docutils literal notranslate"><span class="pre">-x</span></code> should be used if any Ada source is
compiled with <code class="switch docutils literal notranslate"><span class="pre">gnatep=</span></code>, so that the compiler finds the
<em>preprocessor data file</em>.</p></li>
<li><p>the preprocessing data file and the symbol definition files should be
located in the source directories of the project.</p></li>
</ul>
</div></blockquote>
<p>Note that the <code class="docutils literal notranslate"><span class="pre">gnatmake</span></code> switch <code class="switch docutils literal notranslate"><span class="pre">-m</span></code> will almost
always trigger recompilation for sources that are preprocessed,
because <code class="docutils literal notranslate"><span class="pre">gnatmake</span></code> cannot compute the checksum of the source after
preprocessing.</p>
<p>The actual preprocessing function is described in detail in
<a class="reference internal" href="#preprocessing-with-gnatprep"><span class="std std-ref">Preprocessing with gnatprep</span></a>. This section explains the switches
that relate to integrated preprocessing.</p>
<dl id="index-100">
<dt><code class="switch docutils literal notranslate"><span class="pre">-gnatep=</span><em><span class="pre">preprocessor_data_file</span></em></code></dt><dd><p>This switch specifies the file name (without directory
information) of the preprocessor data file. Either place this file
in one of the source directories, or, when using project
files, reference the project file’s directory via the
<code class="docutils literal notranslate"><span class="pre">project_name'Project_Dir</span></code> project attribute; e.g:</p>
<blockquote>
<div><div class="highlight-gpr notranslate"><div class="highlight"><pre><span></span><span class="k">project </span><span class="nf">Prj</span> <span class="kr">is</span><span class="p"></span>
   <span class="k">package </span><span class="nf">Compiler</span> <span class="kr">is</span><span class="p"></span>
      <span class="kr">for</span><span class="p"> </span><span class="n">Switches</span> <span class="o">(</span><span class="s">&quot;Ada&quot;</span><span class="o">)</span> <span class="kr">use</span><span class="p"></span>
        <span class="o">(</span><span class="s">&quot;-gnatep=&quot;</span> <span class="o">&amp;</span> <span class="n">Prj</span><span class="o">&#39;</span><span class="n">Project_Dir</span> <span class="o">&amp;</span> <span class="s">&quot;prep.def&quot;</span><span class="o">)</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">Compiler</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Prj</span><span class="p">;</span>
</pre></div>
</div>
</div></blockquote>
<p>A preprocessor data file is a text file that contains <em>preprocessor
control lines</em>.  A preprocessor control line directs the preprocessing of
either a particular source file, or, analogous to <code class="docutils literal notranslate"><span class="pre">others</span></code> in Ada,
all sources not specified elsewhere in  the preprocessor data file.
A preprocessor control line
can optionally identify a <em>definition file</em> that assigns values to
preprocessor symbols, as well as a list of switches that relate to
preprocessing.
Empty lines and comments (using Ada syntax) are also permitted, with no
semantic effect.</p>
<p>Here’s an example of a preprocessor data file:</p>
<blockquote>
<div><div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="s">&quot;toto.adb&quot;</span>  <span class="s">&quot;prep.def&quot;</span> <span class="o">-</span><span class="n">u</span>
<span class="c">--  Preprocess toto.adb, using definition file prep.def</span>
<span class="c">--  Undefined symbols are treated as False</span>

<span class="o">*</span> <span class="o">-</span><span class="n">c</span> <span class="o">-</span><span class="n">DVERSION</span><span class="o">=</span><span class="n">V101</span>
<span class="c">--  Preprocess all other sources without using a definition file</span>
<span class="c">--  Suppressed lined are commented</span>
<span class="c">--  Symbol VERSION has the value V101</span>

<span class="s">&quot;tata.adb&quot;</span> <span class="s">&quot;prep2.def&quot;</span> <span class="o">-</span><span class="n">s</span>
<span class="c">--  Preprocess tata.adb, using definition file prep2.def</span>
<span class="c">--  List all symbols with their values</span>
</pre></div>
</div>
</div></blockquote>
<p>A preprocessor control line has the following syntax:</p>
<blockquote>
<div><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">preprocessor_control_line</span><span class="o">&gt;</span> <span class="p">:</span><span class="o">:=</span>
   <span class="o">&lt;</span><span class="n">preprocessor_input</span><span class="o">&gt;</span> <span class="p">[</span> <span class="o">&lt;</span><span class="n">definition_file_name</span><span class="o">&gt;</span> <span class="p">]</span> <span class="p">{</span> <span class="o">&lt;</span><span class="n">switch</span><span class="o">&gt;</span> <span class="p">}</span>

<span class="o">&lt;</span><span class="n">preprocessor_input</span><span class="o">&gt;</span> <span class="p">:</span><span class="o">:=</span> <span class="o">&lt;</span><span class="n">source_file_name</span><span class="o">&gt;</span> <span class="o">|</span> <span class="s1">&#39;*&#39;</span>

<span class="o">&lt;</span><span class="n">definition_file_name</span><span class="o">&gt;</span> <span class="p">:</span><span class="o">:=</span> <span class="o">&lt;</span><span class="n">string_literal</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">source_file_name</span><span class="o">&gt;</span> <span class="o">:=</span> <span class="o">&lt;</span><span class="n">string_literal</span><span class="o">&gt;</span>

<span class="o">&lt;</span><span class="n">switch</span><span class="o">&gt;</span> <span class="o">:=</span> <span class="p">(</span><span class="n">See</span> <span class="n">below</span> <span class="k">for</span> <span class="nb">list</span><span class="p">)</span>
</pre></div>
</div>
</div></blockquote>
<p>Thus  each preprocessor control line starts with either a literal string or
the character ‘*’:</p>
<ul class="simple">
<li><p>A literal string is the file name (without directory information) of the source
file that will be input to the preprocessor.</p></li>
<li><p>The character ‘*’ is a wild-card indicator; the additional parameters on the line
indicate the preprocessing for all the sources
that are not specified explicitly on other lines (the order of the lines is not
significant).</p></li>
</ul>
<p>It is an error to have two lines with the same file name or two
lines starting with the character ‘*’.</p>
<p>After the file name or ‘*’, an optional literal string specifies the name of
the definition file to be used for preprocessing
(<a class="reference internal" href="#form-of-definitions-file"><span class="std std-ref">Form of Definitions File</span></a>). The definition files are found by the
compiler in one of the source directories. In some cases, when compiling
a source in a directory other than the current directory, if the definition
file is in the current directory, it may be necessary to add the current
directory as a source directory through the <code class="switch docutils literal notranslate"><span class="pre">-I</span></code> switch; otherwise
the compiler would not find the definition file.</p>
<p>Finally, switches similar to those of <code class="docutils literal notranslate"><span class="pre">gnatprep</span></code> may optionally appear:</p>
<dl class="simple">
<dt><code class="switch docutils literal notranslate"><span class="pre">-b</span></code></dt><dd><p>Causes both preprocessor lines and the lines deleted by
preprocessing to be replaced by blank lines, preserving the line number.
This switch is always implied; however, if specified after <code class="switch docutils literal notranslate"><span class="pre">-c</span></code>
it cancels the effect of <code class="switch docutils literal notranslate"><span class="pre">-c</span></code>.</p>
</dd>
<dt><code class="switch docutils literal notranslate"><span class="pre">-c</span></code></dt><dd><p>Causes both preprocessor lines and the lines deleted
by preprocessing to be retained as comments marked
with the special string ‘<cite>–!</cite>’.</p>
</dd>
<dt><code class="switch docutils literal notranslate"><span class="pre">-D</span><em><span class="pre">symbol</span></em><span class="pre">=</span><em><span class="pre">new_value</span></em></code></dt><dd><p>Define or redefine <code class="docutils literal notranslate"><span class="pre">symbol</span></code> to have <code class="docutils literal notranslate"><span class="pre">new_value</span></code> as its value.
The permitted form for <code class="docutils literal notranslate"><span class="pre">symbol</span></code> is either an Ada identifier, or any Ada reserved word
aside from <code class="docutils literal notranslate"><span class="pre">if</span></code>,
<code class="docutils literal notranslate"><span class="pre">else</span></code>, <code class="docutils literal notranslate"><span class="pre">elsif</span></code>, <code class="docutils literal notranslate"><span class="pre">end</span></code>, <code class="docutils literal notranslate"><span class="pre">and</span></code>, <code class="docutils literal notranslate"><span class="pre">or</span></code> and <code class="docutils literal notranslate"><span class="pre">then</span></code>.
The permitted form for <code class="docutils literal notranslate"><span class="pre">new_value</span></code> is a literal string, an Ada identifier or any Ada reserved
word. A symbol declared with this switch replaces a symbol with the
same name defined in a definition file.</p>
</dd>
<dt><code class="switch docutils literal notranslate"><span class="pre">-s</span></code></dt><dd><p>Causes a sorted list of symbol names and values to be
listed on the standard output file.</p>
</dd>
<dt><code class="switch docutils literal notranslate"><span class="pre">-u</span></code></dt><dd><p>Causes undefined symbols to be treated as having the value <code class="docutils literal notranslate"><span class="pre">FALSE</span></code>
in the context
of a preprocessor test. In the absence of this option, an undefined symbol in
a <code class="docutils literal notranslate"><span class="pre">#if</span></code> or <code class="docutils literal notranslate"><span class="pre">#elsif</span></code> test will be treated as an error.</p>
</dd>
</dl>
</dd>
</dl>
<dl id="index-101">
<dt><code class="switch docutils literal notranslate"><span class="pre">-gnateD</span><em><span class="pre">symbol</span></em><span class="pre">[=</span><em><span class="pre">new_value</span></em><span class="pre">]</span></code></dt><dd><p>Define or redefine <code class="docutils literal notranslate"><span class="pre">symbol</span></code> to have <code class="docutils literal notranslate"><span class="pre">new_value</span></code> as its value. If no value
is supplied, then the value of <code class="docutils literal notranslate"><span class="pre">symbol</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code>.
The form of <code class="docutils literal notranslate"><span class="pre">symbol</span></code> is an identifier, following normal Ada (case-insensitive)
rules for its syntax, and <code class="docutils literal notranslate"><span class="pre">new_value</span></code> is either an arbitrary string between double
quotes or any sequence (including an empty sequence) of characters from the
set (letters, digits, period, underline).
Ada reserved words may be used as symbols, with the exceptions of <code class="docutils literal notranslate"><span class="pre">if</span></code>,
<code class="docutils literal notranslate"><span class="pre">else</span></code>, <code class="docutils literal notranslate"><span class="pre">elsif</span></code>, <code class="docutils literal notranslate"><span class="pre">end</span></code>, <code class="docutils literal notranslate"><span class="pre">and</span></code>, <code class="docutils literal notranslate"><span class="pre">or</span></code> and <code class="docutils literal notranslate"><span class="pre">then</span></code>.</p>
<p>Examples:</p>
<blockquote>
<div><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">-</span><span class="n">gnateDToto</span><span class="o">=</span><span class="n">Tata</span>
<span class="o">-</span><span class="n">gnateDFoo</span>
<span class="o">-</span><span class="n">gnateDFoo</span><span class="o">=</span>\<span class="s2">&quot;Foo-Bar</span><span class="se">\&quot;</span>
</pre></div>
</div>
</div></blockquote>
<p>A symbol declared with this switch on the command line replaces a
symbol with the same name either in a definition file or specified with a
switch <code class="switch docutils literal notranslate"><span class="pre">-D</span></code> in the preprocessor data file.</p>
<p>This switch is similar to switch <code class="switch docutils literal notranslate"><span class="pre">-D</span></code> of <code class="docutils literal notranslate"><span class="pre">gnatprep</span></code>.</p>
</dd>
<dt><code class="switch docutils literal notranslate"><span class="pre">-gnateG</span></code></dt><dd><p>When integrated preprocessing is performed on source file <code class="file docutils literal notranslate"><span class="pre">filename.extension</span></code>,
create or overwrite <code class="file docutils literal notranslate"><span class="pre">filename.extension.prep</span></code> to contain
the result of the preprocessing.
For example if the source file is <code class="file docutils literal notranslate"><span class="pre">foo.adb</span></code> then
the output file will be <code class="file docutils literal notranslate"><span class="pre">foo.adb.prep</span></code>.</p>
</dd>
</dl>
</div>
</div>
<div class="section" id="mixed-language-programming">
<span id="id61"></span><h2><span class="section-number">3.11. </span>Mixed Language Programming<a class="headerlink" href="#mixed-language-programming" title="Permalink to this headline">¶</a></h2>
<p id="index-102">This section describes how to develop a mixed-language program,
with a focus on combining Ada with C or C++.</p>
<div class="section" id="interfacing-to-c">
<span id="id62"></span><h3><span class="section-number">3.11.1. </span>Interfacing to C<a class="headerlink" href="#interfacing-to-c" title="Permalink to this headline">¶</a></h3>
<p>Interfacing Ada with a foreign language such as C involves using
compiler directives to import and/or export entity definitions in each
language – using <code class="docutils literal notranslate"><span class="pre">extern</span></code> statements in C, for instance, and the
<code class="docutils literal notranslate"><span class="pre">Import</span></code>, <code class="docutils literal notranslate"><span class="pre">Export</span></code>, and <code class="docutils literal notranslate"><span class="pre">Convention</span></code> pragmas in Ada.
A full treatment of these topics is provided in Appendix B, section 1
of the Ada Reference Manual.</p>
<p>There are two ways to build a program using GNAT that contains some Ada
sources and some foreign language sources, depending on whether or not
the main subprogram is written in Ada.  Here is a source example with
the main subprogram in Ada:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/* file1.c */</span>
<span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>

<span class="kt">void</span> <span class="nf">print_num</span> <span class="p">(</span><span class="kt">int</span> <span class="n">num</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">printf</span> <span class="p">(</span><span class="s">&quot;num is %d.</span><span class="se">\\</span><span class="s">n&quot;</span><span class="p">,</span> <span class="n">num</span><span class="p">);</span>
  <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/* file2.c */</span>

<span class="cm">/* num_from_Ada is declared in my_main.adb */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">num_from_Ada</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">get_num</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">num_from_Ada</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="c">--  my_main.adb</span>
<span class="k">procedure </span><span class="nf">My_Main</span> <span class="kr">is</span><span class="p"></span>

   <span class="c">--  Declare then export an Integer entity called num_from_Ada</span>
   <span class="n">My_Num</span> <span class="o">:</span> <span class="n">Integer</span> <span class="o">:=</span> <span class="mi">10</span><span class="p">;</span>
   <span class="kr">pragma</span><span class="p"> </span><span class="n">Export</span> <span class="o">(</span><span class="n">C</span><span class="p">,</span> <span class="n">My_Num</span><span class="p">,</span> <span class="s">&quot;num_from_Ada&quot;</span><span class="o">)</span><span class="p">;</span>

   <span class="c">--  Declare an Ada function spec for Get_Num, then use</span>
   <span class="c">--  C function get_num for the implementation.</span>
   <span class="k">function </span><span class="nf">Get_Num</span> <span class="kr">return</span><span class="p"> </span><span class="n">Integer</span><span class="p">;</span>
   <span class="kr">pragma</span><span class="p"> </span><span class="n">Import</span> <span class="o">(</span><span class="n">C</span><span class="p">,</span> <span class="n">Get_Num</span><span class="p">,</span> <span class="s">&quot;get_num&quot;</span><span class="o">)</span><span class="p">;</span>

   <span class="c">--  Declare an Ada procedure spec for Print_Num, then use</span>
   <span class="c">--  C function print_num for the implementation.</span>
   <span class="k">procedure </span><span class="nf">Print_Num</span> <span class="o">(</span><span class="n">Num</span> <span class="o">:</span> <span class="n">Integer</span><span class="o">)</span><span class="p">;</span>
   <span class="kr">pragma</span><span class="p"> </span><span class="n">Import</span> <span class="o">(</span><span class="n">C</span><span class="p">,</span> <span class="n">Print_Num</span><span class="p">,</span> <span class="s">&quot;print_num&quot;</span><span class="o">)</span><span class="p">;</span>

<span class="kr">begin</span><span class="p"></span>
   <span class="n">Print_Num</span> <span class="o">(</span><span class="n">Get_Num</span><span class="o">)</span><span class="p">;</span>
<span class="k">end </span><span class="nf">My_Main</span><span class="p">;</span>
</pre></div>
</div>
<p>To build this example:</p>
<ul>
<li><p>First compile the foreign language files to
generate object files:</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>$ gcc -c file1.c
$ gcc -c file2.c
</pre></div>
</div>
</li>
<li><p>Then, compile the Ada units to produce a set of object files and ALI
files:</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>$ gnatmake -c my_main.adb
</pre></div>
</div>
</li>
<li><p>Run the Ada binder on the Ada main program:</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>$ gnatbind my_main.ali
</pre></div>
</div>
</li>
<li><p>Link the Ada main program, the Ada objects and the other language
objects:</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>$ gnatlink my_main.ali file1.o file2.o
</pre></div>
</div>
</li>
</ul>
<p>The last three steps can be grouped in a single command:</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>$ gnatmake my_main.adb -largs file1.o file2.o
</pre></div>
</div>
<p id="index-103">If the main program is in a language other than Ada, then you may have
more than one entry point into the Ada subsystem. You must use a special
binder option to generate callable routines that initialize and
finalize the Ada units (<a class="reference internal" href="building_executable_programs_with_gnat.html#binding-with-non-ada-main-programs"><span class="std std-ref">Binding with Non-Ada Main Programs</span></a>).
Calls to the initialization and finalization routines must be inserted
in the main program, or some other appropriate point in the code. The
call to initialize the Ada units must occur before the first Ada
subprogram is called, and the call to finalize the Ada units must occur
after the last Ada subprogram returns. The binder will place the
initialization and finalization subprograms into the
<code class="file docutils literal notranslate"><span class="pre">b~xxx.adb</span></code> file where they can be accessed by your C
sources.  To illustrate, we have the following example:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/* main.c */</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="nf">adainit</span> <span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="nf">adafinal</span> <span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="nf">add</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="nf">sub</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">main</span> <span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
   <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">21</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>

   <span class="n">adainit</span><span class="p">();</span>

   <span class="cm">/* Should print &quot;21 + 7 = 28&quot; */</span>
   <span class="n">printf</span> <span class="p">(</span><span class="s">&quot;%d + %d = %d</span><span class="se">\\</span><span class="s">n&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">add</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">));</span>

   <span class="cm">/* Should print &quot;21 - 7 = 14&quot; */</span>
   <span class="n">printf</span> <span class="p">(</span><span class="s">&quot;%d - %d = %d</span><span class="se">\\</span><span class="s">n&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">sub</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">));</span>

   <span class="n">adafinal</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="c">--  unit1.ads</span>
<span class="k">package </span><span class="nf">Unit1</span> <span class="kr">is</span><span class="p"></span>
   <span class="k">function </span><span class="nf">Add</span> <span class="o">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span> <span class="o">:</span> <span class="n">Integer</span><span class="o">)</span> <span class="kr">return</span><span class="p"> </span><span class="n">Integer</span><span class="p">;</span>
   <span class="kr">pragma</span><span class="p"> </span><span class="n">Export</span> <span class="o">(</span><span class="n">C</span><span class="p">,</span> <span class="n">Add</span><span class="p">,</span> <span class="s">&quot;add&quot;</span><span class="o">)</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Unit1</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="c">--  unit1.adb</span>
<span class="k">package body </span><span class="nf">Unit1</span> <span class="kr">is</span><span class="p"></span>
   <span class="k">function </span><span class="nf">Add</span> <span class="o">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span> <span class="o">:</span> <span class="n">Integer</span><span class="o">)</span> <span class="kr">return</span><span class="p"> </span><span class="n">Integer</span> <span class="kr">is</span><span class="p"></span>
   <span class="kr">begin</span><span class="p"></span>
      <span class="kr">return</span><span class="p"> </span><span class="n">A</span> <span class="o">+</span> <span class="n">B</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">Add</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Unit1</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="c">--  unit2.ads</span>
<span class="k">package </span><span class="nf">Unit2</span> <span class="kr">is</span><span class="p"></span>
   <span class="k">function </span><span class="nf">Sub</span> <span class="o">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span> <span class="o">:</span> <span class="n">Integer</span><span class="o">)</span> <span class="kr">return</span><span class="p"> </span><span class="n">Integer</span><span class="p">;</span>
   <span class="kr">pragma</span><span class="p"> </span><span class="n">Export</span> <span class="o">(</span><span class="n">C</span><span class="p">,</span> <span class="n">Sub</span><span class="p">,</span> <span class="s">&quot;sub&quot;</span><span class="o">)</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Unit2</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="c">--  unit2.adb</span>
<span class="k">package body </span><span class="nf">Unit2</span> <span class="kr">is</span><span class="p"></span>
   <span class="k">function </span><span class="nf">Sub</span> <span class="o">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span> <span class="o">:</span> <span class="n">Integer</span><span class="o">)</span> <span class="kr">return</span><span class="p"> </span><span class="n">Integer</span> <span class="kr">is</span><span class="p"></span>
   <span class="kr">begin</span><span class="p"></span>
      <span class="kr">return</span><span class="p"> </span><span class="n">A</span> <span class="o">-</span> <span class="n">B</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">Sub</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Unit2</span><span class="p">;</span>
</pre></div>
</div>
<p>The build procedure for this application is similar to the last
example’s:</p>
<ul>
<li><p>First, compile the foreign language files to generate object files:</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>$ gcc -c main.c
</pre></div>
</div>
</li>
<li><p>Next, compile the Ada units to produce a set of object files and ALI
files:</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>$ gnatmake -c unit1.adb
$ gnatmake -c unit2.adb
</pre></div>
</div>
</li>
<li><p>Run the Ada binder on every generated ALI file.  Make sure to use the
<code class="switch docutils literal notranslate"><span class="pre">-n</span></code> option to specify a foreign main program:</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>$ gnatbind -n unit1.ali unit2.ali
</pre></div>
</div>
</li>
<li><p>Link the Ada main program, the Ada objects and the foreign language
objects. You need only list the last ALI file here:</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>$ gnatlink unit2.ali main.o -o exec_file
</pre></div>
</div>
<p>This procedure yields a binary executable called <code class="file docutils literal notranslate"><span class="pre">exec_file</span></code>.</p>
</li>
</ul>
<p>Depending on the circumstances (for example when your non-Ada main object
does not provide symbol <code class="docutils literal notranslate"><span class="pre">main</span></code>), you may also need to instruct the
GNAT linker not to include the standard startup objects by passing the
<code class="switch docutils literal notranslate"><span class="pre">-nostartfiles</span></code> switch to <code class="docutils literal notranslate"><span class="pre">gnatlink</span></code>.</p>
</div>
<div class="section" id="calling-conventions">
<span id="id63"></span><h3><span class="section-number">3.11.2. </span>Calling Conventions<a class="headerlink" href="#calling-conventions" title="Permalink to this headline">¶</a></h3>
<span class="target" id="index-104"></span><p id="index-105">GNAT follows standard calling sequence conventions and will thus interface
to any other language that also follows these conventions. The following
Convention identifiers are recognized by GNAT:</p>
<span class="target" id="index-106"></span><span class="target" id="index-107"></span><dl id="index-108">
<dt><code class="docutils literal notranslate"><span class="pre">Ada</span></code></dt><dd><p>This indicates that the standard Ada calling sequence will be
used and all Ada data items may be passed without any limitations in the
case where GNAT is used to generate both the caller and callee. It is also
possible to mix GNAT generated code and code generated by another Ada
compiler. In this case, the data types should be restricted to simple
cases, including primitive types. Whether complex data types can be passed
depends on the situation. Probably it is safe to pass simple arrays, such
as arrays of integers or floats. Records may or may not work, depending
on whether both compilers lay them out identically. Complex structures
involving variant records, access parameters, tasks, or protected types,
are unlikely to be able to be passed.</p>
<p>Note that in the case of GNAT running
on a platform that supports HP Ada 83, a higher degree of compatibility
can be guaranteed, and in particular records are laid out in an identical
manner in the two compilers. Note also that if output from two different
compilers is mixed, the program is responsible for dealing with elaboration
issues. Probably the safest approach is to write the main program in the
version of Ada other than GNAT, so that it takes care of its own elaboration
requirements, and then call the GNAT-generated adainit procedure to ensure
elaboration of the GNAT components. Consult the documentation of the other
Ada compiler for further details on elaboration.</p>
<p>However, it is not possible to mix the tasking run time of GNAT and
HP Ada 83, All the tasking operations must either be entirely within
GNAT compiled sections of the program, or entirely within HP Ada 83
compiled sections of the program.</p>
</dd>
</dl>
<span class="target" id="index-109"></span><dl class="simple" id="index-110">
<dt><code class="docutils literal notranslate"><span class="pre">Assembler</span></code></dt><dd><p>Specifies assembler as the convention. In practice this has the
same effect as convention Ada (but is not equivalent in the sense of being
considered the same convention).</p>
</dd>
</dl>
<span class="target" id="index-111"></span><dl id="index-112">
<dt><code class="docutils literal notranslate"><span class="pre">Asm</span></code></dt><dd><p>Equivalent to Assembler.</p>
<span class="target" id="index-113"></span><span class="target" id="index-114"></span></dd>
</dl>
<dl class="simple" id="index-115">
<dt><code class="docutils literal notranslate"><span class="pre">COBOL</span></code></dt><dd><p>Data will be passed according to the conventions described
in section B.4 of the Ada Reference Manual.</p>
</dd>
</dl>
<span class="target" id="index-116"></span><span class="target" id="index-117"></span><dl id="index-118">
<dt><code class="docutils literal notranslate"><span class="pre">C</span></code></dt><dd><p>Data will be passed according to the conventions described
in section B.3 of the Ada Reference Manual.</p>
<p>A note on interfacing to a C ‘varargs’ function:</p>
<blockquote>
<div><span class="target" id="index-119"></span><span class="target" id="index-120"></span><p id="index-121">In C, <code class="docutils literal notranslate"><span class="pre">varargs</span></code> allows a function to take a variable number of
arguments. There is no direct equivalent in this to Ada. One
approach that can be used is to create a C wrapper for each
different profile and then interface to this C wrapper. For
example, to print an <code class="docutils literal notranslate"><span class="pre">int</span></code> value using <code class="docutils literal notranslate"><span class="pre">printf</span></code>,
create a C function <code class="docutils literal notranslate"><span class="pre">printfi</span></code> that takes two arguments, a
pointer to a string and an int, and calls <code class="docutils literal notranslate"><span class="pre">printf</span></code>.
Then in the Ada program, use pragma <code class="docutils literal notranslate"><span class="pre">Import</span></code> to
interface to <code class="docutils literal notranslate"><span class="pre">printfi</span></code>.</p>
<p>It may work on some platforms to directly interface to
a <code class="docutils literal notranslate"><span class="pre">varargs</span></code> function by providing a specific Ada profile
for a particular call. However, this does not work on
all platforms, since there is no guarantee that the
calling sequence for a two argument normal C function
is the same as for calling a <code class="docutils literal notranslate"><span class="pre">varargs</span></code> C function with
the same two arguments.</p>
</div></blockquote>
</dd>
</dl>
<span class="target" id="index-122"></span><dl class="simple" id="index-123">
<dt><code class="docutils literal notranslate"><span class="pre">Default</span></code></dt><dd><p>Equivalent to C.</p>
</dd>
</dl>
<span class="target" id="index-124"></span><dl class="simple" id="index-125">
<dt><code class="docutils literal notranslate"><span class="pre">External</span></code></dt><dd><p>Equivalent to C.</p>
</dd>
</dl>
<span class="target" id="index-126"></span><span class="target" id="index-127"></span><dl class="simple" id="index-128">
<dt><code class="docutils literal notranslate"><span class="pre">C_Plus_Plus</span></code> (or <code class="docutils literal notranslate"><span class="pre">CPP</span></code>)</dt><dd><p>This stands for C++. For most purposes this is identical to C.
See the separate description of the specialized GNAT pragmas relating to
C++ interfacing for further details.</p>
</dd>
</dl>
<span class="target" id="index-129"></span><span class="target" id="index-130"></span><dl id="index-131">
<dt><code class="docutils literal notranslate"><span class="pre">Fortran</span></code></dt><dd><p>Data will be passed according to the conventions described
in section B.5 of the Ada Reference Manual.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">Intrinsic</span></code></dt><dd><p>This applies to an intrinsic operation, as defined in the Ada
Reference Manual. If a pragma Import (Intrinsic) applies to a subprogram,
this means that the body of the subprogram is provided by the compiler itself,
usually by means of an efficient code sequence, and that the user does not
supply an explicit body for it. In an application program, the pragma may
be applied to the following sets of names:</p>
<ul class="simple">
<li><p>Rotate_Left, Rotate_Right, Shift_Left, Shift_Right, Shift_Right_Arithmetic.
The corresponding subprogram declaration must have
two formal parameters. The
first one must be a signed integer type or a modular type with a binary
modulus, and the second parameter must be of type Natural.
The return type must be the same as the type of the first argument. The size
of this type can only be 8, 16, 32, or 64.</p></li>
<li><p>Binary arithmetic operators: ‘+’, ‘-‘, ‘*’, ‘/’.
The corresponding operator declaration must have parameters and result type
that have the same root numeric type (for example, all three are long_float
types). This simplifies the definition of operations that use type checking
to perform dimensional checks:</p></li>
</ul>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span>  <span class="kr">type</span><span class="p"> </span><span class="n">Distance</span> <span class="kr">is</span><span class="p"> </span><span class="kr">new</span><span class="p"> </span><span class="n">Long_Float</span><span class="p">;</span>
  <span class="kr">type</span><span class="p"> </span><span class="n">Time</span>     <span class="kr">is</span><span class="p"> </span><span class="kr">new</span><span class="p"> </span><span class="n">Long_Float</span><span class="p">;</span>
  <span class="kr">type</span><span class="p"> </span><span class="n">Velocity</span> <span class="kr">is</span><span class="p"> </span><span class="kr">new</span><span class="p"> </span><span class="n">Long_Float</span><span class="p">;</span>
  <span class="kr">function</span><span class="p"> </span><span class="s">&quot;/&quot;</span> <span class="o">(</span><span class="n">D</span> <span class="o">:</span> <span class="n">Distance</span><span class="p">;</span> <span class="n">T</span> <span class="o">:</span> <span class="n">Time</span><span class="o">)</span>
    <span class="kr">return</span><span class="p"> </span><span class="n">Velocity</span><span class="p">;</span>
  <span class="kr">pragma</span><span class="p"> </span><span class="n">Import</span> <span class="o">(</span><span class="n">Intrinsic</span><span class="p">,</span> <span class="s">&quot;/&quot;</span><span class="o">)</span><span class="p">;</span>

<span class="n">This</span> <span class="n">common</span> <span class="n">idiom</span> <span class="kr">is</span><span class="p"> </span><span class="n">often</span> <span class="n">programmed</span> <span class="kr">with</span><span class="p"> </span><span class="n">a</span> <span class="kr">generic</span><span class="p"> </span><span class="n">definition</span> <span class="kr">and</span><span class="p"> </span><span class="n">an</span>
<span class="n">explicit</span> <span class="n">body.</span> <span class="n">The</span> <span class="kr">pragma</span><span class="p"> </span><span class="n">makes</span> <span class="n">it</span> <span class="n">simpler</span> <span class="n">to</span> <span class="n">introduce</span> <span class="n">such</span> <span class="n">declarations.</span>
<span class="n">It</span> <span class="n">incurs</span> <span class="n">no</span> <span class="n">overhead</span> <span class="kr">in</span><span class="p"> </span><span class="n">compilation</span> <span class="n">time</span> <span class="kr">or</span><span class="p"> </span><span class="n">code</span> <span class="n">size</span><span class="p">,</span> <span class="n">because</span> <span class="n">it</span> <span class="kr">is</span><span class="p"></span>
<span class="n">implemented</span> <span class="n">as</span> <span class="n">a</span> <span class="n">single</span> <span class="n">machine</span> <span class="n">instruction.</span>
</pre></div>
</div>
<ul>
<li><p>General subprogram entities. This is used  to bind an Ada subprogram
declaration to
a compiler builtin by name with back-ends where such interfaces are
available. A typical example is the set of <code class="docutils literal notranslate"><span class="pre">__builtin</span></code> functions
exposed by the GCC back-end, as in the following example:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="k">function </span><span class="nf">builtin_sqrt</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">Float</span><span class="o">)</span> <span class="kr">return</span><span class="p"> </span><span class="n">Float</span><span class="p">;</span>
<span class="kr">pragma</span><span class="p"> </span><span class="n">Import</span> <span class="o">(</span><span class="n">Intrinsic</span><span class="p">,</span> <span class="n">builtin_sqrt</span><span class="p">,</span> <span class="s">&quot;__builtin_sqrtf&quot;</span><span class="o">)</span><span class="p">;</span>
</pre></div>
</div>
<p>Most of the GCC builtins are accessible this way, and as for other
import conventions (e.g. C), it is the user’s responsibility to ensure
that the Ada subprogram profile matches the underlying builtin
expectations.</p>
</li>
</ul>
</dd>
</dl>
<span class="target" id="index-132"></span><dl class="simple" id="index-133">
<dt><code class="docutils literal notranslate"><span class="pre">Stdcall</span></code></dt><dd><p>This is relevant only to Windows implementations of GNAT,
and specifies that the <code class="docutils literal notranslate"><span class="pre">Stdcall</span></code> calling sequence will be used,
as defined by the NT API. Nevertheless, to ease building
cross-platform bindings this convention will be handled as a <code class="docutils literal notranslate"><span class="pre">C</span></code> calling
convention on non-Windows platforms.</p>
</dd>
</dl>
<span class="target" id="index-134"></span><dl class="simple" id="index-135">
<dt><code class="docutils literal notranslate"><span class="pre">DLL</span></code></dt><dd><p>This is equivalent to <code class="docutils literal notranslate"><span class="pre">Stdcall</span></code>.</p>
</dd>
</dl>
<span class="target" id="index-136"></span><dl class="simple" id="index-137">
<dt><code class="docutils literal notranslate"><span class="pre">Win32</span></code></dt><dd><p>This is equivalent to <code class="docutils literal notranslate"><span class="pre">Stdcall</span></code>.</p>
</dd>
</dl>
<span class="target" id="index-138"></span><dl class="simple" id="index-139">
<dt><code class="docutils literal notranslate"><span class="pre">Stubbed</span></code></dt><dd><p>This is a special convention that indicates that the compiler
should provide a stub body that raises <code class="docutils literal notranslate"><span class="pre">Program_Error</span></code>.</p>
</dd>
</dl>
<p>GNAT additionally provides a useful pragma <code class="docutils literal notranslate"><span class="pre">Convention_Identifier</span></code>
that can be used to parameterize conventions and allow additional synonyms
to be specified. For example if you have legacy code in which the convention
identifier Fortran77 was used for Fortran, you can use the configuration
pragma:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">pragma</span><span class="p"> </span><span class="n">Convention_Identifier</span> <span class="o">(</span><span class="n">Fortran77</span><span class="p">,</span> <span class="n">Fortran</span><span class="o">)</span><span class="p">;</span>
</pre></div>
</div>
<p>And from now on the identifier Fortran77 may be used as a convention
identifier (for example in an <code class="docutils literal notranslate"><span class="pre">Import</span></code> pragma) with the same
meaning as Fortran.</p>
</div>
<div class="section" id="building-mixed-ada-and-c-programs">
<span id="id64"></span><h3><span class="section-number">3.11.3. </span>Building Mixed Ada and C++ Programs<a class="headerlink" href="#building-mixed-ada-and-c-programs" title="Permalink to this headline">¶</a></h3>
<p>A programmer inexperienced with mixed-language development may find that
building an application containing both Ada and C++ code can be a
challenge.  This section gives a few hints that should make this task easier.</p>
<div class="section" id="id65">
<span id="id66"></span><h4><span class="section-number">3.11.3.1. </span>Interfacing to C++<a class="headerlink" href="#id65" title="Permalink to this headline">¶</a></h4>
<p>GNAT supports interfacing with the G++ compiler (or any C++ compiler
generating code that is compatible with the G++ Application Binary
Interface —see <a class="reference external" href="http://www.codesourcery.com/archives/cxx-abi">http://www.codesourcery.com/archives/cxx-abi</a>).</p>
<p>Interfacing can be done at 3 levels: simple data, subprograms, and
classes. In the first two cases, GNAT offers a specific <code class="docutils literal notranslate"><span class="pre">Convention</span> <span class="pre">C_Plus_Plus</span></code>
(or <code class="docutils literal notranslate"><span class="pre">CPP</span></code>) that behaves exactly like <code class="docutils literal notranslate"><span class="pre">Convention</span> <span class="pre">C</span></code>.
Usually, C++ mangles the names of subprograms. To generate proper mangled
names automatically, see <a class="reference internal" href="#generating-ada-bindings-for-c-and-c-headers"><span class="std std-ref">Generating Ada Bindings for C and C++ headers</span></a>).
This problem can also be addressed manually in two ways:</p>
<ul class="simple">
<li><p>by modifying the C++ code in order to force a C convention using
the <code class="docutils literal notranslate"><span class="pre">extern</span> <span class="pre">&quot;C&quot;</span></code> syntax.</p></li>
<li><p>by figuring out the mangled name (using e.g. <code class="docutils literal notranslate"><span class="pre">nm</span></code>) and using it as the
Link_Name argument of the pragma import.</p></li>
</ul>
<p>Interfacing at the class level can be achieved by using the GNAT specific
pragmas such as <code class="docutils literal notranslate"><span class="pre">CPP_Constructor</span></code>.  See the <cite>GNAT_Reference_Manual</cite> for additional information.</p>
</div>
<div class="section" id="linking-a-mixed-c-ada-program">
<span id="linking-a-mixed-c-and-ada-program"></span><h4><span class="section-number">3.11.3.2. </span>Linking a Mixed C++ &amp; Ada Program<a class="headerlink" href="#linking-a-mixed-c-ada-program" title="Permalink to this headline">¶</a></h4>
<p>Usually the linker of the C++ development system must be used to link
mixed applications because most C++ systems will resolve elaboration
issues (such as calling constructors on global class instances)
transparently during the link phase. GNAT has been adapted to ease the
use of a foreign linker for the last phase. Three cases can be
considered:</p>
<ul>
<li><p>Using GNAT and G++ (GNU C++ compiler) from the same GCC installation:
The C++ linker can simply be called by using the C++ specific driver
called <code class="docutils literal notranslate"><span class="pre">g++</span></code>.</p>
<p>Note that if the C++ code uses inline functions, you will need to
compile your C++ code with the <code class="switch docutils literal notranslate"><span class="pre">-fkeep-inline-functions</span></code> switch in
order to provide an existing function implementation that the Ada code can
link with.</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>$ g++ -c -fkeep-inline-functions file1.C
$ g++ -c -fkeep-inline-functions file2.C
$ gnatmake ada_unit -largs file1.o file2.o --LINK<span class="o">=</span>g++
</pre></div>
</div>
</li>
<li><p>Using GNAT and G++ from two different GCC installations: If both
compilers are on the :envvar`PATH`, the previous method may be used. It is
important to note that environment variables such as
<span class="target" id="index-140"></span><code class="xref std std-envvar docutils literal notranslate"><span class="pre">C_INCLUDE_PATH</span></code>, <span class="target" id="index-141"></span><code class="xref std std-envvar docutils literal notranslate"><span class="pre">GCC_EXEC_PREFIX</span></code>,
<span class="target" id="index-142"></span><code class="xref std std-envvar docutils literal notranslate"><span class="pre">BINUTILS_ROOT</span></code>, and
<span class="target" id="index-143"></span><code class="xref std std-envvar docutils literal notranslate"><span class="pre">GCC_ROOT</span></code> will affect both compilers
at the same time and may make one of the two compilers operate
improperly if set during invocation of the wrong compiler.  It is also
very important that the linker uses the proper <code class="file docutils literal notranslate"><span class="pre">libgcc.a</span></code> GCC
library – that is, the one from the C++ compiler installation. The
implicit link command as suggested in the <code class="docutils literal notranslate"><span class="pre">gnatmake</span></code> command
from the former example can be replaced by an explicit link command with
the full-verbosity option in order to verify which library is used:</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>$ gnatbind ada_unit
$ gnatlink -v -v ada_unit file1.o file2.o --LINK<span class="o">=</span>c++
</pre></div>
</div>
<p>If there is a problem due to interfering environment variables, it can
be worked around by using an intermediate script. The following example
shows the proper script to use when GNAT has not been installed at its
default location and g++ has been installed at its default location:</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>$ cat ./my_script
<span class="c1">#!/bin/sh</span>
<span class="nb">unset</span> BINUTILS_ROOT
<span class="nb">unset</span> GCC_ROOT
c++ <span class="nv">$*</span>
$ gnatlink -v -v ada_unit file1.o file2.o --LINK<span class="o">=</span>./my_script
</pre></div>
</div>
</li>
<li><p>Using a non-GNU C++ compiler: The commands previously described can be
used to insure that the C++ linker is used. Nonetheless, you need to add
a few more parameters to the link command line, depending on the exception
mechanism used.</p>
<p>If the <code class="docutils literal notranslate"><span class="pre">setjmp</span></code> / <code class="docutils literal notranslate"><span class="pre">longjmp</span></code> exception mechanism is used, only the paths
to the <code class="docutils literal notranslate"><span class="pre">libgcc</span></code> libraries are required:</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>$ cat ./my_script
<span class="c1">#!/bin/sh</span>
CC <span class="nv">$*</span> gcc -print-file-name<span class="o">=</span>libgcc.a gcc -print-file-name<span class="o">=</span>libgcc_eh.a
$ gnatlink ada_unit file1.o file2.o --LINK<span class="o">=</span>./my_script
</pre></div>
</div>
<p>where CC is the name of the non-GNU C++ compiler.</p>
<p>If the “zero cost” exception mechanism is used, and the platform
supports automatic registration of exception tables (e.g., Solaris),
paths to more objects are required:</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>$ cat ./my_script
<span class="c1">#!/bin/sh</span>
CC gcc -print-file-name<span class="o">=</span>crtbegin.o <span class="nv">$*</span> <span class="se">\\</span>
gcc -print-file-name<span class="o">=</span>libgcc.a gcc -print-file-name<span class="o">=</span>libgcc_eh.a <span class="se">\\</span>
gcc -print-file-name<span class="o">=</span>crtend.o
$ gnatlink ada_unit file1.o file2.o --LINK<span class="o">=</span>./my_script
</pre></div>
</div>
<p>If the “zero cost exception” mechanism is used, and the platform
doesn’t support automatic registration of exception tables (e.g., HP-UX
or AIX), the simple approach described above will not work and
a pre-linking phase using GNAT will be necessary.</p>
</li>
</ul>
<p>Another alternative is to use the <strong class="command">gprbuild</strong> multi-language builder
which has a large knowledge base and knows how to link Ada and C++ code
together automatically in most cases.</p>
</div>
<div class="section" id="a-simple-example">
<span id="id67"></span><h4><span class="section-number">3.11.3.3. </span>A Simple Example<a class="headerlink" href="#a-simple-example" title="Permalink to this headline">¶</a></h4>
<p>The following example, provided as part of the GNAT examples, shows how
to achieve procedural interfacing between Ada and C++ in both
directions. The C++ class A has two methods. The first method is exported
to Ada by the means of an extern C wrapper function. The second method
calls an Ada subprogram. On the Ada side, the C++ calls are modelled by
a limited record with a layout comparable to the C++ class. The Ada
subprogram, in turn, calls the C++ method. So, starting from the C++
main program, the process passes back and forth between the two
languages.</p>
<p>Here are the compilation commands:</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>$ gnatmake -c simple_cpp_interface
$ g++ -c cpp_main.C
$ g++ -c ex7.C
$ gnatbind -n simple_cpp_interface
$ gnatlink simple_cpp_interface -o cpp_main --LINK<span class="o">=</span>g++ -lstdc++ ex7.o cpp_main.o
</pre></div>
</div>
<p>Here are the corresponding sources:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">//cpp_main.C</span>

<span class="cp">#include</span> <span class="cpf">&quot;ex7.h&quot;</span><span class="cp"></span>

<span class="k">extern</span> <span class="s">&quot;C&quot;</span> <span class="p">{</span>
  <span class="kt">void</span> <span class="n">adainit</span> <span class="p">(</span><span class="kt">void</span><span class="p">);</span>
  <span class="kt">void</span> <span class="nf">adafinal</span> <span class="p">(</span><span class="kt">void</span><span class="p">);</span>
  <span class="kt">void</span> <span class="nf">method1</span> <span class="p">(</span><span class="n">A</span> <span class="o">*</span><span class="n">t</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">method1</span> <span class="p">(</span><span class="n">A</span> <span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">t</span><span class="o">-&gt;</span><span class="n">method1</span> <span class="p">();</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span> <span class="p">()</span>
<span class="p">{</span>
  <span class="n">A</span> <span class="n">obj</span><span class="p">;</span>
  <span class="n">adainit</span> <span class="p">();</span>
  <span class="n">obj</span><span class="p">.</span><span class="n">method2</span> <span class="p">(</span><span class="mi">3030</span><span class="p">);</span>
  <span class="n">adafinal</span> <span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">//ex7.h</span>

<span class="k">class</span> <span class="nc">Origin</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="kt">int</span> <span class="n">o_value</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">class</span> <span class="nc">A</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Origin</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="kt">void</span> <span class="n">method1</span> <span class="p">(</span><span class="kt">void</span><span class="p">);</span>
  <span class="kt">void</span> <span class="nf">method2</span> <span class="p">(</span><span class="kt">int</span> <span class="n">v</span><span class="p">);</span>
  <span class="n">A</span><span class="p">();</span>
  <span class="kt">int</span>   <span class="n">a_value</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">//ex7.C</span>

<span class="cp">#include</span> <span class="cpf">&quot;ex7.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>

<span class="k">extern</span> <span class="s">&quot;C&quot;</span> <span class="p">{</span> <span class="kt">void</span> <span class="n">ada_method2</span> <span class="p">(</span><span class="n">A</span> <span class="o">*</span><span class="n">t</span><span class="p">,</span> <span class="kt">int</span> <span class="n">v</span><span class="p">);}</span>

<span class="kt">void</span> <span class="n">A</span><span class="o">::</span><span class="n">method1</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">a_value</span> <span class="o">=</span> <span class="mi">2020</span><span class="p">;</span>
  <span class="n">printf</span> <span class="p">(</span><span class="s">&quot;in A::method1, a_value = %d </span><span class="se">\\</span><span class="s">n&quot;</span><span class="p">,</span><span class="n">a_value</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">A</span><span class="o">::</span><span class="n">method2</span> <span class="p">(</span><span class="kt">int</span> <span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
   <span class="n">ada_method2</span> <span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
   <span class="n">printf</span> <span class="p">(</span><span class="s">&quot;in A::method2, a_value = %d </span><span class="se">\\</span><span class="s">n&quot;</span><span class="p">,</span><span class="n">a_value</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">A</span><span class="o">::</span><span class="n">A</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
   <span class="n">a_value</span> <span class="o">=</span> <span class="mi">1010</span><span class="p">;</span>
  <span class="n">printf</span> <span class="p">(</span><span class="s">&quot;in A::A, a_value = %d </span><span class="se">\\</span><span class="s">n&quot;</span><span class="p">,</span><span class="n">a_value</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="c">-- simple_cpp_interface.ads</span><span class="p"></span>
<span class="kr">with</span><span class="nn"> System;</span>
<span class="k">package </span><span class="nf">Simple_Cpp_Interface</span> <span class="kr">is</span><span class="p"></span>
   <span class="kr">type</span><span class="p"> </span><span class="n">A</span> <span class="kr">is</span><span class="p"> </span><span class="kr">limited</span><span class="p"></span>
      <span class="kr">record</span><span class="p"></span>
         <span class="n">Vptr</span>    <span class="o">:</span> <span class="n">System.Address</span><span class="p">;</span>
         <span class="n">O_Value</span> <span class="o">:</span> <span class="n">Integer</span><span class="p">;</span>
         <span class="n">A_Value</span> <span class="o">:</span> <span class="n">Integer</span><span class="p">;</span>
      <span class="k">end record</span><span class="p">;</span>
   <span class="kr">pragma</span><span class="p"> </span><span class="n">Convention</span> <span class="o">(</span><span class="n">C</span><span class="p">,</span> <span class="n">A</span><span class="o">)</span><span class="p">;</span>

   <span class="k">procedure </span><span class="nf">Method1</span> <span class="o">(</span><span class="n">This</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="kr">out</span><span class="p"> </span><span class="n">A</span><span class="o">)</span><span class="p">;</span>
   <span class="kr">pragma</span><span class="p"> </span><span class="n">Import</span> <span class="o">(</span><span class="n">C</span><span class="p">,</span> <span class="n">Method1</span><span class="o">)</span><span class="p">;</span>

   <span class="k">procedure </span><span class="nf">Ada_Method2</span> <span class="o">(</span><span class="n">This</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="kr">out</span><span class="p"> </span><span class="n">A</span><span class="p">;</span> <span class="n">V</span> <span class="o">:</span> <span class="n">Integer</span><span class="o">)</span><span class="p">;</span>
   <span class="kr">pragma</span><span class="p"> </span><span class="n">Export</span> <span class="o">(</span><span class="n">C</span><span class="p">,</span> <span class="n">Ada_Method2</span><span class="o">)</span><span class="p">;</span>

<span class="k">end </span><span class="nf">Simple_Cpp_Interface</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="c">-- simple_cpp_interface.adb</span>
<span class="k">package body </span><span class="nf">Simple_Cpp_Interface</span> <span class="kr">is</span><span class="p"></span>

   <span class="k">procedure </span><span class="nf">Ada_Method2</span> <span class="o">(</span><span class="n">This</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="kr">out</span><span class="p"> </span><span class="n">A</span><span class="p">;</span> <span class="n">V</span> <span class="o">:</span> <span class="n">Integer</span><span class="o">)</span> <span class="kr">is</span><span class="p"></span>
   <span class="kr">begin</span><span class="p"></span>
      <span class="n">Method1</span> <span class="o">(</span><span class="n">This</span><span class="o">)</span><span class="p">;</span>
      <span class="n">This.A_Value</span> <span class="o">:=</span> <span class="n">V</span><span class="p">;</span>
   <span class="k">end </span><span class="nf">Ada_Method2</span><span class="p">;</span>

<span class="k">end </span><span class="nf">Simple_Cpp_Interface</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="interfacing-with-c-constructors">
<span id="id68"></span><h4><span class="section-number">3.11.3.4. </span>Interfacing with C++ constructors<a class="headerlink" href="#interfacing-with-c-constructors" title="Permalink to this headline">¶</a></h4>
<p>In order to interface with C++ constructors GNAT provides the
<code class="docutils literal notranslate"><span class="pre">pragma</span> <span class="pre">CPP_Constructor</span></code> (see the <cite>GNAT_Reference_Manual</cite>
for additional information).
In this section we present some common uses of C++ constructors
in mixed-languages programs in GNAT.</p>
<p>Let us assume that we need to interface with the following
C++ class:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Root</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="kt">int</span>  <span class="n">a_value</span><span class="p">;</span>
  <span class="kt">int</span>  <span class="n">b_value</span><span class="p">;</span>
  <span class="k">virtual</span> <span class="kt">int</span> <span class="nf">Get_Value</span> <span class="p">();</span>
  <span class="n">Root</span><span class="p">();</span>              <span class="c1">// Default constructor</span>
  <span class="n">Root</span><span class="p">(</span><span class="kt">int</span> <span class="n">v</span><span class="p">);</span>         <span class="c1">// 1st non-default constructor</span>
  <span class="n">Root</span><span class="p">(</span><span class="kt">int</span> <span class="n">v</span><span class="p">,</span> <span class="kt">int</span> <span class="n">w</span><span class="p">);</span>  <span class="c1">// 2nd non-default constructor</span>
<span class="p">};</span>
</pre></div>
</div>
<p>For this purpose we can write the following package spec (further
information on how to build this spec is available in
<a class="reference internal" href="#interfacing-with-c-at-the-class-level"><span class="std std-ref">Interfacing with C++ at the Class Level</span></a> and
<a class="reference internal" href="#generating-ada-bindings-for-c-and-c-headers"><span class="std std-ref">Generating Ada Bindings for C and C++ headers</span></a>).</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">with</span><span class="p"> </span><span class="n">Interfaces.C</span><span class="p">; </span><span class="kr">use</span><span class="nn"> Interfaces.C;</span>
<span class="k">package </span><span class="nf">Pkg_Root</span> <span class="kr">is</span><span class="p"></span>
  <span class="kr">type</span><span class="p"> </span><span class="n">Root</span> <span class="kr">is</span><span class="p"> </span><span class="kr">tagged</span><span class="p"> </span><span class="kr">limited</span><span class="p"> </span><span class="kr">record</span><span class="p"></span>
     <span class="n">A_Value</span> <span class="o">:</span> <span class="n">int</span><span class="p">;</span>
     <span class="n">B_Value</span> <span class="o">:</span> <span class="n">int</span><span class="p">;</span>
  <span class="k">end record</span><span class="p">;</span>
  <span class="kr">pragma</span><span class="p"> </span><span class="n">Import</span> <span class="o">(</span><span class="n">CPP</span><span class="p">,</span> <span class="n">Root</span><span class="o">)</span><span class="p">;</span>

  <span class="k">function </span><span class="nf">Get_Value</span> <span class="o">(</span><span class="n">Obj</span> <span class="o">:</span> <span class="n">Root</span><span class="o">)</span> <span class="kr">return</span><span class="p"> </span><span class="n">int</span><span class="p">;</span>
  <span class="kr">pragma</span><span class="p"> </span><span class="n">Import</span> <span class="o">(</span><span class="n">CPP</span><span class="p">,</span> <span class="n">Get_Value</span><span class="o">)</span><span class="p">;</span>

  <span class="k">function </span><span class="nf">Constructor</span> <span class="kr">return</span><span class="p"> </span><span class="n">Root</span><span class="p">;</span>
  <span class="kr">pragma</span><span class="p"> </span><span class="n">Cpp_Constructor</span> <span class="o">(</span><span class="n">Constructor</span><span class="p">,</span> <span class="s">&quot;_ZN4RootC1Ev&quot;</span><span class="o">)</span><span class="p">;</span>

  <span class="k">function </span><span class="nf">Constructor</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">Integer</span><span class="o">)</span> <span class="kr">return</span><span class="p"> </span><span class="n">Root</span><span class="p">;</span>
  <span class="kr">pragma</span><span class="p"> </span><span class="n">Cpp_Constructor</span> <span class="o">(</span><span class="n">Constructor</span><span class="p">,</span> <span class="s">&quot;_ZN4RootC1Ei&quot;</span><span class="o">)</span><span class="p">;</span>

  <span class="k">function </span><span class="nf">Constructor</span> <span class="o">(</span><span class="n">v</span><span class="p">,</span> <span class="n">w</span> <span class="o">:</span> <span class="n">Integer</span><span class="o">)</span> <span class="kr">return</span><span class="p"> </span><span class="n">Root</span><span class="p">;</span>
  <span class="kr">pragma</span><span class="p"> </span><span class="n">Cpp_Constructor</span> <span class="o">(</span><span class="n">Constructor</span><span class="p">,</span> <span class="s">&quot;_ZN4RootC1Eii&quot;</span><span class="o">)</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Pkg_Root</span><span class="p">;</span>
</pre></div>
</div>
<p>On the Ada side the constructor is represented by a function (whose
name is arbitrary) that returns the classwide type corresponding to
the imported C++ class. Although the constructor is described as a
function, it is typically a procedure with an extra implicit argument
(the object being initialized) at the implementation level. GNAT
issues the appropriate call, whatever it is, to get the object
properly initialized.</p>
<p>Constructors can only appear in the following contexts:</p>
<ul class="simple">
<li><p>On the right side of an initialization of an object of type <code class="docutils literal notranslate"><span class="pre">T</span></code>.</p></li>
<li><p>On the right side of an initialization of a record component of type <code class="docutils literal notranslate"><span class="pre">T</span></code>.</p></li>
<li><p>In an Ada 2005 limited aggregate.</p></li>
<li><p>In an Ada 2005 nested limited aggregate.</p></li>
<li><p>In an Ada 2005 limited aggregate that initializes an object built in
place by an extended return statement.</p></li>
</ul>
<p>In a declaration of an object whose type is a class imported from C++,
either the default C++ constructor is implicitly called by GNAT, or
else the required C++ constructor must be explicitly called in the
expression that initializes the object. For example:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="n">Obj1</span> <span class="o">:</span> <span class="n">Root</span><span class="p">;</span>
<span class="n">Obj2</span> <span class="o">:</span> <span class="n">Root</span> <span class="o">:=</span> <span class="n">Constructor</span><span class="p">;</span>
<span class="n">Obj3</span> <span class="o">:</span> <span class="n">Root</span> <span class="o">:=</span> <span class="n">Constructor</span> <span class="o">(</span><span class="n">v</span> <span class="o">=&gt;</span> <span class="mi">10</span><span class="o">)</span><span class="p">;</span>
<span class="n">Obj4</span> <span class="o">:</span> <span class="n">Root</span> <span class="o">:=</span> <span class="n">Constructor</span> <span class="o">(</span><span class="mi">30</span><span class="p">,</span> <span class="mi">40</span><span class="o">)</span><span class="p">;</span>
</pre></div>
</div>
<p>The first two declarations are equivalent: in both cases the default C++
constructor is invoked (in the former case the call to the constructor is
implicit, and in the latter case the call is explicit in the object
declaration). <code class="docutils literal notranslate"><span class="pre">Obj3</span></code> is initialized by the C++ non-default constructor
that takes an integer argument, and <code class="docutils literal notranslate"><span class="pre">Obj4</span></code> is initialized by the
non-default C++ constructor that takes two integers.</p>
<p>Let us derive the imported C++ class in the Ada side. For example:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">type</span><span class="p"> </span><span class="n">DT</span> <span class="kr">is</span><span class="p"> </span><span class="kr">new</span><span class="p"> </span><span class="n">Root</span> <span class="kr">with</span><span class="p"> </span><span class="kr">record</span><span class="p"></span>
   <span class="n">C_Value</span> <span class="o">:</span> <span class="n">Natural</span> <span class="o">:=</span> <span class="mi">2009</span><span class="p">;</span>
<span class="k">end record</span><span class="p">;</span>
</pre></div>
</div>
<p>In this case the components DT inherited from the C++ side must be
initialized by a C++ constructor, and the additional Ada components
of type DT are initialized by GNAT. The initialization of such an
object is done either by default, or by means of a function returning
an aggregate of type DT, or by means of an extension aggregate.</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="n">Obj5</span> <span class="o">:</span> <span class="n">DT</span><span class="p">;</span>
<span class="n">Obj6</span> <span class="o">:</span> <span class="n">DT</span> <span class="o">:=</span> <span class="n">Function_Returning_DT</span> <span class="o">(</span><span class="mi">50</span><span class="o">)</span><span class="p">;</span>
<span class="n">Obj7</span> <span class="o">:</span> <span class="n">DT</span> <span class="o">:=</span> <span class="o">(</span><span class="n">Constructor</span> <span class="o">(</span><span class="mi">30</span><span class="p">,</span><span class="mi">40</span><span class="o">)</span> <span class="kr">with</span><span class="p"> </span><span class="n">C_Value</span> <span class="o">=&gt;</span> <span class="mi">50</span><span class="o">)</span><span class="p">;</span>
</pre></div>
</div>
<p>The declaration of <code class="docutils literal notranslate"><span class="pre">Obj5</span></code> invokes the default constructors: the
C++ default constructor of the parent type takes care of the initialization
of the components inherited from Root, and GNAT takes care of the default
initialization of the additional Ada components of type DT (that is,
<code class="docutils literal notranslate"><span class="pre">C_Value</span></code> is initialized to value 2009). The order of invocation of
the constructors is consistent with the order of elaboration required by
Ada and C++. That is, the constructor of the parent type is always called
before the constructor of the derived type.</p>
<p>Let us now consider a record that has components whose type is imported
from C++. For example:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">type</span><span class="p"> </span><span class="n">Rec1</span> <span class="kr">is</span><span class="p"> </span><span class="kr">limited</span><span class="p"> </span><span class="kr">record</span><span class="p"></span>
   <span class="n">Data1</span> <span class="o">:</span> <span class="n">Root</span> <span class="o">:=</span> <span class="n">Constructor</span> <span class="o">(</span><span class="mi">10</span><span class="o">)</span><span class="p">;</span>
   <span class="n">Value</span> <span class="o">:</span> <span class="n">Natural</span> <span class="o">:=</span> <span class="mi">1000</span><span class="p">;</span>
<span class="k">end record</span><span class="p">;</span>

<span class="kr">type</span><span class="p"> </span><span class="n">Rec2</span> <span class="o">(</span><span class="n">D</span> <span class="o">:</span> <span class="n">Integer</span> <span class="o">:=</span> <span class="mi">20</span><span class="o">)</span> <span class="kr">is</span><span class="p"> </span><span class="kr">limited</span><span class="p"> </span><span class="kr">record</span><span class="p"></span>
   <span class="n">Rec</span>   <span class="o">:</span> <span class="n">Rec1</span><span class="p">;</span>
   <span class="n">Data2</span> <span class="o">:</span> <span class="n">Root</span> <span class="o">:=</span> <span class="n">Constructor</span> <span class="o">(</span><span class="n">D</span><span class="p">,</span> <span class="mi">30</span><span class="o">)</span><span class="p">;</span>
<span class="k">end record</span><span class="p">;</span>
</pre></div>
</div>
<p>The initialization of an object of type <code class="docutils literal notranslate"><span class="pre">Rec2</span></code> will call the
non-default C++ constructors specified for the imported components.
For example:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="n">Obj8</span> <span class="o">:</span> <span class="n">Rec2</span> <span class="o">(</span><span class="mi">40</span><span class="o">)</span><span class="p">;</span>
</pre></div>
</div>
<p>Using Ada 2005 we can use limited aggregates to initialize an object
invoking C++ constructors that differ from those specified in the type
declarations. For example:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="n">Obj9</span> <span class="o">:</span> <span class="n">Rec2</span> <span class="o">:=</span> <span class="o">(</span><span class="n">Rec</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Data1</span> <span class="o">=&gt;</span> <span class="n">Constructor</span> <span class="o">(</span><span class="mi">15</span><span class="p">,</span> <span class="mi">16</span><span class="o">)</span><span class="p">,</span>
                        <span class="kr">others</span><span class="p"> </span><span class="o">=&gt;</span> <span class="o">&lt;&gt;)</span><span class="p">,</span>
                <span class="kr">others</span><span class="p"> </span><span class="o">=&gt;</span> <span class="o">&lt;&gt;)</span><span class="p">;</span>
</pre></div>
</div>
<p>The above declaration uses an Ada 2005 limited aggregate to
initialize <code class="docutils literal notranslate"><span class="pre">Obj9</span></code>, and the C++ constructor that has two integer
arguments is invoked to initialize the <code class="docutils literal notranslate"><span class="pre">Data1</span></code> component instead
of the constructor specified in the declaration of type <code class="docutils literal notranslate"><span class="pre">Rec1</span></code>. In
Ada 2005 the box in the aggregate indicates that unspecified components
are initialized using the expression (if any) available in the component
declaration. That is, in this case discriminant <code class="docutils literal notranslate"><span class="pre">D</span></code> is initialized
to value <code class="docutils literal notranslate"><span class="pre">20</span></code>, <code class="docutils literal notranslate"><span class="pre">Value</span></code> is initialized to value 1000, and the
non-default C++ constructor that handles two integers takes care of
initializing component <code class="docutils literal notranslate"><span class="pre">Data2</span></code> with values <code class="docutils literal notranslate"><span class="pre">20,30</span></code>.</p>
<p>In Ada 2005 we can use the extended return statement to build the Ada
equivalent to C++ non-default constructors. For example:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="k">function </span><span class="nf">Constructor</span> <span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="n">Integer</span><span class="o">)</span> <span class="kr">return</span><span class="p"> </span><span class="n">Rec2</span> <span class="kr">is</span><span class="p"></span>
<span class="kr">begin</span><span class="p"></span>
   <span class="kr">return</span><span class="p"> </span><span class="n">Obj</span> <span class="o">:</span> <span class="n">Rec2</span> <span class="o">:=</span> <span class="o">(</span><span class="n">Rec</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">Data1</span>  <span class="o">=&gt;</span> <span class="n">Constructor</span> <span class="o">(</span><span class="n">V</span><span class="p">,</span> <span class="mi">20</span><span class="o">)</span><span class="p">,</span>
                                 <span class="kr">others</span><span class="p"> </span><span class="o">=&gt;</span> <span class="o">&lt;&gt;)</span><span class="p">,</span>
                         <span class="kr">others</span><span class="p"> </span><span class="o">=&gt;</span> <span class="o">&lt;&gt;)</span> <span class="kr">do</span><span class="p"></span>
      <span class="c">--  Further actions required for construction of</span>
      <span class="c">--  objects of type Rec2</span>
      <span class="o">...</span>
   <span class="k">end record</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Constructor</span><span class="p">;</span>
</pre></div>
</div>
<p>In this example the extended return statement construct is used to
build in place the returned object whose components are initialized
by means of a limited aggregate. Any further action associated with
the constructor can be placed inside the construct.</p>
</div>
<div class="section" id="interfacing-with-c-at-the-class-level">
<span id="id69"></span><h4><span class="section-number">3.11.3.5. </span>Interfacing with C++ at the Class Level<a class="headerlink" href="#interfacing-with-c-at-the-class-level" title="Permalink to this headline">¶</a></h4>
<p>In this section we demonstrate the GNAT features for interfacing with
C++ by means of an example making use of Ada 2005 abstract interface
types. This example consists of a classification of animals; classes
have been used to model our main classification of animals, and
interfaces provide support for the management of secondary
classifications. We first demonstrate a case in which the types and
constructors are defined on the C++ side and imported from the Ada
side, and latter the reverse case.</p>
<p>The root of our derivation will be the <code class="docutils literal notranslate"><span class="pre">Animal</span></code> class, with a
single private attribute (the <code class="docutils literal notranslate"><span class="pre">Age</span></code> of the animal), a constructor,
and two public primitives to set and get the value of this attribute.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Animal</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
   <span class="k">virtual</span> <span class="kt">void</span> <span class="n">Set_Age</span> <span class="p">(</span><span class="kt">int</span> <span class="n">New_Age</span><span class="p">);</span>
   <span class="k">virtual</span> <span class="kt">int</span> <span class="nf">Age</span> <span class="p">();</span>
   <span class="n">Animal</span><span class="p">()</span> <span class="p">{</span><span class="n">Age_Count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;};</span>
 <span class="k">private</span><span class="o">:</span>
   <span class="kt">int</span> <span class="n">Age_Count</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Abstract interface types are defined in C++ by means of classes with pure
virtual functions and no data members. In our example we will use two
interfaces that provide support for the common management of <code class="docutils literal notranslate"><span class="pre">Carnivore</span></code>
and <code class="docutils literal notranslate"><span class="pre">Domestic</span></code> animals:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Carnivore</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
   <span class="k">virtual</span> <span class="kt">int</span> <span class="n">Number_Of_Teeth</span> <span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Domestic</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
   <span class="k">virtual</span> <span class="kt">void</span> <span class="n">Set_Owner</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">Name</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Using these declarations, we can now say that a <code class="docutils literal notranslate"><span class="pre">Dog</span></code> is an animal that is
both Carnivore and Domestic, that is:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Dog</span> <span class="o">:</span> <span class="n">Animal</span><span class="p">,</span> <span class="n">Carnivore</span><span class="p">,</span> <span class="n">Domestic</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
   <span class="k">virtual</span> <span class="kt">int</span>  <span class="n">Number_Of_Teeth</span> <span class="p">();</span>
   <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">Set_Owner</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">Name</span><span class="p">);</span>

   <span class="n">Dog</span><span class="p">();</span> <span class="c1">// Constructor</span>
 <span class="k">private</span><span class="o">:</span>
   <span class="kt">int</span>  <span class="n">Tooth_Count</span><span class="p">;</span>
   <span class="kt">char</span> <span class="o">*</span><span class="n">Owner</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>In the following examples we will assume that the previous declarations are
located in a file named <code class="file docutils literal notranslate"><span class="pre">animals.h</span></code>. The following package demonstrates
how to import these C++ declarations from the Ada side:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">with</span><span class="p"> </span><span class="n">Interfaces.C.Strings</span><span class="p">; </span><span class="kr">use</span><span class="nn"> Interfaces.C.Strings;</span>
<span class="k">package </span><span class="nf">Animals</span> <span class="kr">is</span><span class="p"></span>
  <span class="kr">type</span><span class="p"> </span><span class="n">Carnivore</span> <span class="kr">is</span><span class="p"> </span><span class="kr">limited</span><span class="p"> </span><span class="kr">interface</span><span class="p">;</span>
  <span class="kr">pragma</span><span class="p"> </span><span class="n">Convention</span> <span class="o">(</span><span class="n">C_Plus_Plus</span><span class="p">,</span> <span class="n">Carnivore</span><span class="o">)</span><span class="p">;</span>
  <span class="k">function </span><span class="nf">Number_Of_Teeth</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">Carnivore</span><span class="o">)</span>
     <span class="kr">return</span><span class="p"> </span><span class="n">Natural</span> <span class="kr">is</span><span class="p"> </span><span class="kr">abstract</span><span class="p">;</span>

  <span class="kr">type</span><span class="p"> </span><span class="n">Domestic</span> <span class="kr">is</span><span class="p"> </span><span class="kr">limited</span><span class="p"> </span><span class="kr">interface</span><span class="p">;</span>
  <span class="kr">pragma</span><span class="p"> </span><span class="n">Convention</span> <span class="o">(</span><span class="n">C_Plus_Plus</span><span class="p">,</span> <span class="n">Domestic</span><span class="o">)</span><span class="p">;</span>
  <span class="k">procedure </span><span class="nf">Set_Owner</span>
    <span class="o">(</span><span class="n">X</span>    <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="kr">out</span><span class="p"> </span><span class="n">Domestic</span><span class="p">;</span>
     <span class="n">Name</span> <span class="o">:</span> <span class="n">Chars_Ptr</span><span class="o">)</span> <span class="kr">is</span><span class="p"> </span><span class="kr">abstract</span><span class="p">;</span>

  <span class="kr">type</span><span class="p"> </span><span class="n">Animal</span> <span class="kr">is</span><span class="p"> </span><span class="kr">tagged</span><span class="p"> </span><span class="kr">limited</span><span class="p"> </span><span class="kr">record</span><span class="p"></span>
    <span class="n">Age</span> <span class="o">:</span> <span class="n">Natural</span><span class="p">;</span>
  <span class="k">end record</span><span class="p">;</span>
  <span class="kr">pragma</span><span class="p"> </span><span class="n">Import</span> <span class="o">(</span><span class="n">C_Plus_Plus</span><span class="p">,</span> <span class="n">Animal</span><span class="o">)</span><span class="p">;</span>

  <span class="k">procedure </span><span class="nf">Set_Age</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="kr">out</span><span class="p"> </span><span class="n">Animal</span><span class="p">;</span> <span class="n">Age</span> <span class="o">:</span> <span class="n">Integer</span><span class="o">)</span><span class="p">;</span>
  <span class="kr">pragma</span><span class="p"> </span><span class="n">Import</span> <span class="o">(</span><span class="n">C_Plus_Plus</span><span class="p">,</span> <span class="n">Set_Age</span><span class="o">)</span><span class="p">;</span>

  <span class="k">function </span><span class="nf">Age</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">Animal</span><span class="o">)</span> <span class="kr">return</span><span class="p"> </span><span class="n">Integer</span><span class="p">;</span>
  <span class="kr">pragma</span><span class="p"> </span><span class="n">Import</span> <span class="o">(</span><span class="n">C_Plus_Plus</span><span class="p">,</span> <span class="n">Age</span><span class="o">)</span><span class="p">;</span>

  <span class="k">function </span><span class="nf">New_Animal</span> <span class="kr">return</span><span class="p"> </span><span class="n">Animal</span><span class="p">;</span>
  <span class="kr">pragma</span><span class="p"> </span><span class="n">CPP_Constructor</span> <span class="o">(</span><span class="n">New_Animal</span><span class="o">)</span><span class="p">;</span>
  <span class="kr">pragma</span><span class="p"> </span><span class="n">Import</span> <span class="o">(</span><span class="n">CPP</span><span class="p">,</span> <span class="n">New_Animal</span><span class="p">,</span> <span class="s">&quot;_ZN6AnimalC1Ev&quot;</span><span class="o">)</span><span class="p">;</span>

  <span class="kr">type</span><span class="p"> </span><span class="n">Dog</span> <span class="kr">is</span><span class="p"> </span><span class="kr">new</span><span class="p"> </span><span class="n">Animal</span> <span class="kr">and</span><span class="p"> </span><span class="n">Carnivore</span> <span class="kr">and</span><span class="p"> </span><span class="n">Domestic</span> <span class="kr">with</span><span class="p"> </span><span class="kr">record</span><span class="p"></span>
    <span class="n">Tooth_Count</span> <span class="o">:</span> <span class="n">Natural</span><span class="p">;</span>
    <span class="n">Owner</span>       <span class="o">:</span> <span class="n">Chars_Ptr</span><span class="p">;</span>
  <span class="k">end record</span><span class="p">;</span>
  <span class="kr">pragma</span><span class="p"> </span><span class="n">Import</span> <span class="o">(</span><span class="n">C_Plus_Plus</span><span class="p">,</span> <span class="n">Dog</span><span class="o">)</span><span class="p">;</span>

  <span class="k">function </span><span class="nf">Number_Of_Teeth</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">Dog</span><span class="o">)</span> <span class="kr">return</span><span class="p"> </span><span class="n">Natural</span><span class="p">;</span>
  <span class="kr">pragma</span><span class="p"> </span><span class="n">Import</span> <span class="o">(</span><span class="n">C_Plus_Plus</span><span class="p">,</span> <span class="n">Number_Of_Teeth</span><span class="o">)</span><span class="p">;</span>

  <span class="k">procedure </span><span class="nf">Set_Owner</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="kr">out</span><span class="p"> </span><span class="n">Dog</span><span class="p">;</span> <span class="n">Name</span> <span class="o">:</span> <span class="n">Chars_Ptr</span><span class="o">)</span><span class="p">;</span>
  <span class="kr">pragma</span><span class="p"> </span><span class="n">Import</span> <span class="o">(</span><span class="n">C_Plus_Plus</span><span class="p">,</span> <span class="n">Set_Owner</span><span class="o">)</span><span class="p">;</span>

  <span class="k">function </span><span class="nf">New_Dog</span> <span class="kr">return</span><span class="p"> </span><span class="n">Dog</span><span class="p">;</span>
  <span class="kr">pragma</span><span class="p"> </span><span class="n">CPP_Constructor</span> <span class="o">(</span><span class="n">New_Dog</span><span class="o">)</span><span class="p">;</span>
  <span class="kr">pragma</span><span class="p"> </span><span class="n">Import</span> <span class="o">(</span><span class="n">CPP</span><span class="p">,</span> <span class="n">New_Dog</span><span class="p">,</span> <span class="s">&quot;_ZN3DogC2Ev&quot;</span><span class="o">)</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Animals</span><span class="p">;</span>
</pre></div>
</div>
<p>Thanks to the compatibility between GNAT run-time structures and the C++ ABI,
interfacing with these C++ classes is easy. The only requirement is that all
the primitives and components must be declared exactly in the same order in
the two languages.</p>
<p>Regarding the abstract interfaces, we must indicate to the GNAT compiler by
means of a <code class="docutils literal notranslate"><span class="pre">pragma</span> <span class="pre">Convention</span> <span class="pre">(C_Plus_Plus)</span></code>, the convention used to pass
the arguments to the called primitives will be the same as for C++. For the
imported classes we use <code class="docutils literal notranslate"><span class="pre">pragma</span> <span class="pre">Import</span></code> with convention <code class="docutils literal notranslate"><span class="pre">C_Plus_Plus</span></code>
to indicate that they have been defined on the C++ side; this is required
because the dispatch table associated with these tagged types will be built
in the C++ side and therefore will not contain the predefined Ada primitives
which Ada would otherwise expect.</p>
<p>As the reader can see there is no need to indicate the C++ mangled names
associated with each subprogram because it is assumed that all the calls to
these primitives will be dispatching calls. The only exception is the
constructor, which must be registered with the compiler by means of
<code class="docutils literal notranslate"><span class="pre">pragma</span> <span class="pre">CPP_Constructor</span></code> and needs to provide its associated C++
mangled name because the Ada compiler generates direct calls to it.</p>
<p>With the above packages we can now declare objects of type Dog on the Ada side
and dispatch calls to the corresponding subprograms on the C++ side. We can
also extend the tagged type Dog with further fields and primitives, and
override some of its C++ primitives on the Ada side. For example, here we have
a type derivation defined on the Ada side that inherits all the dispatching
primitives of the ancestor from the C++ side.</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">with</span><span class="p"> </span><span class="n">Animals</span><span class="p">; </span><span class="kr">use</span><span class="nn"> Animals;</span>
<span class="k">package </span><span class="nf">Vaccinated_Animals</span> <span class="kr">is</span><span class="p"></span>
  <span class="kr">type</span><span class="p"> </span><span class="n">Vaccinated_Dog</span> <span class="kr">is</span><span class="p"> </span><span class="kr">new</span><span class="p"> </span><span class="n">Dog</span> <span class="kr">with</span><span class="p"> </span><span class="kr">null</span><span class="p"> </span><span class="kr">record</span><span class="p">;</span>
  <span class="k">function </span><span class="nf">Vaccination_Expired</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">Vaccinated_Dog</span><span class="o">)</span> <span class="kr">return</span><span class="p"> </span><span class="n">Boolean</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Vaccinated_Animals</span><span class="p">;</span>
</pre></div>
</div>
<p>It is important to note that, because of the ABI compatibility, the programmer
does not need to add any further information to indicate either the object
layout or the dispatch table entry associated with each dispatching operation.</p>
<p>Now let us define all the types and constructors on the Ada side and export
them to C++, using the same hierarchy of our previous example:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">with</span><span class="p"> </span><span class="n">Interfaces.C.Strings</span><span class="p">;</span>
<span class="kr">use</span><span class="nn"> Interfaces.C.Strings;</span>
<span class="k">package </span><span class="nf">Animals</span> <span class="kr">is</span><span class="p"></span>
  <span class="kr">type</span><span class="p"> </span><span class="n">Carnivore</span> <span class="kr">is</span><span class="p"> </span><span class="kr">limited</span><span class="p"> </span><span class="kr">interface</span><span class="p">;</span>
  <span class="kr">pragma</span><span class="p"> </span><span class="n">Convention</span> <span class="o">(</span><span class="n">C_Plus_Plus</span><span class="p">,</span> <span class="n">Carnivore</span><span class="o">)</span><span class="p">;</span>
  <span class="k">function </span><span class="nf">Number_Of_Teeth</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">Carnivore</span><span class="o">)</span>
     <span class="kr">return</span><span class="p"> </span><span class="n">Natural</span> <span class="kr">is</span><span class="p"> </span><span class="kr">abstract</span><span class="p">;</span>

  <span class="kr">type</span><span class="p"> </span><span class="n">Domestic</span> <span class="kr">is</span><span class="p"> </span><span class="kr">limited</span><span class="p"> </span><span class="kr">interface</span><span class="p">;</span>
  <span class="kr">pragma</span><span class="p"> </span><span class="n">Convention</span> <span class="o">(</span><span class="n">C_Plus_Plus</span><span class="p">,</span> <span class="n">Domestic</span><span class="o">)</span><span class="p">;</span>
  <span class="k">procedure </span><span class="nf">Set_Owner</span>
    <span class="o">(</span><span class="n">X</span>    <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="kr">out</span><span class="p"> </span><span class="n">Domestic</span><span class="p">;</span>
     <span class="n">Name</span> <span class="o">:</span> <span class="n">Chars_Ptr</span><span class="o">)</span> <span class="kr">is</span><span class="p"> </span><span class="kr">abstract</span><span class="p">;</span>

  <span class="kr">type</span><span class="p"> </span><span class="n">Animal</span> <span class="kr">is</span><span class="p"> </span><span class="kr">tagged</span><span class="p"> </span><span class="kr">record</span><span class="p"></span>
    <span class="n">Age</span> <span class="o">:</span> <span class="n">Natural</span><span class="p">;</span>
  <span class="k">end record</span><span class="p">;</span>
  <span class="kr">pragma</span><span class="p"> </span><span class="n">Convention</span> <span class="o">(</span><span class="n">C_Plus_Plus</span><span class="p">,</span> <span class="n">Animal</span><span class="o">)</span><span class="p">;</span>

  <span class="k">procedure </span><span class="nf">Set_Age</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="kr">out</span><span class="p"> </span><span class="n">Animal</span><span class="p">;</span> <span class="n">Age</span> <span class="o">:</span> <span class="n">Integer</span><span class="o">)</span><span class="p">;</span>
  <span class="kr">pragma</span><span class="p"> </span><span class="n">Export</span> <span class="o">(</span><span class="n">C_Plus_Plus</span><span class="p">,</span> <span class="n">Set_Age</span><span class="o">)</span><span class="p">;</span>

  <span class="k">function </span><span class="nf">Age</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="n">Animal</span><span class="o">)</span> <span class="kr">return</span><span class="p"> </span><span class="n">Integer</span><span class="p">;</span>
  <span class="kr">pragma</span><span class="p"> </span><span class="n">Export</span> <span class="o">(</span><span class="n">C_Plus_Plus</span><span class="p">,</span> <span class="n">Age</span><span class="o">)</span><span class="p">;</span>

  <span class="k">function </span><span class="nf">New_Animal</span> <span class="kr">return</span><span class="p"> </span><span class="n">Animal</span><span class="na">&#39;Class</span><span class="p">;</span>
  <span class="kr">pragma</span><span class="p"> </span><span class="n">Export</span> <span class="o">(</span><span class="n">C_Plus_Plus</span><span class="p">,</span> <span class="n">New_Animal</span><span class="o">)</span><span class="p">;</span>

  <span class="kr">type</span><span class="p"> </span><span class="n">Dog</span> <span class="kr">is</span><span class="p"> </span><span class="kr">new</span><span class="p"> </span><span class="n">Animal</span> <span class="kr">and</span><span class="p"> </span><span class="n">Carnivore</span> <span class="kr">and</span><span class="p"> </span><span class="n">Domestic</span> <span class="kr">with</span><span class="p"> </span><span class="kr">record</span><span class="p"></span>
    <span class="n">Tooth_Count</span> <span class="o">:</span> <span class="n">Natural</span><span class="p">;</span>
    <span class="n">Owner</span>       <span class="o">:</span> <span class="n">String</span> <span class="o">(</span><span class="mi">1</span> <span class="o">..</span> <span class="mi">30</span><span class="o">)</span><span class="p">;</span>
  <span class="k">end record</span><span class="p">;</span>
  <span class="kr">pragma</span><span class="p"> </span><span class="n">Convention</span> <span class="o">(</span><span class="n">C_Plus_Plus</span><span class="p">,</span> <span class="n">Dog</span><span class="o">)</span><span class="p">;</span>

  <span class="k">function </span><span class="nf">Number_Of_Teeth</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="n">Dog</span><span class="o">)</span> <span class="kr">return</span><span class="p"> </span><span class="n">Natural</span><span class="p">;</span>
  <span class="kr">pragma</span><span class="p"> </span><span class="n">Export</span> <span class="o">(</span><span class="n">C_Plus_Plus</span><span class="p">,</span> <span class="n">Number_Of_Teeth</span><span class="o">)</span><span class="p">;</span>

  <span class="k">procedure </span><span class="nf">Set_Owner</span> <span class="o">(</span><span class="n">A</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="kr">out</span><span class="p"> </span><span class="n">Dog</span><span class="p">;</span> <span class="n">Name</span> <span class="o">:</span> <span class="n">Chars_Ptr</span><span class="o">)</span><span class="p">;</span>
  <span class="kr">pragma</span><span class="p"> </span><span class="n">Export</span> <span class="o">(</span><span class="n">C_Plus_Plus</span><span class="p">,</span> <span class="n">Set_Owner</span><span class="o">)</span><span class="p">;</span>

  <span class="k">function </span><span class="nf">New_Dog</span> <span class="kr">return</span><span class="p"> </span><span class="n">Dog</span><span class="na">&#39;Class</span><span class="p">;</span>
  <span class="kr">pragma</span><span class="p"> </span><span class="n">Export</span> <span class="o">(</span><span class="n">C_Plus_Plus</span><span class="p">,</span> <span class="n">New_Dog</span><span class="o">)</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Animals</span><span class="p">;</span>
</pre></div>
</div>
<p>Compared with our previous example the only differences are the use of
<code class="docutils literal notranslate"><span class="pre">pragma</span> <span class="pre">Convention</span></code> (instead of <code class="docutils literal notranslate"><span class="pre">pragma</span> <span class="pre">Import</span></code>), and the use of
<code class="docutils literal notranslate"><span class="pre">pragma</span> <span class="pre">Export</span></code> to indicate to the GNAT compiler that the primitives will
be available to C++. Thanks to the ABI compatibility, on the C++ side there is
nothing else to be done; as explained above, the only requirement is that all
the primitives and components are declared in exactly the same order.</p>
<p>For completeness, let us see a brief C++ main program that uses the
declarations available in <code class="file docutils literal notranslate"><span class="pre">animals.h</span></code> (presented in our first example) to
import and use the declarations from the Ada side, properly initializing and
finalizing the Ada run-time system along the way:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&quot;animals.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">Check_Carnivore</span> <span class="p">(</span><span class="n">Carnivore</span> <span class="o">*</span><span class="n">obj</span><span class="p">)</span> <span class="p">{...}</span>
<span class="kt">void</span> <span class="nf">Check_Domestic</span> <span class="p">(</span><span class="n">Domestic</span> <span class="o">*</span><span class="n">obj</span><span class="p">)</span>   <span class="p">{...}</span>
<span class="kt">void</span> <span class="nf">Check_Animal</span> <span class="p">(</span><span class="n">Animal</span> <span class="o">*</span><span class="n">obj</span><span class="p">)</span>       <span class="p">{...}</span>
<span class="kt">void</span> <span class="nf">Check_Dog</span> <span class="p">(</span><span class="n">Dog</span> <span class="o">*</span><span class="n">obj</span><span class="p">)</span>             <span class="p">{...}</span>

<span class="k">extern</span> <span class="s">&quot;C&quot;</span> <span class="p">{</span>
  <span class="kt">void</span> <span class="n">adainit</span> <span class="p">(</span><span class="kt">void</span><span class="p">);</span>
  <span class="kt">void</span> <span class="nf">adafinal</span> <span class="p">(</span><span class="kt">void</span><span class="p">);</span>
  <span class="n">Dog</span><span class="o">*</span> <span class="nf">new_dog</span> <span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">test</span> <span class="p">()</span>
<span class="p">{</span>
  <span class="n">Dog</span> <span class="o">*</span><span class="n">obj</span> <span class="o">=</span> <span class="n">new_dog</span><span class="p">();</span>  <span class="c1">// Ada constructor</span>
  <span class="n">Check_Carnivore</span> <span class="p">(</span><span class="n">obj</span><span class="p">);</span> <span class="c1">// Check secondary DT</span>
  <span class="n">Check_Domestic</span> <span class="p">(</span><span class="n">obj</span><span class="p">);</span>  <span class="c1">// Check secondary DT</span>
  <span class="n">Check_Animal</span> <span class="p">(</span><span class="n">obj</span><span class="p">);</span>    <span class="c1">// Check primary DT</span>
  <span class="n">Check_Dog</span> <span class="p">(</span><span class="n">obj</span><span class="p">);</span>       <span class="c1">// Check primary DT</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span> <span class="p">()</span>
<span class="p">{</span>
  <span class="n">adainit</span> <span class="p">();</span>  <span class="n">test</span><span class="p">();</span>  <span class="n">adafinal</span> <span class="p">();</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="generating-ada-bindings-for-c-and-c-headers">
<span id="id70"></span><h3><span class="section-number">3.11.4. </span>Generating Ada Bindings for C and C++ headers<a class="headerlink" href="#generating-ada-bindings-for-c-and-c-headers" title="Permalink to this headline">¶</a></h3>
<span class="target" id="index-144"></span><span class="target" id="index-145"></span><p id="index-146">GNAT includes a binding generator for C and C++ headers which is
intended to do 95% of the tedious work of generating Ada specs from C
or C++ header files.</p>
<p>Note that this capability is not intended to generate 100% correct Ada specs,
and will is some cases require manual adjustments, although it can often
be used out of the box in practice.</p>
<p>Some of the known limitations include:</p>
<ul class="simple">
<li><p>only very simple character constant macros are translated into Ada
constants. Function macros (macros with arguments) are partially translated
as comments, to be completed manually if needed.</p></li>
<li><p>some extensions (e.g. vector types) are not supported</p></li>
<li><p>pointers to pointers or complex structures are mapped to System.Address</p></li>
<li><p>identifiers with identical name (except casing) will generate compilation
errors (e.g. <code class="docutils literal notranslate"><span class="pre">shm_get</span></code> vs <code class="docutils literal notranslate"><span class="pre">SHM_GET</span></code>).</p></li>
</ul>
<p>The code is generated using Ada 2012 syntax, which makes it easier to interface
with other languages. In most cases you can still use the generated binding
even if your code is compiled using earlier versions of Ada (e.g. <code class="docutils literal notranslate"><span class="pre">-gnat95</span></code>).</p>
<div class="section" id="running-the-binding-generator">
<span id="id71"></span><h4><span class="section-number">3.11.4.1. </span>Running the Binding Generator<a class="headerlink" href="#running-the-binding-generator" title="Permalink to this headline">¶</a></h4>
<p>The binding generator is part of the <code class="docutils literal notranslate"><span class="pre">gcc</span></code> compiler and can be
invoked via the <code class="switch docutils literal notranslate"><span class="pre">-fdump-ada-spec</span></code> switch, which will generate Ada
spec files for the header files specified on the command line, and all
header files needed by these files transitively. For example:</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>$ g++ -c -fdump-ada-spec -C /usr/include/time.h
$ gcc -c *.ads
</pre></div>
</div>
<p>will generate, under GNU/Linux, the following files: <code class="file docutils literal notranslate"><span class="pre">time_h.ads</span></code>,
<code class="file docutils literal notranslate"><span class="pre">bits_time_h.ads</span></code>, <code class="file docutils literal notranslate"><span class="pre">stddef_h.ads</span></code>, <code class="file docutils literal notranslate"><span class="pre">bits_types_h.ads</span></code> which
correspond to the files <code class="file docutils literal notranslate"><span class="pre">/usr/include/time.h</span></code>,
<code class="file docutils literal notranslate"><span class="pre">/usr/include/bits/time.h</span></code>, etc…, and will then compile these Ada specs
in Ada 2005 mode.</p>
<p>The <code class="switch docutils literal notranslate"><span class="pre">-C</span></code> switch tells <code class="docutils literal notranslate"><span class="pre">gcc</span></code> to extract comments from headers,
and will attempt to generate corresponding Ada comments.</p>
<p>If you want to generate a single Ada file and not the transitive closure, you
can use instead the <code class="switch docutils literal notranslate"><span class="pre">-fdump-ada-spec-slim</span></code> switch.</p>
<p>You can optionally specify a parent unit, of which all generated units will
be children, using <code class="switch docutils literal notranslate"><span class="pre">-fada-spec-parent=</span><em><span class="pre">unit</span></em></code>.</p>
<p>Note that we recommend when possible to use the <em>g++</em> driver to
generate bindings, even for most C headers, since this will in general
generate better Ada specs. For generating bindings for C++ headers, it is
mandatory to use the <em>g++</em> command, or <em>gcc -x c++</em> which
is equivalent in this case. If <em>g++</em> cannot work on your C headers
because of incompatibilities between C and C++, then you can fallback to
<code class="docutils literal notranslate"><span class="pre">gcc</span></code> instead.</p>
<p>For an example of better bindings generated from the C++ front-end,
the name of the parameters (when available) are actually ignored by the C
front-end. Consider the following C header:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">extern</span> <span class="kt">void</span> <span class="nf">foo</span> <span class="p">(</span><span class="kt">int</span> <span class="n">variable</span><span class="p">);</span>
</pre></div>
</div>
<p>with the C front-end, <code class="docutils literal notranslate"><span class="pre">variable</span></code> is ignored, and the above is handled as:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">extern</span> <span class="kt">void</span> <span class="nf">foo</span> <span class="p">(</span><span class="kt">int</span><span class="p">);</span>
</pre></div>
</div>
<p>generating a generic:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="k">procedure </span><span class="nf">foo</span> <span class="o">(</span><span class="n">param1</span> <span class="o">:</span> <span class="n">int</span><span class="o">)</span><span class="p">;</span>
</pre></div>
</div>
<p>with the C++ front-end, the name is available, and we generate:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="k">procedure </span><span class="nf">foo</span> <span class="o">(</span><span class="n">variable</span> <span class="o">:</span> <span class="n">int</span><span class="o">)</span><span class="p">;</span>
</pre></div>
</div>
<p>In some cases, the generated bindings will be more complete or more meaningful
when defining some macros, which you can do via the <code class="switch docutils literal notranslate"><span class="pre">-D</span></code> switch. This
is for example the case with <code class="file docutils literal notranslate"><span class="pre">Xlib.h</span></code> under GNU/Linux:</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>$ g++ -c -fdump-ada-spec -DXLIB_ILLEGAL_ACCESS -C /usr/include/X11/Xlib.h
</pre></div>
</div>
<p>The above will generate more complete bindings than a straight call without
the <code class="switch docutils literal notranslate"><span class="pre">-DXLIB_ILLEGAL_ACCESS</span></code> switch.</p>
<p>In other cases, it is not possible to parse a header file in a stand-alone
manner, because other include files need to be included first. In this
case, the solution is to create a small header file including the needed
<code class="docutils literal notranslate"><span class="pre">#include</span></code> and possible <code class="docutils literal notranslate"><span class="pre">#define</span></code> directives. For example, to
generate Ada bindings for <code class="file docutils literal notranslate"><span class="pre">readline/readline.h</span></code>, you need to first
include <code class="file docutils literal notranslate"><span class="pre">stdio.h</span></code>, so you can create a file with the following two
lines in e.g. <code class="file docutils literal notranslate"><span class="pre">readline1.h</span></code>:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;readline/readline.h&gt;</span><span class="cp"></span>
</pre></div>
</div>
<p>and then generate Ada bindings from this file:</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>$ g++ -c -fdump-ada-spec readline1.h
</pre></div>
</div>
</div>
<div class="section" id="generating-bindings-for-c-headers">
<span id="id72"></span><h4><span class="section-number">3.11.4.2. </span>Generating Bindings for C++ Headers<a class="headerlink" href="#generating-bindings-for-c-headers" title="Permalink to this headline">¶</a></h4>
<p>Generating bindings for C++ headers is done using the same options, always
with the <em>g++</em> compiler. Note that generating Ada spec from C++ headers is a
much more complex job and support for C++ headers is much more limited that
support for C headers. As a result, you will need to modify the resulting
bindings by hand more extensively when using C++ headers.</p>
<p>In this mode, C++ classes will be mapped to Ada tagged types, constructors
will be mapped using the <code class="docutils literal notranslate"><span class="pre">CPP_Constructor</span></code> pragma, and when possible,
multiple inheritance of abstract classes will be mapped to Ada interfaces
(see the <em>Interfacing to C++</em> section in the <cite>GNAT Reference Manual</cite>
for additional information on interfacing to C++).</p>
<p>For example, given the following C++ header file:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Carnivore</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
   <span class="k">virtual</span> <span class="kt">int</span> <span class="n">Number_Of_Teeth</span> <span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Domestic</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
   <span class="k">virtual</span> <span class="kt">void</span> <span class="n">Set_Owner</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">Name</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Animal</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="kt">int</span> <span class="n">Age_Count</span><span class="p">;</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">Set_Age</span> <span class="p">(</span><span class="kt">int</span> <span class="n">New_Age</span><span class="p">);</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Dog</span> <span class="o">:</span> <span class="n">Animal</span><span class="p">,</span> <span class="n">Carnivore</span><span class="p">,</span> <span class="n">Domestic</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="kt">int</span>  <span class="n">Tooth_Count</span><span class="p">;</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">Owner</span><span class="p">;</span>

  <span class="k">virtual</span> <span class="kt">int</span>  <span class="nf">Number_Of_Teeth</span> <span class="p">();</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">Set_Owner</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">Name</span><span class="p">);</span>

  <span class="n">Dog</span><span class="p">();</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The corresponding Ada code is generated:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="k">package </span><span class="nf">Class_Carnivore</span> <span class="kr">is</span><span class="p"></span>
  <span class="kr">type</span><span class="p"> </span><span class="n">Carnivore</span> <span class="kr">is</span><span class="p"> </span><span class="kr">limited</span><span class="p"> </span><span class="kr">interface</span><span class="p">;</span>
  <span class="kr">pragma</span><span class="p"> </span><span class="n">Import</span> <span class="o">(</span><span class="n">CPP</span><span class="p">,</span> <span class="n">Carnivore</span><span class="o">)</span><span class="p">;</span>

  <span class="k">function </span><span class="nf">Number_Of_Teeth</span> <span class="o">(</span><span class="n">this</span> <span class="o">:</span> <span class="kr">access</span><span class="p"> </span><span class="n">Carnivore</span><span class="o">)</span> <span class="kr">return</span><span class="p"> </span><span class="n">int</span> <span class="kr">is</span><span class="p"> </span><span class="kr">abstract</span><span class="p">;</span>
<span class="kr">end</span><span class="p">;</span>
<span class="kr">use</span><span class="nn"> Class_Carnivore;</span>

<span class="k">package </span><span class="nf">Class_Domestic</span> <span class="kr">is</span><span class="p"></span>
  <span class="kr">type</span><span class="p"> </span><span class="n">Domestic</span> <span class="kr">is</span><span class="p"> </span><span class="kr">limited</span><span class="p"> </span><span class="kr">interface</span><span class="p">;</span>
  <span class="kr">pragma</span><span class="p"> </span><span class="n">Import</span> <span class="o">(</span><span class="n">CPP</span><span class="p">,</span> <span class="n">Domestic</span><span class="o">)</span><span class="p">;</span>

  <span class="k">procedure </span><span class="nf">Set_Owner</span>
    <span class="o">(</span><span class="n">this</span> <span class="o">:</span> <span class="kr">access</span><span class="p"> </span><span class="n">Domestic</span><span class="p">;</span>
     <span class="n">Name</span> <span class="o">:</span> <span class="n">Interfaces.C.Strings.chars_ptr</span><span class="o">)</span> <span class="kr">is</span><span class="p"> </span><span class="kr">abstract</span><span class="p">;</span>
<span class="kr">end</span><span class="p">;</span>
<span class="kr">use</span><span class="nn"> Class_Domestic;</span>

<span class="k">package </span><span class="nf">Class_Animal</span> <span class="kr">is</span><span class="p"></span>
  <span class="kr">type</span><span class="p"> </span><span class="n">Animal</span> <span class="kr">is</span><span class="p"> </span><span class="kr">tagged</span><span class="p"> </span><span class="kr">limited</span><span class="p"> </span><span class="kr">record</span><span class="p"></span>
    <span class="n">Age_Count</span> <span class="o">:</span> <span class="kr">aliased</span><span class="p"> </span><span class="n">int</span><span class="p">;</span>
  <span class="k">end record</span><span class="p">;</span>
  <span class="kr">pragma</span><span class="p"> </span><span class="n">Import</span> <span class="o">(</span><span class="n">CPP</span><span class="p">,</span> <span class="n">Animal</span><span class="o">)</span><span class="p">;</span>

  <span class="k">procedure </span><span class="nf">Set_Age</span> <span class="o">(</span><span class="n">this</span> <span class="o">:</span> <span class="kr">access</span><span class="p"> </span><span class="n">Animal</span><span class="p">;</span> <span class="n">New_Age</span> <span class="o">:</span> <span class="n">int</span><span class="o">)</span><span class="p">;</span>
  <span class="kr">pragma</span><span class="p"> </span><span class="n">Import</span> <span class="o">(</span><span class="n">CPP</span><span class="p">,</span> <span class="n">Set_Age</span><span class="p">,</span> <span class="s">&quot;_ZN6Animal7Set_AgeEi&quot;</span><span class="o">)</span><span class="p">;</span>
<span class="kr">end</span><span class="p">;</span>
<span class="kr">use</span><span class="nn"> Class_Animal;</span>

<span class="k">package </span><span class="nf">Class_Dog</span> <span class="kr">is</span><span class="p"></span>
  <span class="kr">type</span><span class="p"> </span><span class="n">Dog</span> <span class="kr">is</span><span class="p"> </span><span class="kr">new</span><span class="p"> </span><span class="n">Animal</span> <span class="kr">and</span><span class="p"> </span><span class="n">Carnivore</span> <span class="kr">and</span><span class="p"> </span><span class="n">Domestic</span> <span class="kr">with</span><span class="p"> </span><span class="kr">record</span><span class="p"></span>
    <span class="n">Tooth_Count</span> <span class="o">:</span> <span class="kr">aliased</span><span class="p"> </span><span class="n">int</span><span class="p">;</span>
    <span class="n">Owner</span> <span class="o">:</span> <span class="n">Interfaces.C.Strings.chars_ptr</span><span class="p">;</span>
  <span class="k">end record</span><span class="p">;</span>
  <span class="kr">pragma</span><span class="p"> </span><span class="n">Import</span> <span class="o">(</span><span class="n">CPP</span><span class="p">,</span> <span class="n">Dog</span><span class="o">)</span><span class="p">;</span>

  <span class="k">function </span><span class="nf">Number_Of_Teeth</span> <span class="o">(</span><span class="n">this</span> <span class="o">:</span> <span class="kr">access</span><span class="p"> </span><span class="n">Dog</span><span class="o">)</span> <span class="kr">return</span><span class="p"> </span><span class="n">int</span><span class="p">;</span>
  <span class="kr">pragma</span><span class="p"> </span><span class="n">Import</span> <span class="o">(</span><span class="n">CPP</span><span class="p">,</span> <span class="n">Number_Of_Teeth</span><span class="p">,</span> <span class="s">&quot;_ZN3Dog15Number_Of_TeethEv&quot;</span><span class="o">)</span><span class="p">;</span>

  <span class="k">procedure </span><span class="nf">Set_Owner</span>
    <span class="o">(</span><span class="n">this</span> <span class="o">:</span> <span class="kr">access</span><span class="p"> </span><span class="n">Dog</span><span class="p">;</span> <span class="n">Name</span> <span class="o">:</span> <span class="n">Interfaces.C.Strings.chars_ptr</span><span class="o">)</span><span class="p">;</span>
  <span class="kr">pragma</span><span class="p"> </span><span class="n">Import</span> <span class="o">(</span><span class="n">CPP</span><span class="p">,</span> <span class="n">Set_Owner</span><span class="p">,</span> <span class="s">&quot;_ZN3Dog9Set_OwnerEPc&quot;</span><span class="o">)</span><span class="p">;</span>

  <span class="k">function </span><span class="nf">New_Dog</span> <span class="kr">return</span><span class="p"> </span><span class="n">Dog</span><span class="p">;</span>
  <span class="kr">pragma</span><span class="p"> </span><span class="n">CPP_Constructor</span> <span class="o">(</span><span class="n">New_Dog</span><span class="o">)</span><span class="p">;</span>
  <span class="kr">pragma</span><span class="p"> </span><span class="n">Import</span> <span class="o">(</span><span class="n">CPP</span><span class="p">,</span> <span class="n">New_Dog</span><span class="p">,</span> <span class="s">&quot;_ZN3DogC1Ev&quot;</span><span class="o">)</span><span class="p">;</span>
<span class="kr">end</span><span class="p">;</span>
<span class="kr">use</span><span class="nn"> Class_Dog;</span>
</pre></div>
</div>
</div>
<div class="section" id="switches">
<span id="switches-for-ada-binding-generation"></span><h4><span class="section-number">3.11.4.3. </span>Switches<a class="headerlink" href="#switches" title="Permalink to this headline">¶</a></h4>
<dl class="simple" id="index-147">
<dt><code class="switch docutils literal notranslate"><span class="pre">-fdump-ada-spec</span></code></dt><dd><p>Generate Ada spec files for the given header files transitively (including
all header files that these headers depend upon).</p>
</dd>
</dl>
<dl class="simple" id="index-148">
<dt><code class="switch docutils literal notranslate"><span class="pre">-fdump-ada-spec-slim</span></code></dt><dd><p>Generate Ada spec files for the header files specified on the command line
only.</p>
</dd>
</dl>
<dl class="simple" id="index-149">
<dt><code class="switch docutils literal notranslate"><span class="pre">-fada-spec-parent=</span><em><span class="pre">unit</span></em></code></dt><dd><p>Specifies that all files generated by <code class="switch docutils literal notranslate"><span class="pre">-fdump-ada-spec</span></code> are
to be child units of the specified parent unit.</p>
</dd>
</dl>
<dl class="simple" id="index-150">
<dt><code class="switch docutils literal notranslate"><span class="pre">-C</span></code></dt><dd><p>Extract comments from headers and generate Ada comments in the Ada spec files.</p>
</dd>
</dl>
</div>
</div>
<div class="section" id="generating-c-headers-for-ada-specifications">
<span id="id73"></span><h3><span class="section-number">3.11.5. </span>Generating C Headers for Ada Specifications<a class="headerlink" href="#generating-c-headers-for-ada-specifications" title="Permalink to this headline">¶</a></h3>
<span class="target" id="index-151"></span><p id="index-152">GNAT includes a C header generator for Ada specifications which supports
Ada types that have a direct mapping to C types. This includes in particular
support for:</p>
<ul class="simple">
<li><p>Scalar types</p></li>
<li><p>Constrained arrays</p></li>
<li><p>Records (untagged)</p></li>
<li><p>Composition of the above types</p></li>
<li><p>Constant declarations</p></li>
<li><p>Object declarations</p></li>
<li><p>Subprogram declarations</p></li>
</ul>
<div class="section" id="running-the-c-header-generator">
<h4><span class="section-number">3.11.5.1. </span>Running the C Header Generator<a class="headerlink" href="#running-the-c-header-generator" title="Permalink to this headline">¶</a></h4>
<p>The C header generator is part of the GNAT compiler and can be invoked via
the <code class="switch docutils literal notranslate"><span class="pre">-gnatceg</span></code> combination of switches, which will generate a <code class="file docutils literal notranslate"><span class="pre">.h</span></code>
file corresponding to the given input file (Ada spec or body). Note that
only spec files are processed in any case, so giving a spec or a body file
as input is equivalent. For example:</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>$ gcc -c -gnatceg pack1.ads
</pre></div>
</div>
<p>will generate a self-contained file called <code class="file docutils literal notranslate"><span class="pre">pack1.h</span></code> including
common definitions from the Ada Standard package, followed by the
definitions included in <code class="file docutils literal notranslate"><span class="pre">pack1.ads</span></code>, as well as all the other units
withed by this file.</p>
<p>For instance, given the following Ada files:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="k">package </span><span class="nf">Pack2</span> <span class="kr">is</span><span class="p"></span>
   <span class="kr">type</span><span class="p"> </span><span class="n">Int</span> <span class="kr">is</span><span class="p"> </span><span class="kr">range</span><span class="p"> </span><span class="mi">1</span> <span class="o">..</span> <span class="mi">10</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Pack2</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="kr">with</span><span class="p"> </span><span class="n">Pack2</span><span class="p">;</span>

<span class="k">package </span><span class="nf">Pack1</span> <span class="kr">is</span><span class="p"></span>
   <span class="kr">type</span><span class="p"> </span><span class="n">Rec</span> <span class="kr">is</span><span class="p"> </span><span class="kr">record</span><span class="p"></span>
      <span class="n">Field1</span><span class="p">,</span> <span class="n">Field2</span> <span class="o">:</span> <span class="n">Pack2.Int</span><span class="p">;</span>
   <span class="k">end record</span><span class="p">;</span>

   <span class="n">Global</span> <span class="o">:</span> <span class="n">Rec</span> <span class="o">:=</span> <span class="o">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="o">)</span><span class="p">;</span>

   <span class="k">procedure </span><span class="nf">Proc1</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="n">Rec</span><span class="o">)</span><span class="p">;</span>
   <span class="k">procedure </span><span class="nf">Proc2</span> <span class="o">(</span><span class="n">R</span> <span class="o">:</span> <span class="kr">in</span><span class="p"> </span><span class="kr">out</span><span class="p"> </span><span class="n">Rec</span><span class="o">)</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Pack1</span><span class="p">;</span>
</pre></div>
</div>
<p>The above <code class="docutils literal notranslate"><span class="pre">gcc</span></code> command will generate the following <code class="file docutils literal notranslate"><span class="pre">pack1.h</span></code> file:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/* Standard definitions skipped */</span>
<span class="cp">#ifndef PACK2_ADS</span>
<span class="cp">#define PACK2_ADS</span>
<span class="k">typedef</span> <span class="n">short_short_integer</span> <span class="n">pack2__TintB</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">pack2__TintB</span> <span class="n">pack2__int</span><span class="p">;</span>
<span class="cp">#endif </span><span class="cm">/* PACK2_ADS */</span><span class="cp"></span>

<span class="cp">#ifndef PACK1_ADS</span>
<span class="cp">#define PACK1_ADS</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">_pack1__rec</span> <span class="p">{</span>
  <span class="n">pack2__int</span> <span class="n">field1</span><span class="p">;</span>
  <span class="n">pack2__int</span> <span class="n">field2</span><span class="p">;</span>
<span class="p">}</span> <span class="n">pack1__rec</span><span class="p">;</span>
<span class="k">extern</span> <span class="n">pack1__rec</span> <span class="n">pack1__global</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="nf">pack1__proc1</span><span class="p">(</span><span class="k">const</span> <span class="n">pack1__rec</span> <span class="n">r</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="nf">pack1__proc2</span><span class="p">(</span><span class="n">pack1__rec</span> <span class="o">*</span><span class="n">r</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* PACK1_ADS */</span><span class="cp"></span>
</pre></div>
</div>
<p>You can then <code class="docutils literal notranslate"><span class="pre">include</span></code> <code class="file docutils literal notranslate"><span class="pre">pack1.h</span></code> from a C source file and use the types,
call subprograms, reference objects, and constants.</p>
</div>
</div>
</div>
<div class="section" id="gnat-and-other-compilation-models">
<span id="id74"></span><h2><span class="section-number">3.12. </span>GNAT and Other Compilation Models<a class="headerlink" href="#gnat-and-other-compilation-models" title="Permalink to this headline">¶</a></h2>
<p>This section compares the GNAT model with the approaches taken in
other environents, first the C/C++ model and then the mechanism that
has been used in other Ada systems, in particular those traditionally
used for Ada 83.</p>
<div class="section" id="comparison-between-gnat-and-c-c-compilation-models">
<span id="id75"></span><h3><span class="section-number">3.12.1. </span>Comparison between GNAT and C/C++ Compilation Models<a class="headerlink" href="#comparison-between-gnat-and-c-c-compilation-models" title="Permalink to this headline">¶</a></h3>
<p>The GNAT model of compilation is close to the C and C++ models. You can
think of Ada specs as corresponding to header files in C. As in C, you
don’t need to compile specs; they are compiled when they are used. The
Ada <em>with</em> is similar in effect to the <code class="docutils literal notranslate"><span class="pre">#include</span></code> of a C
header.</p>
<p>One notable difference is that, in Ada, you may compile specs separately
to check them for semantic and syntactic accuracy. This is not always
possible with C headers because they are fragments of programs that have
less specific syntactic or semantic rules.</p>
<p>The other major difference is the requirement for running the binder,
which performs two important functions. First, it checks for
consistency. In C or C++, the only defense against assembling
inconsistent programs lies outside the compiler, in a makefile, for
example. The binder satisfies the Ada requirement that it be impossible
to construct an inconsistent program when the compiler is used in normal
mode.</p>
<p id="index-153">The other important function of the binder is to deal with elaboration
issues. There are also elaboration issues in C++ that are handled
automatically. This automatic handling has the advantage of being
simpler to use, but the C++ programmer has no control over elaboration.
Where <code class="docutils literal notranslate"><span class="pre">gnatbind</span></code> might complain there was no valid order of
elaboration, a C++ compiler would simply construct a program that
malfunctioned at run time.</p>
</div>
<div class="section" id="comparison-between-gnat-and-conventional-ada-library-models">
<span id="id76"></span><h3><span class="section-number">3.12.2. </span>Comparison between GNAT and Conventional Ada Library Models<a class="headerlink" href="#comparison-between-gnat-and-conventional-ada-library-models" title="Permalink to this headline">¶</a></h3>
<p>This section is intended for Ada programmers who have
used an Ada compiler implementing the traditional Ada library
model, as described in the Ada Reference Manual.</p>
<p id="index-154">In GNAT, there is no ‘library’ in the normal sense. Instead, the set of
source files themselves acts as the library. Compiling Ada programs does
not generate any centralized information, but rather an object file and
a ALI file, which are of interest only to the binder and linker.
In a traditional system, the compiler reads information not only from
the source file being compiled, but also from the centralized library.
This means that the effect of a compilation depends on what has been
previously compiled. In particular:</p>
<ul class="simple">
<li><p>When a unit is <em>with</em>ed, the unit seen by the compiler corresponds
to the version of the unit most recently compiled into the library.</p></li>
<li><p>Inlining is effective only if the necessary body has already been
compiled into the library.</p></li>
<li><p>Compiling a unit may obsolete other units in the library.</p></li>
</ul>
<p>In GNAT, compiling one unit never affects the compilation of any other
units because the compiler reads only source files. Only changes to source
files can affect the results of a compilation. In particular:</p>
<ul>
<li><p>When a unit is <em>with</em>ed, the unit seen by the compiler corresponds
to the source version of the unit that is currently accessible to the
compiler.</p>
</li>
<li id="index-155"><p>Inlining requires the appropriate source files for the package or
subprogram bodies to be available to the compiler. Inlining is always
effective, independent of the order in which units are compiled.</p></li>
<li><p>Compiling a unit never affects any other compilations. The editing of
sources may cause previous compilations to be out of date if they
depended on the source file being modified.</p></li>
</ul>
<p>The most important result of these differences is that order of compilation
is never significant in GNAT. There is no situation in which one is
required to do one compilation before another. What shows up as order of
compilation requirements in the traditional Ada library becomes, in
GNAT, simple source dependencies; in other words, there is only a set
of rules saying what source files must be present when a file is
compiled.</p>
</div>
</div>
<div class="section" id="using-gnat-files-with-external-tools">
<span id="id77"></span><h2><span class="section-number">3.13. </span>Using GNAT Files with External Tools<a class="headerlink" href="#using-gnat-files-with-external-tools" title="Permalink to this headline">¶</a></h2>
<p>This section explains how files that are produced by GNAT may be
used with tools designed for other languages.</p>
<div class="section" id="using-other-utility-programs-with-gnat">
<span id="id78"></span><h3><span class="section-number">3.13.1. </span>Using Other Utility Programs with GNAT<a class="headerlink" href="#using-other-utility-programs-with-gnat" title="Permalink to this headline">¶</a></h3>
<p>The object files generated by GNAT are in standard system format and in
particular the debugging information uses this format. This means
programs generated by GNAT can be used with existing utilities that
depend on these formats.</p>
<p>In general, any utility program that works with C will also often work with
Ada programs generated by GNAT. This includes software utilities such as
gprof (a profiling program), gdb (the FSF debugger), and utilities such
as Purify.</p>
</div>
<div class="section" id="the-external-symbol-naming-scheme-of-gnat">
<span id="id79"></span><h3><span class="section-number">3.13.2. </span>The External Symbol Naming Scheme of GNAT<a class="headerlink" href="#the-external-symbol-naming-scheme-of-gnat" title="Permalink to this headline">¶</a></h3>
<p>In order to interpret the output from GNAT, when using tools that are
originally intended for use with other languages, it is useful to
understand the conventions used to generate link names from the Ada
entity names.</p>
<p>All link names are in all lowercase letters. With the exception of library
procedure names, the mechanism used is simply to use the full expanded
Ada name with dots replaced by double underscores. For example, suppose
we have the following package spec:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="k">package </span><span class="nf">QRS</span> <span class="kr">is</span><span class="p"></span>
   <span class="n">MN</span> <span class="o">:</span> <span class="n">Integer</span><span class="p">;</span>
<span class="k">end </span><span class="nf">QRS</span><span class="p">;</span>
</pre></div>
</div>
<p id="index-156">The variable <code class="docutils literal notranslate"><span class="pre">MN</span></code> has a full expanded Ada name of <code class="docutils literal notranslate"><span class="pre">QRS.MN</span></code>, so
the corresponding link name is <code class="docutils literal notranslate"><span class="pre">qrs__mn</span></code>.
Of course if a <code class="docutils literal notranslate"><span class="pre">pragma</span> <span class="pre">Export</span></code> is used this may be overridden:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="k">package </span><span class="nf">Exports</span> <span class="kr">is</span><span class="p"></span>
   <span class="n">Var1</span> <span class="o">:</span> <span class="n">Integer</span><span class="p">;</span>
   <span class="kr">pragma</span><span class="p"> </span><span class="n">Export</span> <span class="o">(</span><span class="n">Var1</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">External_Name</span> <span class="o">=&gt;</span> <span class="s">&quot;var1_name&quot;</span><span class="o">)</span><span class="p">;</span>
   <span class="n">Var2</span> <span class="o">:</span> <span class="n">Integer</span><span class="p">;</span>
   <span class="kr">pragma</span><span class="p"> </span><span class="n">Export</span> <span class="o">(</span><span class="n">Var2</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">Link_Name</span> <span class="o">=&gt;</span> <span class="s">&quot;var2_link_name&quot;</span><span class="o">)</span><span class="p">;</span>
<span class="k">end </span><span class="nf">Exports</span><span class="p">;</span>
</pre></div>
</div>
<p>In this case, the link name for <code class="docutils literal notranslate"><span class="pre">Var1</span></code> is whatever link name the
C compiler would assign for the C function <code class="docutils literal notranslate"><span class="pre">var1_name</span></code>. This typically
would be either <code class="docutils literal notranslate"><span class="pre">var1_name</span></code> or <code class="docutils literal notranslate"><span class="pre">_var1_name</span></code>, depending on operating
system conventions, but other possibilities exist. The link name for
<code class="docutils literal notranslate"><span class="pre">Var2</span></code> is <code class="docutils literal notranslate"><span class="pre">var2_link_name</span></code>, and this is not operating system
dependent.</p>
<p>One exception occurs for library level procedures. A potential ambiguity
arises between the required name <code class="docutils literal notranslate"><span class="pre">_main</span></code> for the C main program,
and the name we would otherwise assign to an Ada library level procedure
called <code class="docutils literal notranslate"><span class="pre">Main</span></code> (which might well not be the main program).</p>
<p>To avoid this ambiguity, we attach the prefix <code class="docutils literal notranslate"><span class="pre">_ada_</span></code> to such
names. So if we have a library level procedure such as:</p>
<div class="highlight-ada notranslate"><div class="highlight"><pre><span></span><span class="k">procedure </span><span class="nf">Hello</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">String</span><span class="o">)</span><span class="p">;</span>
</pre></div>
</div>
<p>the external name of this procedure will be <code class="docutils literal notranslate"><span class="pre">_ada_hello</span></code>.</p>
</div>
</div>
</div>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../gnat_ugn.html">
              <img class="logo" src="../_static/adacore_transparent.png" alt="Logo"/>
            </a></p>
  <h3><a href="../gnat_ugn.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">3. The GNAT Compilation Model</a><ul>
<li><a class="reference internal" href="#source-representation">3.1. Source Representation</a></li>
<li><a class="reference internal" href="#foreign-language-representation">3.2. Foreign Language Representation</a><ul>
<li><a class="reference internal" href="#latin-1">3.2.1. Latin-1</a></li>
<li><a class="reference internal" href="#other-8-bit-codes">3.2.2. Other 8-Bit Codes</a></li>
<li><a class="reference internal" href="#wide-character-encodings">3.2.3. Wide_Character Encodings</a></li>
<li><a class="reference internal" href="#wide-wide-character-encodings">3.2.4. Wide_Wide_Character Encodings</a></li>
</ul>
</li>
<li><a class="reference internal" href="#file-naming-topics-and-utilities">3.3. File Naming Topics and Utilities</a><ul>
<li><a class="reference internal" href="#file-naming-rules">3.3.1. File Naming Rules</a></li>
<li><a class="reference internal" href="#using-other-file-names">3.3.2. Using Other File Names</a></li>
<li><a class="reference internal" href="#alternative-file-naming-schemes">3.3.3. Alternative File Naming Schemes</a></li>
<li><a class="reference internal" href="#handling-arbitrary-file-naming-conventions-with-gnatname">3.3.4. Handling Arbitrary File Naming Conventions with <code class="docutils literal notranslate"><span class="pre">gnatname</span></code></a><ul>
<li><a class="reference internal" href="#arbitrary-file-naming-conventions">3.3.4.1. Arbitrary File Naming Conventions</a></li>
<li><a class="reference internal" href="#running-gnatname">3.3.4.2. Running <code class="docutils literal notranslate"><span class="pre">gnatname</span></code></a></li>
<li><a class="reference internal" href="#switches-for-gnatname">3.3.4.3. Switches for <code class="docutils literal notranslate"><span class="pre">gnatname</span></code></a></li>
<li><a class="reference internal" href="#examples-of-gnatname-usage">3.3.4.4. Examples of <code class="docutils literal notranslate"><span class="pre">gnatname</span></code> Usage</a></li>
</ul>
</li>
<li><a class="reference internal" href="#file-name-krunching-with-gnatkr">3.3.5. File Name Krunching with <code class="docutils literal notranslate"><span class="pre">gnatkr</span></code></a><ul>
<li><a class="reference internal" href="#about-gnatkr">3.3.5.1. About <code class="docutils literal notranslate"><span class="pre">gnatkr</span></code></a></li>
<li><a class="reference internal" href="#using-gnatkr">3.3.5.2. Using <code class="docutils literal notranslate"><span class="pre">gnatkr</span></code></a></li>
<li><a class="reference internal" href="#krunching-method">3.3.5.3. Krunching Method</a></li>
<li><a class="reference internal" href="#examples-of-gnatkr-usage">3.3.5.4. Examples of <code class="docutils literal notranslate"><span class="pre">gnatkr</span></code> Usage</a></li>
</ul>
</li>
<li><a class="reference internal" href="#renaming-files-with-gnatchop">3.3.6. Renaming Files with <code class="docutils literal notranslate"><span class="pre">gnatchop</span></code></a><ul>
<li><a class="reference internal" href="#handling-files-with-multiple-units">3.3.6.1. Handling Files with Multiple Units</a></li>
<li><a class="reference internal" href="#operating-gnatchop-in-compilation-mode">3.3.6.2. Operating gnatchop in Compilation Mode</a></li>
<li><a class="reference internal" href="#command-line-for-gnatchop">3.3.6.3. Command Line for <code class="docutils literal notranslate"><span class="pre">gnatchop</span></code></a></li>
<li><a class="reference internal" href="#switches-for-gnatchop">3.3.6.4. Switches for <code class="docutils literal notranslate"><span class="pre">gnatchop</span></code></a></li>
<li><a class="reference internal" href="#examples-of-gnatchop-usage">3.3.6.5. Examples of <code class="docutils literal notranslate"><span class="pre">gnatchop</span></code> Usage</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#configuration-pragmas">3.4. Configuration Pragmas</a><ul>
<li><a class="reference internal" href="#handling-of-configuration-pragmas">3.4.1. Handling of Configuration Pragmas</a></li>
<li><a class="reference internal" href="#the-configuration-pragmas-files">3.4.2. The Configuration Pragmas Files</a></li>
</ul>
</li>
<li><a class="reference internal" href="#generating-object-files">3.5. Generating Object Files</a></li>
<li><a class="reference internal" href="#source-dependencies">3.6. Source Dependencies</a></li>
<li><a class="reference internal" href="#the-ada-library-information-files">3.7. The Ada Library Information Files</a></li>
<li><a class="reference internal" href="#binding-an-ada-program">3.8. Binding an Ada Program</a></li>
<li><a class="reference internal" href="#gnat-and-libraries">3.9. GNAT and Libraries</a><ul>
<li><a class="reference internal" href="#introduction-to-libraries-in-gnat">3.9.1. Introduction to Libraries in GNAT</a></li>
<li><a class="reference internal" href="#general-ada-libraries">3.9.2. General Ada Libraries</a><ul>
<li><a class="reference internal" href="#building-a-library">3.9.2.1. Building a library</a></li>
<li><a class="reference internal" href="#installing-a-library">3.9.2.2. Installing a library</a></li>
<li><a class="reference internal" href="#using-a-library">3.9.2.3. Using a library</a></li>
</ul>
</li>
<li><a class="reference internal" href="#stand-alone-ada-libraries">3.9.3. Stand-alone Ada Libraries</a><ul>
<li><a class="reference internal" href="#introduction-to-stand-alone-libraries">3.9.3.1. Introduction to Stand-alone Libraries</a></li>
<li><a class="reference internal" href="#building-a-stand-alone-library">3.9.3.2. Building a Stand-alone Library</a></li>
<li><a class="reference internal" href="#creating-a-stand-alone-library-to-be-used-in-a-non-ada-context">3.9.3.3. Creating a Stand-alone Library to be used in a non-Ada context</a></li>
<li><a class="reference internal" href="#restrictions-in-stand-alone-libraries">3.9.3.4. Restrictions in Stand-alone Libraries</a></li>
</ul>
</li>
<li><a class="reference internal" href="#rebuilding-the-gnat-run-time-library">3.9.4. Rebuilding the GNAT Run-Time Library</a></li>
</ul>
</li>
<li><a class="reference internal" href="#conditional-compilation">3.10. Conditional Compilation</a><ul>
<li><a class="reference internal" href="#modeling-conditional-compilation-in-ada">3.10.1. Modeling Conditional Compilation in Ada</a><ul>
<li><a class="reference internal" href="#use-of-boolean-constants">3.10.1.1. Use of Boolean Constants</a></li>
<li><a class="reference internal" href="#debugging-a-special-case">3.10.1.2. Debugging - A Special Case</a></li>
<li><a class="reference internal" href="#conditionalizing-declarations">3.10.1.3. Conditionalizing Declarations</a></li>
<li><a class="reference internal" href="#use-of-alternative-implementations">3.10.1.4. Use of Alternative Implementations</a></li>
<li><a class="reference internal" href="#preprocessing">3.10.1.5. Preprocessing</a></li>
</ul>
</li>
<li><a class="reference internal" href="#preprocessing-with-gnatprep">3.10.2. Preprocessing with <code class="docutils literal notranslate"><span class="pre">gnatprep</span></code></a><ul>
<li><a class="reference internal" href="#preprocessing-symbols">3.10.2.1. Preprocessing Symbols</a></li>
<li><a class="reference internal" href="#using-gnatprep">3.10.2.2. Using <code class="docutils literal notranslate"><span class="pre">gnatprep</span></code></a></li>
<li><a class="reference internal" href="#switches-for-gnatprep">3.10.2.3. Switches for <code class="docutils literal notranslate"><span class="pre">gnatprep</span></code></a></li>
<li><a class="reference internal" href="#form-of-definitions-file">3.10.2.4. Form of Definitions File</a></li>
<li><a class="reference internal" href="#form-of-input-text-for-gnatprep">3.10.2.5. Form of Input Text for <code class="docutils literal notranslate"><span class="pre">gnatprep</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#integrated-preprocessing">3.10.3. Integrated Preprocessing</a></li>
</ul>
</li>
<li><a class="reference internal" href="#mixed-language-programming">3.11. Mixed Language Programming</a><ul>
<li><a class="reference internal" href="#interfacing-to-c">3.11.1. Interfacing to C</a></li>
<li><a class="reference internal" href="#calling-conventions">3.11.2. Calling Conventions</a></li>
<li><a class="reference internal" href="#building-mixed-ada-and-c-programs">3.11.3. Building Mixed Ada and C++ Programs</a><ul>
<li><a class="reference internal" href="#id65">3.11.3.1. Interfacing to C++</a></li>
<li><a class="reference internal" href="#linking-a-mixed-c-ada-program">3.11.3.2. Linking a Mixed C++ &amp; Ada Program</a></li>
<li><a class="reference internal" href="#a-simple-example">3.11.3.3. A Simple Example</a></li>
<li><a class="reference internal" href="#interfacing-with-c-constructors">3.11.3.4. Interfacing with C++ constructors</a></li>
<li><a class="reference internal" href="#interfacing-with-c-at-the-class-level">3.11.3.5. Interfacing with C++ at the Class Level</a></li>
</ul>
</li>
<li><a class="reference internal" href="#generating-ada-bindings-for-c-and-c-headers">3.11.4. Generating Ada Bindings for C and C++ headers</a><ul>
<li><a class="reference internal" href="#running-the-binding-generator">3.11.4.1. Running the Binding Generator</a></li>
<li><a class="reference internal" href="#generating-bindings-for-c-headers">3.11.4.2. Generating Bindings for C++ Headers</a></li>
<li><a class="reference internal" href="#switches">3.11.4.3. Switches</a></li>
</ul>
</li>
<li><a class="reference internal" href="#generating-c-headers-for-ada-specifications">3.11.5. Generating C Headers for Ada Specifications</a><ul>
<li><a class="reference internal" href="#running-the-c-header-generator">3.11.5.1. Running the C Header Generator</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#gnat-and-other-compilation-models">3.12. GNAT and Other Compilation Models</a><ul>
<li><a class="reference internal" href="#comparison-between-gnat-and-c-c-compilation-models">3.12.1. Comparison between GNAT and C/C++ Compilation Models</a></li>
<li><a class="reference internal" href="#comparison-between-gnat-and-conventional-ada-library-models">3.12.2. Comparison between GNAT and Conventional Ada Library Models</a></li>
</ul>
</li>
<li><a class="reference internal" href="#using-gnat-files-with-external-tools">3.13. Using GNAT Files with External Tools</a><ul>
<li><a class="reference internal" href="#using-other-utility-programs-with-gnat">3.13.1. Using Other Utility Programs with GNAT</a></li>
<li><a class="reference internal" href="#the-external-symbol-naming-scheme-of-gnat">3.13.2. The External Symbol Naming Scheme of GNAT</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="getting_started_with_gnat.html"
                        title="previous chapter"><span class="section-number">2. </span>Getting Started with GNAT</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="building_executable_programs_with_gnat.html"
                        title="next chapter"><span class="section-number">4. </span>Building Executable Programs with GNAT</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/gnat_ugn/the_gnat_compilation_model.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="building_executable_programs_with_gnat.html" title="4. Building Executable Programs with GNAT"
             >next</a> |</li>
        <li class="right" >
          <a href="getting_started_with_gnat.html" title="2. Getting Started with GNAT"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../gnat_ugn.html">GNAT User&#39;s Guide for Native Platforms 2021 documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><span class="section-number">3. </span>The GNAT Compilation Model</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2008-2021, Free Software Foundation.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 3.2.1.
    </div>
  </body>
</html>