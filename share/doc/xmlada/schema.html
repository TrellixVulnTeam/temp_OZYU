
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>6. The Schema module &#8212; XML/Ada: the XML Library for Ada 2021 documentation</title>
    <link rel="stylesheet" href="_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/language_data.js"></script>
    <link rel="shortcut icon" href="_static/favicon.ico"/>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="7. Using the library" href="using.html" />
    <link rel="prev" title="5. The DOM module" href="dom.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="using.html" title="7. Using the library"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="dom.html" title="5. The DOM module"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">XML/Ada: the XML Library for Ada 2021 documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><span class="section-number">6. </span>The Schema module</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="the-schema-module">
<span id="id1"></span><h1><span class="section-number">6. </span>The Schema module<a class="headerlink" href="#the-schema-module" title="Permalink to this headline">¶</a></h1>
<div class="section" id="xml-grammars">
<h2><span class="section-number">6.1. </span>XML Grammars<a class="headerlink" href="#xml-grammars" title="Permalink to this headline">¶</a></h2>
<p>There are several steps that applications must go through when they have to use
XML files:</p>
<ul>
<li><p>Make sure the XML file is well-formed.</p>
<p>This is a basic step where we ensure that XML tags are correctly nested, that
closing tags have the same names as the matching opening tags, that attribute
values are quoted,…. This corresponds to a syntactic parser in a compiler.</p>
<p>This step does not depend on the application domain. One file that is
well-formed will always be so, no matter in what context you use it.</p>
</li>
<li><p>Make sure the contents of the XML file is semantically valid.</p>
<p>Depending on the application domain, we must ensure that the content of the
file makes sense. This step is highly application dependent, and a file that
is usable in one application might not be usable in another one.</p>
<p>This is the phase in which the application needs to check whether a given XML
file has all its required attributes, whether the children of an XML tag are
the expected ones, whether the type of the attributes is valid,….</p>
</li>
<li><p>Use the XML file in the application.</p>
<p>This is done through the already-described SAX or DOM parsers</p>
</li>
</ul>
<p>The first phase is mandatory, and necessarily enforced by XML/Ada. You will not
be able to access the contents of the XML file if it isn’t well-formed.</p>
<p>The second phase is provided by the Schema module in XML/Ada. Although such
constraints can be checked at the application level, with ad hoc code, it is
generally easier to maintain a separate file that describes the valid semantic
contents of the file, than maintain specific code when the semantic changes. It
is also difficult not to forget special cases when doing the validating through
a set of <cite>if</cite> statements in the Ada code.</p>
<p>XML provides two ways to describe additional constraints that a file must
satisfy in order to be considered as valid.</p>
<ul>
<li><p>DTD</p>
<p>The Document Type Description is the original way to do this. They come
directly from the ancestor of XML, SGML. All XML parsers must parse the DTD,
and report events if the user is using SAX. However, not all parsers are able
to validate the document against a DTD (XML/Ada doesn’t).</p>
<p>Their use tends to greatly diminish. Among their limitations are a limited
capability to express constraints on the order of tag children, the fact that
the DTDs themselves are written in a separate language totally different from
XML, and that users must learn this language as a result.</p>
</li>
<li><p>XML Schema</p>
<p>The XML schemas are replacing the DTDs. They are written in XML, and provide
an extensive capability to describe what the XML document should look like.
In fact, almost all Ada types can be described in an XML schema, including
range constraints, arrays, records, type inheritance, abstract types,….</p>
<p>It is for instance possible to indicate that the value of a preference, in
our example, must be a string of length 6. Any other length will result in a
validation error.</p>
</li>
</ul>
</div>
<div class="section" id="xml-schema-syntax">
<h2><span class="section-number">6.2. </span>XML Schema Syntax<a class="headerlink" href="#xml-schema-syntax" title="Permalink to this headline">¶</a></h2>
<p>The Schema module provides subprograms and types to parse an XML schema and
validate an XML document with this schema.</p>
<p>This document does not provide a full documentation on the format of XML
Schemas. This is extensive, has several obscure features, which, although
supported by XML/Ada, are of little use in most practical usages. We refer the
reader to the first part of the XML Schema specification, which is designed as
a tutorial (<a class="reference external" href="http://www.w3.org/TR/xmlschema-0/">http://www.w3.org/TR/xmlschema-0/</a>).</p>
<p>The typical extension for a schema file is <code class="file docutils literal notranslate"><span class="pre">.xsd</span></code>.</p>
<p>A schema file must be a valid XML file, and thus start with the usual <cite>&lt;?xml
version=”1.0” ?&gt;</cite> line. The root node must be named <cite>schema</cite>, and belong to the
namespace (<a class="reference external" href="http://www.w3.org/2001/XMLSchema/">http://www.w3.org/2001/XMLSchema/</a>). The handling of namespaces is fairly
powerful, but also complex. A given XML document might have nodes belonging to
several namespaces, and thus several schema files might have to be loaded, each
defining one of the namespaces.</p>
<p>In the following simple example, we will not define our schema for a specific
namespace, and thus no special attribute is needed for the root node.  Thus,
our document will be organized as:</p>
<div class="highlight-xml notranslate"><div class="highlight"><pre><span></span><span class="cp">&lt;?xml version=&quot;1.0&quot; ?&gt;</span>
<span class="nt">&lt;xsd:schema</span> <span class="na">xmlns:xsd=</span><span class="s">&quot;http://www.w3.org/2001/XMLSchema&quot;</span><span class="nt">&gt;</span>
    ... rest of the description goes here ...
<span class="nt">&lt;/xsd:schema&gt;</span>
</pre></div>
</div>
<p>An XML schema does not enforce a specific root node in the XML documents it
validates. However, it must define all the valid elements that can be used in
the XML file. This is done through the <cite>&lt;element&gt;</cite> tag, which takes
one mandatory attribute, the name of the element we are defining.</p>
<p>The contents of the element is then defined in one of two ways:</p>
<ul>
<li><p>Through a <cite>type</cite> attribute.</p>
<p>Schemas come with a number of predefined simple types. A simple type is
such that an element of that type accepts no child node, and that its
contents must satisfy additional constraints (be an integer, a date,
…).</p>
<p>Among the predefined simple types (which are all defined in the namespace
<a class="reference external" href="http://www.w3.org/2001/XMLSchema/">http://www.w3.org/2001/XMLSchema/</a>),
one can find: <cite>string</cite>, <cite>integer</cite>, <cite>byte</cite>, <cite>date</cite>, <cite>time</cite>, <cite>dateTime</cite>,
<cite>boolean</cite>,…</p>
<p>If no additional constraint should be enforced on this simple type when
applied to the element, the type of the element is given through a <cite>type</cite>
attribute, as in:</p>
<div class="highlight-xml notranslate"><div class="highlight"><pre><span></span><span class="nt">&lt;xsd:element</span> <span class="na">name=</span><span class="s">&quot;tag1&quot;</span> <span class="na">type=</span><span class="s">&quot;xsd:string&quot;</span>  <span class="nt">/&gt;</span>
<span class="nt">&lt;xsd:element</span> <span class="na">name=</span><span class="s">&quot;tag2&quot;</span> <span class="na">type=</span><span class="s">&quot;xsd:boolean&quot;</span> <span class="nt">/&gt;</span>
</pre></div>
</div>
<p>which would accept the following XML files:</p>
<div class="highlight-xml notranslate"><div class="highlight"><pre><span></span><span class="nt">&lt;tag1&gt;</span>Any string is valid here<span class="nt">&lt;/tag1&gt;</span>
</pre></div>
</div>
<p>and:</p>
<div class="highlight-xml notranslate"><div class="highlight"><pre><span></span><span class="nt">&lt;tag2&gt;</span>true<span class="nt">&lt;/tag2&gt;</span>
</pre></div>
</div>
<p>but not:</p>
<div class="highlight-xml notranslate"><div class="highlight"><pre><span></span><span class="nt">&lt;tag2&gt;</span>String<span class="nt">&lt;/tag2&gt;</span>
</pre></div>
</div>
<p>As will be described later, it is possible to create new types in XML schema,
which are created with a name. Such new types can also be associated with the
element through the <cite>type</cite> attribute.</p>
</li>
<li><p>Through an inline type definition</p>
<p>If the element must accept child elements, or if a further constraint needs
to be enforced on the list of valid values, one must create the type. As
mentioned above, this can be done by creating a type separately and
referencing it by name, or through an inline type definition.</p>
<p>The syntax is mostly the same in both cases. Schemas distinguish between the
notion of simple types (that accept no child element) and complex types (that
accept child elements, and possibly text value).</p>
<p>To define a simple type, based on string, but that only allows a limited set
of values (similar to an Ada enumeration), one would create a restriction of
the standard string type, as in:</p>
<div class="highlight-xml notranslate"><div class="highlight"><pre><span></span><span class="nt">&lt;xsd:element</span> <span class="na">name=</span><span class="s">&quot;tag3&quot;</span><span class="nt">&gt;</span>
 <span class="nt">&lt;xsd:simpleType&gt;</span>
   <span class="nt">&lt;xsd:restriction</span> <span class="na">base=</span><span class="s">&quot;xsd:string&quot;</span><span class="nt">&gt;</span>
     <span class="nt">&lt;xsd:enumeration</span> <span class="na">value=</span><span class="s">&quot;value1&quot;</span> <span class="nt">/&gt;</span>
     <span class="nt">&lt;xsd:enumeration</span> <span class="na">value=</span><span class="s">&quot;value2&quot;</span> <span class="nt">/&gt;</span>
   <span class="nt">&lt;/xsd:restriction&gt;</span>
 <span class="nt">&lt;/xsd:simpleType&gt;</span>
<span class="nt">&lt;/xsd:element&gt;</span>
</pre></div>
</div>
<p>Similarly, we could create an integer type whose valid range of values
is between 10 and 20, as in:</p>
<div class="highlight-xml notranslate"><div class="highlight"><pre><span></span><span class="nt">&lt;xsd:element</span> <span class="na">name=</span><span class="s">&quot;tag4&quot;</span><span class="nt">&gt;</span>
 <span class="nt">&lt;xsd:simpleType&gt;</span>
   <span class="nt">&lt;xsd:restriction</span> <span class="na">base=</span><span class="s">&quot;xsd:byte&quot;</span><span class="nt">&gt;</span>
     <span class="nt">&lt;xsd:minInclusive</span> <span class="na">value=</span><span class="s">&quot;10&quot;</span> <span class="nt">/&gt;</span>
     <span class="nt">&lt;xsd:maxInclusive</span> <span class="na">value=</span><span class="s">&quot;20&quot;</span> <span class="nt">/&gt;</span>
   <span class="nt">&lt;/xsd:restriction&gt;</span>
 <span class="nt">&lt;/xsd:simpleType&gt;</span>
<span class="nt">&lt;/xsd:element&gt;</span>
</pre></div>
</div>
<p>Complex types allow elements to have child nodes, as well as attributes. The
list of valid attributes is created by a set of <cite>&lt;xsd:attribute&gt;</cite> tags, and
the list of valid child nodes is generally defined either through a
<cite>&lt;xsd:choice&gt;</cite> or a <cite>&lt;xsd:sequence&gt;</cite> node (although it is possible to
indicate that any child node is authorized, among other things).</p>
<p><cite>&lt;xsd:choice&gt;</cite> indicates the children can appear in any order, whereas
<cite>&lt;xsd:sequence&gt;</cite> enforces a specific order on children.</p>
<p>In both cases, extra attributes can be specified to indicate the number of
times the sequence or choice itself can be repeated, or that each child node
can appear.</p>
<p>For instance, we can indicate that <cite>tag5</cite> accepts between 1 and 4 child
nodes, chosen among <cite>tag6</cite> and <cite>tag7</cite>, but that the latter, if
present, can only appear once. In addition, tag5 accepts one optional
attribute. Note that the type of tag6 and tag7 is here specified through a
<cite>type</cite> attribute, although it could in turn be defined inline:</p>
<div class="highlight-xml notranslate"><div class="highlight"><pre><span></span>&lt;xsd:element name=&quot;tag5&quot;&gt;
  &lt;xsd:complexType&gt;
    &lt;xsd:choice&gt;
      &lt;xsd:element name=&quot;tag6&quot; type=&quot;xsd:string&quot;
                   minOccurs=&quot;1&quot; maxOccurs=&quot;3/&gt;
      &lt;xsd:element name=&quot;tag7&quot; type=&quot;xsd:string&quot; maxOccurs=&quot;1&quot; /&gt;
    &lt;/xsd:choice&gt;
    &lt;xsd:attribute name=&quot;attr&quot; type=&quot;xsd:boolean&quot; use=&quot;optional&quot; /&gt;
  &lt;/xsd:complexType&gt;
&lt;/xsd:element&gt;
</pre></div>
</div>
<p>In the example above, if <cite>tag6</cite> was defined elsewhere in the
schema, we could use a reference to it, instead of duplicating its
type definition, as in:</p>
<div class="highlight-xml notranslate"><div class="highlight"><pre><span></span><span class="nt">&lt;xsd:element</span> <span class="na">ref=</span><span class="s">&quot;tag6&quot;</span> <span class="nt">/&gt;</span>
</pre></div>
</div>
<p>If you need an element with no child element (just a string value),
but that accepts attributes, this also must be defined through a
complex type, as in:</p>
<div class="highlight-xml notranslate"><div class="highlight"><pre><span></span><span class="nt">&lt;xsd:element</span> <span class="na">name=</span><span class="s">&quot;tag8&quot;</span> <span class="nt">/&gt;</span>
  <span class="nt">&lt;xsd:complexType&gt;</span>
    <span class="nt">&lt;xsd:simpleContent&gt;</span>
      <span class="nt">&lt;xsd:extension</span> <span class="na">base=</span><span class="s">&quot;xsd:string&quot;</span><span class="nt">&gt;</span>
         <span class="nt">&lt;xsd:attribute</span> <span class="na">name=</span><span class="s">&quot;attr&quot;</span> <span class="na">type=</span><span class="s">&quot;xsd:boolean&quot;</span> <span class="nt">/&gt;</span>
      <span class="nt">&lt;/xsd:extension&gt;</span>
    <span class="nt">&lt;/xsd:simpleContent&gt;</span>
  <span class="nt">&lt;/xsd:complexType&gt;</span>
<span class="nt">&lt;/xsd:element&gt;</span>
</pre></div>
</div>
</li>
</ul>
<p>As mentioned before, instead of defining inline types, we could explicitly
declare them, and reference them in the element declaration later on:</p>
<div class="highlight-xml notranslate"><div class="highlight"><pre><span></span><span class="nt">&lt;xsd:simpleType</span> <span class="na">name=</span><span class="s">&quot;string_of_length_10&quot;</span><span class="nt">&gt;</span>
  <span class="nt">&lt;xsd:restriction</span> <span class="na">base=</span><span class="s">&quot;xsd:string&quot;</span> <span class="nt">/&gt;</span>
    <span class="nt">&lt;xsd:length</span> <span class="na">value=</span><span class="s">&quot;10&quot;</span><span class="nt">/&gt;</span>
  <span class="nt">&lt;/xsd:restriction&gt;</span>
<span class="nt">&lt;/xsd:simpleType&gt;</span>
<span class="nt">&lt;xsd:element</span> <span class="na">name=</span><span class="s">&quot;tag9&quot;</span> <span class="na">type=</span><span class="s">&quot;string_of_length_10&quot;</span> <span class="nt">/&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="connecting-xml-documents-and-schemas">
<h2><span class="section-number">6.3. </span>Connecting XML documents and schemas<a class="headerlink" href="#connecting-xml-documents-and-schemas" title="Permalink to this headline">¶</a></h2>
<p>There are several ways that XML/Ada uses to find what schema to use when
validating a file.</p>
<ul>
<li><p>Manually creating the grammar.</p>
<p>The schema module contains the package <cite>Schema.Validators</cite> which
allows you to create a grammar by hand. It is very low-level, and it is
likely that you will never need to use it. It is used internally mostly,
and when creating the schema which is used to validate schema files
themselves.</p>
</li>
<li><p>Explicitly parsing a schema file</p>
<p>Parsing a schema file can be done through a call to parse for a reader
derived from <cite>Schema.Schema_Readers.Schema_reader</cite>.  As usual, you
call <cite>Parse</cite>, and pass it an input source. As output, you get
access to a grammar, that can then be given to another instance of a
<cite>Schema.Readers.Validating_Reader</cite>.</p>
<p>This technique will generally be used when you need to validate several
XML files with the same grammar: you parse the grammar only once, and
then reuse its instance, instead of reparsing the <code class="file docutils literal notranslate"><span class="pre">.xsd</span></code> file every
time:</p>
<div class="highlight-ada notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kn">with</span> <span class="nn">Ada.Text_IO</span><span class="p">;</span>   <span class="kn">use</span> <span class="nn">Ada.Text_IO</span><span class="p">;</span>
<span class="kn">with</span> <span class="nn">Schema.Schema_Readers</span><span class="p">,</span> <span class="n">Schema</span><span class="p">.</span><span class="n">Validators</span><span class="p">,</span> <span class="n">Input_Sources</span><span class="p">.</span><span class="n">File</span><span class="p">;</span>
<span class="kn">use</span>  <span class="nn">Schema.Schema_Readers</span><span class="p">,</span> <span class="n">Schema</span><span class="p">.</span><span class="n">Validators</span><span class="p">,</span> <span class="n">Input_Sources</span><span class="p">.</span><span class="n">File</span><span class="p">;</span>

<span class="kd">procedure</span> <span class="nf">SchemaExample2</span> <span class="kr">is</span>
   <span class="n">Grammar</span> <span class="p">:</span> <span class="n">XML_Grammar</span><span class="p">;</span>
   <span class="n">Schema</span>  <span class="p">:</span> <span class="n">Schema_Reader</span><span class="p">;</span>
   <span class="n">Read</span>    <span class="p">:</span> <span class="n">File_Input</span><span class="p">;</span>
<span class="kr">begin</span>
   <span class="n">Open</span> <span class="p">(</span><span class="s">&quot;file.xsd&quot;</span><span class="p">,</span> <span class="n">Read</span><span class="p">);</span>
   <span class="n">Parse</span> <span class="p">(</span><span class="n">Schema</span><span class="p">,</span> <span class="n">Read</span><span class="p">);</span>
   <span class="n">Close</span> <span class="p">(</span><span class="n">Read</span><span class="p">);</span>

   <span class="n">Grammar</span> <span class="p">:=</span> <span class="n">Get_Grammar</span> <span class="p">(</span><span class="n">Schema</span><span class="p">);</span>

 <span class="kr">exception</span>
    <span class="kr">when</span> <span class="n">XML_Validation_Error</span> <span class="p">|</span> <span class="n">XML_Not_Implemented</span> <span class="p">=&gt;</span>
       <span class="n">Put_Line</span> <span class="p">(</span><span class="s">&quot;ERROR: &quot;</span> <span class="o">&amp;</span> <span class="n">Get_Error_Message</span> <span class="p">(</span><span class="n">Schema</span><span class="p">));</span>
<span class="kr">end</span> <span class="nf">SchemaExample2</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p>In the example above, the schema file itself is validated against the
official schema for schema files.</p>
<p>The resulting grammar object is in fact a collection of parsed schema
files, each associated with its own namespace. It can be kept as long as
you need it in your application. Memory will automatically be reclaimed
when no longer needed.</p>
<p>Every time you parse an XML file later on, you must associate the
Grammar with the parser:</p>
<div class="highlight-ada notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kr">declare</span>
   <span class="n">Read</span>      <span class="p">:</span> <span class="n">File_Input</span><span class="p">;</span>
   <span class="n">My_Reader</span> <span class="p">:</span> <span class="n">Validating_Reader</span><span class="p">;</span>
<span class="kr">begin</span>
   <span class="n">Set_Grammar</span> <span class="p">(</span><span class="n">My_Reader</span><span class="p">,</span> <span class="n">Grammar</span><span class="p">);</span>
   <span class="n">Set_Feature</span> <span class="p">(</span><span class="n">My_Reader</span><span class="p">,</span> <span class="n">Schema_Validation_Feature</span><span class="p">,</span> <span class="kc">True</span><span class="p">);</span>
   <span class="n">Open</span> <span class="p">(</span><span class="n">Xml_File</span><span class="p">.</span><span class="kr">all</span><span class="p">,</span> <span class="n">Read</span><span class="p">);</span>
   <span class="n">Parse</span> <span class="p">(</span><span class="n">My_Reader</span><span class="p">,</span> <span class="n">Read</span><span class="p">);</span>
   <span class="n">Close</span> <span class="p">(</span><span class="n">Read</span><span class="p">);</span>

<span class="kr">exception</span>
   <span class="kr">when</span> <span class="n">XML_Validation_Error</span> <span class="p">|</span> <span class="n">XML_Not_Implemented</span> <span class="p">=&gt;</span>
      <span class="n">Put_Line</span> <span class="p">(</span><span class="s">&quot;ERROR: &quot;</span> <span class="o">&amp;</span> <span class="n">Get_Error_Message</span> <span class="p">(</span><span class="n">My_reader</span><span class="p">));</span>
<span class="kr">end</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
</li>
<li><p>Implicitly parsing the schema</p>
<p>Two special attributes, defined in the Schema standard, can be used to
indicate, in an XML document itself, that it should be validated with
a specific schema.</p>
<p>These attributes are both defined in a special namespace,
<a class="reference external" href="http://www.w3.org/2001/XMLSchema-instance">http://www.w3.org/2001/XMLSchema-instance</a>.</p>
<ul>
<li><p><cite>xsi:noNamespaceSchemaLocation</cite></p>
<p>The value of this attribute is the name of a file that contains
the schema to use for elements that are not associated with a
specific namespace.</p>
</li>
<li><p><cite>xsi:schemaLocation</cite></p>
<p>This attribute is a list of strings, alternatively the prefix of
a namespace and the name of an xsd file to use for that
namespace. For instance, <cite>“ns1 file1.xsd ns2 file2.xsd”</cite>.</p>
</li>
</ul>
<p>When it encounters any of these two attributes, XML/Ada will
automatically parse the corresponding schema files, and use the result
to validate the file.</p>
<p>See the section below on optimizing the parsing of the grammars, as a
way to avoid parsing the same grammar multiple times.</p>
</li>
</ul>
</div>
<div class="section" id="validating-documents-with-sax">
<h2><span class="section-number">6.4. </span>Validating documents with SAX<a class="headerlink" href="#validating-documents-with-sax" title="Permalink to this headline">¶</a></h2>
<p>XML/Ada is quite unique in the category of XML parsers, since it allows the
validation of XML files when you are using an event-based parser with SAX.
Most other XML parsers only work on DOM trees.</p>
<p>Basing the validation on SAX is more efficient, since there is no need to read
the whole XML stream (or even the grammar) in memory before starting the
validation, and errors can be reported immediately.</p>
<p>It also requires less memory to run, and thus can validate large XML
documents.</p>
<p>It also means that even if you are using SAX, and not DOM, you still have
access to the validation features.</p>
<p>Validating an XML document while parsing it is basically done the same as when
using SAX itself. Instead of inheriting from <cite>Sax.Readers.Reader</cite>, your tagged
type must inherit from <cite>Schema.Readers.Validating_Reader</cite>.</p>
<p>As usual, you can still override the predefined primitive operations like
<cite>Start_Element</cite>, <cite>End_Element</cite>, …</p>
<p>Note the activation of the <cite>Schema_Validation_Feature</cite> feature, without which
no validation takes place:</p>
<div class="highlight-ada notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="c1">--</span>
<span class="c1">--  Copyright (C) 2017, AdaCore</span>
<span class="c1">--</span>

<span class="kn">with</span> <span class="nn">Ada.Text_IO</span><span class="p">;</span>        <span class="kn">use</span> <span class="nn">Ada.Text_IO</span><span class="p">;</span>
<span class="kn">with</span> <span class="nn">Sax.Readers</span><span class="p">;</span>        <span class="kn">use</span> <span class="nn">Sax.Readers</span><span class="p">;</span>
<span class="kn">with</span> <span class="nn">Schema.Readers</span><span class="p">;</span>     <span class="kn">use</span> <span class="nn">Schema.Readers</span><span class="p">;</span>
<span class="kn">with</span> <span class="nn">Schema.Validators</span><span class="p">;</span>
<span class="kn">with</span> <span class="nn">Input_Sources.File</span><span class="p">;</span> <span class="kn">use</span> <span class="nn">Input_Sources.File</span><span class="p">;</span>

<span class="kd">procedure</span> <span class="nf">SchemaExample</span> <span class="kr">is</span>
   <span class="n">Input</span> <span class="p">:</span> <span class="n">File_Input</span><span class="p">;</span>
   <span class="n">My_Reader</span> <span class="p">:</span> <span class="n">Validating_Reader</span><span class="p">;</span>
<span class="kr">begin</span>
   <span class="n">Set_Public_Id</span> <span class="p">(</span><span class="n">Input</span><span class="p">,</span> <span class="s">&quot;Preferences file&quot;</span><span class="p">);</span>
   <span class="n">Open</span> <span class="p">(</span><span class="s">&quot;pref.xml&quot;</span><span class="p">,</span> <span class="n">Input</span><span class="p">);</span>

   <span class="n">Set_Feature</span> <span class="p">(</span><span class="n">My_Reader</span><span class="p">,</span> <span class="n">Schema_Validation_Feature</span><span class="p">,</span> <span class="kc">True</span><span class="p">);</span>
   <span class="n">Parse</span> <span class="p">(</span><span class="n">My_Reader</span><span class="p">,</span> <span class="n">Input</span><span class="p">);</span>

   <span class="n">Close</span> <span class="p">(</span><span class="n">Input</span><span class="p">);</span>

<span class="kr">exception</span>
   <span class="kr">when</span> <span class="n">Schema</span><span class="p">.</span><span class="n">Validators</span><span class="p">.</span><span class="n">XML_Validation_Error</span> <span class="p">=&gt;</span>
      <span class="n">Put_Line</span> <span class="p">(</span><span class="s">&quot;ERROR: &quot;</span> <span class="o">&amp;</span> <span class="n">Get_Error_Message</span> <span class="p">(</span><span class="n">My_Reader</span><span class="p">));</span>
<span class="kr">end</span> <span class="nf">SchemaExample</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
</div>
<div class="section" id="validating-documents-with-dom">
<h2><span class="section-number">6.5. </span>Validating documents with DOM<a class="headerlink" href="#validating-documents-with-dom" title="Permalink to this headline">¶</a></h2>
<p>This is very similar to using DOM itself, except the base class of your
reader should be <cite>Schema.Dom_Readers.Tree_Reader</cite>. Going back to the
example described in <a class="reference internal" href="dom.html#using-dom"><span class="std std-ref">Using DOM</span></a>, you would use the following to
validate XML streams before generating the DOM tree.</p>
<div class="highlight-ada notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="c1">--</span>
<span class="c1">--  Copyright (C) 2017, AdaCore</span>
<span class="c1">--</span>

<span class="kn">with</span> <span class="nn">Input_Sources.File</span><span class="p">;</span> <span class="kn">use</span> <span class="nn">Input_Sources.File</span><span class="p">;</span>
<span class="kn">with</span> <span class="nn">Sax.Readers</span><span class="p">;</span>        <span class="kn">use</span> <span class="nn">Sax.Readers</span><span class="p">;</span>
<span class="kn">with</span> <span class="nn">DOM.Core</span><span class="p">;</span>           <span class="kn">use</span> <span class="nn">DOM.Core</span><span class="p">;</span>
<span class="kn">with</span> <span class="nn">Schema.Dom_Readers</span><span class="p">;</span> <span class="kn">use</span> <span class="nn">Schema.Dom_Readers</span><span class="p">;</span>

<span class="kd">procedure</span> <span class="nf">DomSchemaExample</span> <span class="kr">is</span>
   <span class="n">Input</span>  <span class="p">:</span> <span class="n">File_Input</span><span class="p">;</span>
   <span class="n">Reader</span> <span class="p">:</span> <span class="n">Schema</span><span class="p">.</span><span class="n">Dom_Readers</span><span class="p">.</span><span class="n">Tree_Reader</span><span class="p">;</span>
   <span class="n">Doc</span>    <span class="p">:</span> <span class="n">Document</span><span class="p">;</span>
<span class="kr">begin</span>
   <span class="n">Set_Public_Id</span> <span class="p">(</span><span class="n">Input</span><span class="p">,</span> <span class="s">&quot;Preferences file&quot;</span><span class="p">);</span>
   <span class="n">Open</span> <span class="p">(</span><span class="s">&quot;pref_with_xsd.xml&quot;</span><span class="p">,</span> <span class="n">Input</span><span class="p">);</span>

   <span class="n">Set_Feature</span> <span class="p">(</span><span class="n">Reader</span><span class="p">,</span> <span class="n">Validation_Feature</span><span class="p">,</span> <span class="kc">False</span><span class="p">);</span>

   <span class="n">Parse</span> <span class="p">(</span><span class="n">Reader</span><span class="p">,</span> <span class="n">Input</span><span class="p">);</span>
   <span class="n">Close</span> <span class="p">(</span><span class="n">Input</span><span class="p">);</span>

   <span class="n">Doc</span> <span class="p">:=</span> <span class="n">Get_Tree</span> <span class="p">(</span><span class="n">Reader</span><span class="p">);</span>

   <span class="n">Free</span> <span class="p">(</span><span class="n">Reader</span><span class="p">);</span>
<span class="kr">end</span> <span class="nf">DomSchemaExample</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
</div>
<div class="section" id="unsupported-schema-elements">
<h2><span class="section-number">6.6. </span>Unsupported schema elements<a class="headerlink" href="#unsupported-schema-elements" title="Permalink to this headline">¶</a></h2>
<p>Not all aspects of XML schemas are supported by XML/Ada.
In particular, it does not currently support XPath, so any part of the
schema that is related to XPath expressions (for instance <cite>&lt;xsd:key&gt;</cite>
and <cite>&lt;xsd:unique&gt;</cite>) are not supported currently.</p>
</div>
<div class="section" id="optimizing-the-parsing-of-grammars">
<h2><span class="section-number">6.7. </span>Optimizing the parsing of grammars<a class="headerlink" href="#optimizing-the-parsing-of-grammars" title="Permalink to this headline">¶</a></h2>
<p>It is often the case that a given <code class="file docutils literal notranslate"><span class="pre">.xsd</span></code> file will be reused multiple
times to validate XML documents. In such case, you do not want to parse the
file multiple times, but instead reuse an already existing <cite>XML_Grammar</cite>
object. Of course, this is a tradeoff between memory used to keep the
grammar in memory, and the time it would take to reparse the grammar.</p>
<p>This is easily done when you have a single <code class="file docutils literal notranslate"><span class="pre">.xsd</span></code> file to reuse
for all the XML files. Simply call <cite>Set_Grammar</cite> on the parser before
you parse the file, as in:</p>
<div class="highlight-ada notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kr">declare</span>
   <span class="no">G</span> <span class="p">:</span> <span class="kr">constant</span> <span class="n">XML_Grammar</span> <span class="p">:=</span> <span class="p">...;</span>  <span class="c1">--  parsed earlier</span>
   <span class="n">R</span> <span class="p">:</span> <span class="n">Validating_Reader</span><span class="p">;</span>
   <span class="n">F</span> <span class="p">:</span> <span class="n">File_Input</span><span class="p">;</span>
<span class="kr">begin</span>
   <span class="n">R</span><span class="p">.</span><span class="n">Set_Grammar</span> <span class="p">(</span><span class="n">G</span><span class="p">);</span>
   <span class="n">Open</span> <span class="p">(</span><span class="s">&quot;file.xml&quot;</span><span class="p">,</span> <span class="n">F</span><span class="p">);</span>
   <span class="n">R</span><span class="p">.</span><span class="n">Parse</span> <span class="p">(</span><span class="n">F</span><span class="p">);</span>
   <span class="n">Close</span> <span class="p">(</span><span class="n">F</span><span class="p">);</span>
   <span class="p">...;</span>  <span class="c1">--  Do something with the resulting tree</span>
<span class="kr">end</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p>The second use case is a bit more complex: you have several XSD files to
parse, and the XML files will need either of these. If you are using
namespaces, there is nothing special to do, and the same code as above
applies: you can simply parse each of the XSD files into the same
XML_Grammar, and then use that grammar to parse all the XML files,
as in:</p>
<div class="highlight-ada notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kr">declare</span>
   <span class="n">G</span> <span class="p">:</span> <span class="n">XML_Grammar</span><span class="p">;</span>
   <span class="n">S</span> <span class="p">:</span> <span class="n">Schema_Reader</span><span class="p">;</span>
   <span class="n">F</span> <span class="p">:</span> <span class="n">File_Input</span><span class="p">;</span>
   <span class="n">R</span> <span class="p">:</span> <span class="n">Validating_Reader</span><span class="p">;</span>
<span class="kr">begin</span>
   <span class="n">Open</span> <span class="p">(</span><span class="s">&quot;grammar1.xsd&quot;</span><span class="p">,</span> <span class="n">F</span><span class="p">);</span>
   <span class="n">S</span><span class="p">.</span><span class="n">Parse</span> <span class="p">(</span><span class="n">F</span><span class="p">);</span>
   <span class="n">F</span><span class="p">.</span><span class="n">Close</span><span class="p">;</span>

   <span class="n">Open</span> <span class="p">(</span><span class="s">&quot;grammar2.xsd&quot;</span><span class="p">,</span> <span class="n">F</span><span class="p">);</span>
   <span class="n">S</span><span class="p">.</span><span class="n">Parse</span> <span class="p">(</span><span class="n">F</span><span class="p">);</span>
   <span class="n">F</span><span class="p">.</span><span class="n">Close</span><span class="p">;</span>

   <span class="n">G</span> <span class="p">:=</span> <span class="n">S</span><span class="p">.</span><span class="n">Get_Grammar</span><span class="p">;</span>

   <span class="n">R</span><span class="p">.</span><span class="n">Set_Grammar</span> <span class="p">(</span><span class="n">G</span><span class="p">);</span>
   <span class="n">Open</span> <span class="p">(</span><span class="s">&quot;file.xml&quot;</span><span class="p">,</span> <span class="n">F</span><span class="p">);</span>
   <span class="n">R</span><span class="p">.</span><span class="n">Parse</span> <span class="p">(</span><span class="n">F</span><span class="p">);</span>
   <span class="n">F</span><span class="p">.</span><span class="n">Close</span><span class="p">;</span>
<span class="kr">end</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p>If however you are not using namespaces, you cannot use this technique, since
the grammar from the various XSD files would end up mixed up, and validation
will most likely fail. So instead you need to have one <cite>XML_Grammar</cite> per
XSD file, and then set the grammar on the reader dynamically. A full
example is given in the XML/Ada source distribution, in
<code class="file docutils literal notranslate"><span class="pre">tests/schema/multiple_xsd</span></code>. Here is an overview.</p>
<p>We first need to parse each of the XSD files into its own grammar:</p>
<div class="highlight-ada notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kr">declare</span>
   <span class="n">Symbols</span> <span class="p">:</span> <span class="n">Symbol_Table</span><span class="p">;</span>
   <span class="n">G1</span><span class="p">,</span> <span class="n">G2</span> <span class="p">:</span> <span class="n">XML_Grammar</span><span class="p">;</span>
   <span class="n">S</span>      <span class="p">:</span> <span class="n">Schema_Grammar</span><span class="p">;</span>
   <span class="n">F</span>      <span class="p">:</span> <span class="n">File_Input</span><span class="p">;</span>
<span class="kr">begin</span>
   <span class="c1">--  Since we are going to reuse grammars, we need to ensure their</span>
   <span class="c1">--  symbol tables (where internal strings are stored) across all</span>
   <span class="c1">--  involved parsers).</span>
   <span class="n">Symbols</span> <span class="p">:=</span> <span class="n">Allocate</span><span class="p">;</span>
   <span class="n">S</span><span class="p">.</span><span class="n">Set_Symbol_Table</span> <span class="p">(</span><span class="n">Symbols</span><span class="p">);</span>

   <span class="c1">--  Now we can parse each of the XSD file</span>
   <span class="n">Open</span> <span class="p">(</span><span class="s">&quot;algo1.xsd&quot;</span><span class="p">,</span> <span class="n">F</span><span class="p">);</span>
   <span class="n">S</span><span class="p">.</span><span class="n">Parse</span> <span class="p">(</span><span class="n">F</span><span class="p">);</span>
   <span class="n">F</span><span class="p">.</span><span class="n">Close</span><span class="p">;</span>
   <span class="n">G1</span> <span class="p">:=</span> <span class="n">S</span><span class="p">.</span><span class="n">Get_Grammar</span><span class="p">;</span>

   <span class="n">S</span><span class="p">.</span><span class="n">Set_Grammar</span> <span class="p">(</span><span class="n">No_Grammar</span><span class="p">);</span>  <span class="c1">--  reset</span>
   <span class="n">Open</span> <span class="p">(</span><span class="s">&quot;algo2.xsd&quot;</span><span class="p">,</span> <span class="n">F</span><span class="p">);</span>
   <span class="n">S</span><span class="p">.</span><span class="n">Parse</span> <span class="p">(</span><span class="n">F</span><span class="p">);</span>
   <span class="n">F</span><span class="p">.</span><span class="n">Close</span><span class="p">;</span>
   <span class="n">G2</span> <span class="p">:=</span> <span class="n">S</span><span class="p">.</span><span class="n">Get_Grammar</span><span class="p">;</span>
<span class="kr">end</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p>We then need to create a custom validating reader, which knows how to set
the grammar based on its name. This is done by overriding one of the
primitive operations of the parser:</p>
<div class="highlight-ada notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kr">declare</span>
   <span class="kd">type</span> <span class="kt">My_Reader</span> <span class="kr">is</span> <span class="kr">new</span> <span class="n">Validating_Reader</span> <span class="kr">with</span> <span class="kr">null record</span><span class="p">;</span>
   <span class="kr">overriding</span> <span class="kd">procedure</span> <span class="nf">Parse_Grammar</span>
      <span class="p">(</span><span class="nv">Self</span>          <span class="p">: </span><span class="nv">not</span> <span class="nv">null</span> <span class="nv">access</span> <span class="nv">Reader_With_Preloaded_XSD</span><span class="p">;</span>
       <span class="nv">URI</span><span class="p">,</span> <span class="nv">Xsd_File</span> <span class="p">: </span><span class="nv">Sax</span><span class="p">.</span><span class="nv">Symbols</span><span class="p">.</span><span class="nv">Symbol</span><span class="p">;</span>
       <span class="nv">Do_Create_NFA</span> <span class="p">: </span><span class="nv">Boolean</span> <span class="p">:=</span> <span class="nv">True</span><span class="p">)</span> <span class="kr">is</span>
   <span class="kr">begin</span>
      <span class="kr">if</span> <span class="n">Xsd_File</span> <span class="o">=</span> <span class="s">&quot;algo1.xsd&quot;</span> <span class="kr">then</span>
         <span class="n">Self</span><span class="p">.</span><span class="n">Set_Grammar</span> <span class="p">(</span><span class="n">G1</span><span class="p">);</span>
      <span class="kr">elsif</span> <span class="n">Xsd_File</span> <span class="o">=</span> <span class="s">&quot;algo2.xsd&quot;</span> <span class="kr">then</span>
         <span class="n">Self</span><span class="p">.</span><span class="n">Set_Grammar</span> <span class="p">(</span><span class="n">G2</span><span class="p">);</span>
      <span class="kr">end</span> <span class="kr">if</span><span class="p">;</span>
   <span class="kr">end</span> <span class="nf">Parse_Grammar</span><span class="p">;</span>

   <span class="n">R</span> <span class="p">:</span> <span class="n">My_Reader</span><span class="p">;</span>
<span class="kr">begin</span>
   <span class="c1">--  Also share the same symbol table</span>
   <span class="n">R</span><span class="p">.</span><span class="n">Set_Symbol_Table</span> <span class="p">(</span><span class="n">Symbols</span><span class="p">);</span>
   <span class="n">R</span><span class="p">.</span><span class="n">Set_Feature</span> <span class="p">(</span><span class="n">Schema_Validation_Feature</span><span class="p">,</span> <span class="kc">True</span><span class="p">);</span>

   <span class="n">Open</span> <span class="p">(</span><span class="s">&quot;test1.xml&quot;</span><span class="p">,</span> <span class="n">F</span><span class="p">);</span>
   <span class="n">R</span><span class="p">.</span><span class="n">Parse</span> <span class="p">(</span><span class="n">F</span><span class="p">);</span>
   <span class="n">F</span><span class="p">.</span><span class="n">Close</span><span class="p">;</span>
<span class="kr">end</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p>Where for instance <code class="file docutils literal notranslate"><span class="pre">test1.xml</span></code> contains:</p>
<div class="highlight-ada notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="highlight"><pre><span></span>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;root xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
      xsi:noNamespaceSchemaLocation=&quot;algo1.xsd&quot;&gt;
   &lt;child&gt;102&lt;/child&gt;
&lt;/root&gt;
</pre></div>
</td></tr></table></div>
</div>
</div>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="index.html">
              <img class="logo" src="_static/adacore_transparent.png" alt="Logo"/>
            </a></p>
  <h3><a href="index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">6. The Schema module</a><ul>
<li><a class="reference internal" href="#xml-grammars">6.1. XML Grammars</a></li>
<li><a class="reference internal" href="#xml-schema-syntax">6.2. XML Schema Syntax</a></li>
<li><a class="reference internal" href="#connecting-xml-documents-and-schemas">6.3. Connecting XML documents and schemas</a></li>
<li><a class="reference internal" href="#validating-documents-with-sax">6.4. Validating documents with SAX</a></li>
<li><a class="reference internal" href="#validating-documents-with-dom">6.5. Validating documents with DOM</a></li>
<li><a class="reference internal" href="#unsupported-schema-elements">6.6. Unsupported schema elements</a></li>
<li><a class="reference internal" href="#optimizing-the-parsing-of-grammars">6.7. Optimizing the parsing of grammars</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="dom.html"
                        title="previous chapter"><span class="section-number">5. </span>The DOM module</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="using.html"
                        title="next chapter"><span class="section-number">7. </span>Using the library</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/schema.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="using.html" title="7. Using the library"
             >next</a> |</li>
        <li class="right" >
          <a href="dom.html" title="5. The DOM module"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">XML/Ada: the XML Library for Ada 2021 documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><span class="section-number">6. </span>The Schema module</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2003-2021, AdaCore.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 3.2.1.
    </div>
  </body>
</html>